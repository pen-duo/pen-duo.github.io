<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title></title>
    <link href="/2021/03/03/Vue3%E9%80%A0%E8%BD%AE%E5%AD%90%E7%AC%94%E8%AE%B0/"/>
    <url>/2021/03/03/Vue3%E9%80%A0%E8%BD%AE%E5%AD%90%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="Vue3造轮子笔记"><a href="#Vue3造轮子笔记" class="headerlink" title="Vue3造轮子笔记"></a>Vue3造轮子笔记</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这段时间学习vue3造轮子，颇有心得，写一篇文章对整个造轮子的过程进行一个总结（PS：目前造的只是一个很小的ui框架，后续会慢慢的扩充轮子的数量并增加目前轮子的特性）</p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li>  使用vite搭建官网</li><li>  制作switch组件</li><li>  制作button组件</li><li>  制作dialog组件</li><li>  制作tabs组件</li><li>  装修自己的官网</li><li>  代码构建与发布</li></ul><h2 id="使用vite搭建官网"><a href="#使用vite搭建官网" class="headerlink" title="使用vite搭建官网"></a>使用vite搭建官网</h2><p>vite是vue3中的新的web开发构建工具，由于其原生ES模块的导入方式，可以实现闪电般的冷服务器启动。（体验过后不要太快，瞬间构建完成一个项目，瞬间启动）</p><ul><li>  全局安装create-vite-app</li></ul><p>yarn global add <a href="mailto:&#x63;&#x72;&#x65;&#97;&#116;&#101;&#45;&#118;&#x69;&#116;&#101;&#x2d;&#x61;&#x70;&#x70;&#64;&#49;&#46;&#49;&#x38;&#x2e;&#48;">&#x63;&#x72;&#x65;&#97;&#116;&#101;&#45;&#118;&#x69;&#116;&#101;&#x2d;&#x61;&#x70;&#x70;&#64;&#49;&#46;&#49;&#x38;&#x2e;&#48;</a></p><ul><li>  创建项目目录</li></ul><p>cva migu-ui 或者 create-vite-app migu-ui</p><p>这样就构建好了一个vue3项目</p><p>简单说一下vue2和vue3的区别</p><p>90%的写法完全一致，除了以下几点</p><ol><li> vue3的template支持多个根标签，vue2不支持</li><li> 创建Vue实例vue3用的是createApp(),而vue2使用的new Vue()</li><li> createApp(组件)，new Vue({template,render})</li></ol><h2 id="新建组件与vue-router"><a href="#新建组件与vue-router" class="headerlink" title="新建组件与vue-router"></a>新建组件与vue-router</h2><p>由于这次我们使用的是typescript进行整个项目的编写，所以router是ts文件，在引入.vue文件时会报错</p><p>因为ts只能理解ts文件，无法理解.vue文件</p><p>我们需要创建一个shim-vue.d.ts来解决这个问题，然后ts文件就不报错了</p><p>declare module ‘*.vue’{  import {ComponentOptions} from ‘vue’ const componentOptions:ComponentOptions export default componentOptions }</p><p>qn-ui采用的history模式的路由，整个路由的创建过程比较常规，就不赘述了</p><p>我这里只说明一下项目中vue3使用到的内容</p><p>需求:我们需要控制菜单栏的显示隐藏,即图中内容,在手机页面是可以控制显示隐藏的</p><p> <img src="https://cdn.nlark.com/yuque/0/2021/png/1554318/1612252795557-08b7f375-0912-4604-9f64-5c93120c7eba.png" alt="Snipaste_2021-02-02_15-59-49.png" title="Snipaste_2021-02-02_15-59-49.png"> </p><p>组件列表</p><p>Switch组件</p><p>Button组件</p><p>Dialog组件</p><p>Tabs组件</p><h2 id="使用provide和inject控制边栏显隐"><a href="#使用provide和inject控制边栏显隐" class="headerlink" title="使用provide和inject控制边栏显隐"></a>使用provide和inject控制边栏显隐</h2><p>1.首先在app中定义一个menuVisible，使用provide进行数据的共享</p><p>语法setup()和data,methods等平级,setup是vue3新特性,我们可以使用setup来取代vue2中的data,methods,生命周期等。</p><p>ref也属于vue新特性,用来将基础响应类型转响应式,在项目中,使用ref来定义一个bool类型的数据menuVisible，使用provide来将这个数据共享到子组件中。</p><p>2.然后我们在topnav组件，也就是顶部标签组件中拿到这个menuVisible，并提供一个函数，用来控制menuVisible变化</p><p>你看，setup已经完成了data和methods的工作了</p><p>3.然后我们在边栏中拿到menuVisible，通过v-if控制显隐</p><p>需要注意的是，setup函数需要将定义的内部函数，变量都return出来，要不然无法使用</p><p>4.解决在pc端,菜单栏隐藏的bug</p><p>按理说,上面的控制菜单栏显示隐藏的功能我们只需要在手机端实现即可,因此在pc端我们可以将menuVisible一致设置为true。</p><p>在provide变量menuVisible之前先判断一下屏幕宽度。</p><p>5.当在手机端菜单栏进行切换时,隐藏菜单栏。</p><p>afterEach函数会在切换路由时执行。</p><p>所以我们在切换菜单选项时只需要判断屏幕宽度,如果为手机端,则将menuVisible设置为true</p><h2 id="Switch组件的实现"><a href="#Switch组件的实现" class="headerlink" title="Switch组件的实现"></a>Switch组件的实现</h2><p>我们要造一个轮子，首先要明白需求，然后确定这个轮子中需要哪些值，哪些属性，最后再是写代码实现轮子</p><p>第一步：什么是switch组件，如图</p><p> <img src="https://cdn.nlark.com/yuque/0/2021/gif/1554318/1612253399651-817175f1-b91b-450b-84ae-d0662afd35b0.gif"> </p><p>可以控制是和否的组件</p><p>第二步：switch组件怎么用？</p><p>switch最基本的功能就是控制是否嘛，所以肯定要传一个value（bool），除此之外，我们还可以控制switch组件的大小，是否禁用等等</p><p>第三步：写代码</p><p>switch组件的样式很好实现，html结构，一个button里面一个span（小圆球）</p><p>然后通过两种不同的样式来控制是否状态的switch，加上过渡效果，就实现啦</p><p>关于数据的传输，外部组件需要传一个bool类型的value进来</p><p>然后我们在点击事件中，需要将这个值取反然后回传给父组件（注意：这里子组件一定不能去修改这个值，要将数据回传回去）。setup中接收两个参数，props和context，通过context.emit通知父组件去更新这个value。（与vue2中的this.$emit不同）</p><p>父组件中获取事件，并将value的值改变</p><p>可以简写为</p><p>这个组件中最核心的知识点：不准改props，使用：value和@input实现父子组件交流</p><h2 id="Button组件的实现"><a href="#Button组件的实现" class="headerlink" title="Button组件的实现"></a>Button组件的实现</h2><h3 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h3><p>(搞清楚我们需要做出什么东西来)</p><p>需求</p><ul><li>  可以有不同的等级(level)</li><li>  可以是链接,可以是文字</li><li>  可以click,focus,鼠标悬浮</li><li>  可以改变size:大中小</li><li>  可以禁用(disabled)</li><li>  可以加载中(loading)</li></ul><h3 id="API设计"><a href="#API设计" class="headerlink" title="API设计"></a>API设计</h3><p>Button组件怎么用</p><p>实现一:让Button支持事件click,focus,mouseover</p><p>前置知识:</p><h3 id="Vue3属性绑定"><a href="#Vue3属性绑定" class="headerlink" title="*Vue3属性绑定"></a>*Vue3属性绑定</h3><ul><li>  组件上绑定的事件默认会传给最外层的元素。</li><li>  使用inhertAttrs:false 可以取消默认绑定</li><li>  利用attrs或者context.$attrs可以获取所有属性</li><li>  可以利用v-bind=”$attrs”批量绑定属性</li><li>  使用const {size,level,…rest}  =  context.$attrs将属性分开</li></ul><p>示例:假设有两个组件分别叫做Father和Son，Son是Father的子组件</p><p>这里是Father组件内部部分代码</p><p>这里是Son组件内部部分代码</p><p>上面click事件默认会绑定到div上,这时无论是点击button还是div都会打印出”你好”来。</p><p>但是,如果我们设置<strong>inhertAttrs:false</strong>时,所有在Son绑定的属性都不会被继承。此时无论点击div还是buttong都不会打印”你好”。</p><p>如果我们此时想将所有从外界传来的无论属性还是事件都绑定到button上该怎么办呢？</p><p>答案是在button上加上<code>v-bind=&quot;$attrs&quot;</code></p><p>attrs就是从<Son>组件上传的所有属性(包括事件)。</p><p>如果这个时候我们想给son组件的div添加focus事件同时给button添加click该如何是好呢？</p><p>答案是将传过来的属性分开,代码如下</p><p>依旧是Son组件内部代码</p><p>这样我们就将传过来的属性分离,然后分别绑定到想要绑定的元素身上就好了。</p><h3 id="props与attrs的区别"><a href="#props与attrs的区别" class="headerlink" title="*props与attrs的区别"></a>*props与attrs的区别</h3><p>同样是获取属性的方法,props与attrs有什么区别呢?</p><ul><li>  props要先声明才能取值,attrs不同先声明</li><li>  props不包括事件,attrs包括</li><li>  props没有声明的属性,会跑到attrs里</li><li>  props支持string以外的类型,attrs只有string类型</li></ul><p>上面都是我们的前置知识,知道这些前置知识才能帮助我们刚好的封装组件,接下来,我们开始做业务逻辑相关的东西。</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>由于我们封装的是一个面向大众的ui库,所以在封装前,我们得站在用户的角度思考如何封装,在我看来,我们提供一个接口,用户只需要,知道怎么去用ok了。</p><p>关于button主题有三种:分别是默认按钮,链接按钮,文本按钮</p><p>以下是对应的使用方法</p><p>button大小有三种:分别是大号按钮,中号按钮,小号按钮</p><p>以下是对应的使用方法</p><p>button种类有三种:分别是主要按钮,普通按钮,危险按钮</p><p>通过props接收父组件传来的大小，是否加载等属性</p><p>然后通过计算属性来动态的改变button的类名，计算属性也写在setup中</p><p>这里关于css需要提醒的是：最小css原则</p><p>组件中的元素的样式是基于一个默认样式的</p><p>但是用户使用我们组件的时候，用户不一定有这样的样式。</p><p>所以我们创建一个scss文件，用来将我们组件的样式进行一个默认的改动</p><p>所有以qngu开头的都是我们的组件</p><h2 id="Dialog组件的实现"><a href="#Dialog组件的实现" class="headerlink" title="Dialog组件的实现"></a>Dialog组件的实现</h2><h3 id="需求分析-1"><a href="#需求分析-1" class="headerlink" title="需求分析"></a>需求分析</h3><p>参考antD,Bulma,Element,iView,Vuetify等</p><p>需求</p><ul><li>  点击后弹出</li><li>  有遮罩层overlay</li><li>  有close按钮</li><li>  有标题</li><li>  有内容</li><li>  有yes/no内容</li></ul><h3 id="API设计-1"><a href="#API设计-1" class="headerlink" title="API设计"></a>API设计</h3><h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><p>第一个功能,点击toggle按钮,弹出遮罩层以及对话框,用一个visible来控制对话框的显示与隐藏。</p><p>这里我们只能实现对话框的显示。</p><p>第二个功能,点击x按钮,关闭对话框。</p><p>我们在点击事件中，需要将Dialog上传来的x取反然后回传给父组件（注意：这里子组件一定不能去修改这个值，要将数据回传回去）。setup中接收两个参数，props和context，通过context.emit通知父组件去更新这个value。（与vue2中的this.$emit不同）</p><p>由于子组件中直接不能修改父组件传过来的值,所以我们只能在子组件中通知父组件,向父组件发射一个事件要求父组件修改。由此引出上面的三部曲:父组件传参,子组件发出时间通知父组件修改参数,父组件执行事件。</p><p>可以简写为</p><p>第三个功能，点击遮罩层，关闭，我们需要判断有些对话框是否需要点击遮罩层关闭</p><p>传一个closeOnClickOverlay属性</p><p>遮罩层绑定OnClickOverlay事件</p><p>第三个功能，点击ok或者cancel关闭，这里需要注意，有时候表单没有填写完毕，我们是不允许ok的，这个判断需要由父组件传来，一个ok对应f1，一个cancel对应f2</p><p>子组件接收ok或者cancel，如果父组件返回的是true就可以关闭，false就不能关闭</p><p>第四个功能，dialog支持自定义内容</p><p>使用具名插槽</p><p>1.在父组件的dialog标签里面加上两个具名插槽，名字为content和name</p><p>注意vue3中具名插槽的用法与vue2中的不太一样</p><p>具名插槽vue2与vue3的区别</p><p>2.子组件通过name找到这个插槽里面对应的内容</p><p>第五个功能，如果有一个div，层级为2，而你的dialog层级为1，这样你的对话框就会被遮挡</p><p>使用teleport，无需导入，是vue3的新组件，将我们的内容用teleport包裹，然后放到body下面</p><p>第六个功能，我们在父组件不给dialog传参，使用一个函数，能够传递所有的值到dialog组件中</p><p>首先声明一个showDialog的事件，然后声明一个openDialog的函数</p><p> <img src="https://cdn.nlark.com/yuque/0/2021/png/1554318/1612354599240-c47ea2a2-9d20-4d4f-b87c-4cc5ffc8ee49.png" alt="1.png" title="1.png"> </p><p>标题</p><p>你好</p><p>OK</p><p>Cancel</p><p>openDialog支持我们目前所创建的所有参数，标题，内容，点击ok之后的返回事件，点击取消之后的返回事件</p><p>我们创建一个ts文件用来定义这个函数，这个函数首先会创建一个div，然后我们的dialog挂载到这个div上</p><p>对于传入的参数，我们用h函数来进行渲染，我们先将visible属性变为true，这样对话框就出来了，然后对话框中包含一个onUpdate:visible函数，这是我们点击叉号关闭事件需要引用的，如果接受的update:visible值为false，我们就关闭对话框、以及ok和cancel函数</p><h2 id="Tabs组件的实现"><a href="#Tabs组件的实现" class="headerlink" title="Tabs组件的实现"></a>Tabs组件的实现</h2><h3 id="需求设计"><a href="#需求设计" class="headerlink" title="需求设计"></a>需求设计</h3><p>参考antD,Bulma,Element,iView,Vuetify等</p><p>需求</p><ul><li>  点击Tab切换内容</li><li>  有一条横线在动</li></ul><h3 id="API设计-2"><a href="#API设计-2" class="headerlink" title="API设计"></a>API设计</h3><p>Tabs组件怎么用</p><h3 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h3><p>问题1：如何确认tab的类型，如果我往tabs里面传的是一个div，那不就翻皮水了</p><p>我们需要检查tabs中的标签类型</p><p>通过log调试大法，最后我们找到了tabs里面的标签类型为context.slots.default()，log出来是个对象，然后我们拿这个结果和子组件Tab一一对比，不是Tab类型的就报错</p><p>问题2：切换标签页</p><p>我们这里使用selected用title，虽然在两个tabtitle一样的时候有漏洞，但是比较方便</p><p>这里使用v-model绑定一个selected</p><p>tabs中通过defaults中的props.title可以拿到titles数组</p><p>当父组件传来的selected和我们的标签名相等的时候，我们就改变css的样式</p><p>select实现 将标签名传给父组件，父组件会将selected的值变为这个标签名，然后回传给子组件</p><p>子组件中通过父组件传来的selected改变标签内容</p><p>问题3:如何获取每一个导航的宽度?</p><p>内部用途 <code>v-for</code></p><p>v-for 与 ref结合使用获取被遍历的每一个元素</p><p>其实divs就是由被遍历的元素组成的数组,使用flter获取以及被选中的导航,获取其宽度。</p><p>问题四:indirctor动画实现</p><p>点击那个导航,那个导航下面就会出现一个蓝色的与其宽度相同的蓝色条条</p><p>其宽度等于上面以及获取的被选中的导航的宽度</p><p><code>x.getBoundingClientRect()</code></p><p>用于获取x盒子的位置大小相关信息</p><p>所有indirctor的位置带啊吗如下</p><p>container为导航栏</p><p>result为被选中的盒子</p><h2 id="装修自己的官网"><a href="#装修自己的官网" class="headerlink" title="装修自己的官网"></a>装修自己的官网</h2><p>对于程序员来说，想把界面设计好看很难，这里推荐从一些设计网站获取素材，比如dribble</p><p>使用<a href="https://link.zhihu.com/?target=https://cssgradient.io/">cssgradient.io/</a> 这个网址制作渐变色背景</p><p>使用iconfont进行图片的引入</p><p>使用clip-path(裁剪半径)画圆弧</p><p>然后就实现了这样的一个首页</p><h2 id="装修自己的文档页"><a href="#装修自己的文档页" class="headerlink" title="装修自己的文档页"></a>装修自己的文档页</h2><p>我们的文档页要使用markdown的形式来展示，我们用github-markdown-css进行渲染</p><p>然后我们在页面中给articel标签都加上class=”markdown-body”就可以了</p><p>实现markdonw之后的效果</p><p>但是我们不想要页面结构如此之丑，能否用markdown格式的语法呢</p><h2 id="自制vite插件"><a href="#自制vite插件" class="headerlink" title="自制vite插件"></a>自制vite插件</h2><p>注意marked插件让页面可以解析markdown，我们需要在容器出加markdown-body类</p><p>安装marked 1.1.1</p><p>新建vite.config.ts，代码如下</p><p>新建plugins目录与md.ts</p><p>新建三个文档页面的markdown文件</p><p>例如，开始页面</p><p>这样mark插件就做好了</p><p>我们只需要在需要mark的地方加上markdown-body类，然后通过异步加载的形式，将md文件的内容转化为html就好了</p><h2 id="如何实现代码高亮"><a href="#如何实现代码高亮" class="headerlink" title="如何实现代码高亮"></a><strong>如何实现代码高亮</strong></h2><p>安装插件prismjs</p><p>由于这是一个老的插件，所以需要这样使用</p><p>然后在代码的部分</p><p>这里的html通过计算获得</p><h2 id="如何展示源代码"><a href="#如何展示源代码" class="headerlink" title="如何展示源代码"></a><strong>如何展示源代码</strong></h2><p>我们将需要展示的代码抽离到别的组件中</p><p>如何获取组件中的代码呢，使用custom blocks</p><p>1.在展示代码组件中写一个demo标签，标签里面写标题</p><p>2，我们来到vite.config.js里面加一段配置</p><p>3.在组件的__sourceCode处拿到源代码</p><h2 id="代码构建与发布"><a href="#代码构建与发布" class="headerlink" title="代码构建与发布"></a>代码构建与发布</h2><h2 id="1-将官网发布到github，并实现预览"><a href="#1-将官网发布到github，并实现预览" class="headerlink" title="1.将官网发布到github，并实现预览"></a>1.将官网发布到github，并实现预览</h2><p>发布官网，就是把dist目录传到网上，yarn build时要注意设置build path</p><p>1.如果有dist目录，删除</p><p>2.运行yarn build创建出最新的dist</p><p>3.运行hs dist在本地测试</p><p>4.部署到github</p><p><strong>问题1：</strong>我们使用github提供的预览功能时，发现加载不到css和js文件，这是因为路径有问题，我们需要配置一下yarn build</p><p>在vite.config.ts中加上</p><p><strong>问题2：</strong>我们每次打包上传都需要输入很多命令，所以我们配置一个自动化脚本–文件名deploy.sh</p><p>以后我们可以一键上传了，在终端运行</p><p>若有收获，就点个赞吧</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2021/03/03/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAaxios/"/>
    <url>/2021/03/03/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAaxios/</url>
    
    <content type="html"><![CDATA[<h1 id="深入浅出axios"><a href="#深入浅出axios" class="headerlink" title="深入浅出axios"></a>深入浅出axios</h1><h1 id="1-axios的基本使用"><a href="#1-axios的基本使用" class="headerlink" title="1 axios的基本使用"></a>1 axios的基本使用</h1><p>GET请求</p><p>// Make a request for a user with a given ID axios.get(‘/user?ID=12345’) .then(function (response) {  console.log(response); }) .catch(function (error) {  console.log(error); }); axios.get(‘/user’, {  params: { ID: 12345 } }) .then(function (response) { console.log(response); }) .catch(function (error) { console.log(error); });   axios({  method: ‘get’, url: ‘<a href="http://bit.ly/2mTM3nY&#39;">http://bit.ly/2mTM3nY&#39;</a>, responseType: ‘stream’ })  .then(function(response) { response.data.pipe(fs.createWriteStream(‘ada_lovelace.jpg’)) }); </p><p>POST请求</p><p>axios.post(‘/user’, {  firstName: ‘Fred’, lastName: ‘Flintstone’ }) .then(function (response) { console.log(response); }) .catch(function (error) { console.log(error); });  // Send a POST request axios({  method: ‘post’, url: ‘/user/12345’, data: { firstName: ‘Fred’, lastName: ‘Flintstone’ } }); </p><h1 id="2-axios的发送并发请求"><a href="#2-axios的发送并发请求" class="headerlink" title="2.axios的发送并发请求"></a>2.axios的发送并发请求</h1><h1 id="3-axios的配置信息相关"><a href="#3-axios的配置信息相关" class="headerlink" title="3.axios的配置信息相关"></a>3.axios的配置信息相关</h1><h1 id="4-axios的实例和模块的封装"><a href="#4-axios的实例和模块的封装" class="headerlink" title="4.axios的实例和模块的封装"></a>4.axios的实例和模块的封装</h1><p>创建实例</p><p>为了避免项目对于axios的过度依赖,将axios框架封装成单独文件</p><p>例如:</p><h1 id="5-axios拦截器"><a href="#5-axios拦截器" class="headerlink" title="5.axios拦截器"></a>5.axios拦截器</h1><p>若有收获，就点个赞吧</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2021/03/03/%E4%B9%98%E9%A3%8E%E7%A0%B4%E6%B5%AA%E5%AD%A6%E4%B9%A0Vue(%E4%B8%8B)/"/>
    <url>/2021/03/03/%E4%B9%98%E9%A3%8E%E7%A0%B4%E6%B5%AA%E5%AD%A6%E4%B9%A0Vue(%E4%B8%8B)/</url>
    
    <content type="html"><![CDATA[<h1 id="乘风破浪学习Vue-下"><a href="#乘风破浪学习Vue-下" class="headerlink" title="乘风破浪学习Vue(下)"></a>乘风破浪学习Vue(下)</h1><h1 id="一-路由"><a href="#一-路由" class="headerlink" title="一.路由"></a>一.路由</h1><p><strong>路由</strong>就是通过互联的网络把信息从源地址传输到目的地址的活动。(维基百科)</p><p>通俗点来说:就是将数据通过互联网从一个地方传输到另一个地方。(url与页面的映射关系)</p><p>路由器提供了两种机制:路由和转送</p><ul><li>  路由是决定数据包从来源到目的地的路径(确定传输路径)</li><li>  转送将输入端的数据转移到合适的输出(传输)</li></ul><p><strong>路由表</strong>:本质上就是一个映射表,决定了数据包的指向（本质上是IP地址与MAC地址的一一对应）</p><h1 id="二-后端渲染与后端路由"><a href="#二-后端渲染与后端路由" class="headerlink" title="二.后端渲染与后端路由"></a>二.后端渲染与后端路由</h1><h2 id="2-1-后端渲染"><a href="#2-1-后端渲染" class="headerlink" title="2.1 后端渲染"></a>2.1 后端渲染</h2><p>早期的网站开发整个HTML页面是由服务器来渲染的.</p><p>服务器直接生产渲染好对应的HTML页面,返回给客户端进行显示。</p><p>早期我们早浏览器上输入一个url触发的过程</p><ol><li> 一个页面有自己对应的网页,也就是URL。</li><li> URL会发送到服务器,服务器会通过正则对改URL进行匹配,并且最后交给一个控制器进行处理。</li><li> controller进行各种处理,最终生成HTML或则数据,返回前端。</li><li> 这就完成了一个IO操作。</li></ol><h2 id="2-2-后端路由"><a href="#2-2-后端路由" class="headerlink" title="2.2 后端路由"></a>2.2 后端路由</h2><p>当我们网页需要请求不同的路径内容时,交给服务器0来进行处理，服务器渲染好整个页面,并且将页面返回给客户端。</p><p>浏览器中输入url,直接在服务器中找对应得已经渲染好的页面到浏览器。</p><h3 id="2-2-1-后端路由的优点"><a href="#2-2-1-后端路由的优点" class="headerlink" title="2.2.1 后端路由的优点"></a>2.2.1 后端路由的优点</h3><p>这种情况下渲染好的页面,不需要单独加载任何的js和css，可以直接交给浏览器展示,这样也有利于SEO的优化。</p><h3 id="2-2-2-后端路由的缺点"><a href="#2-2-2-后端路由的缺点" class="headerlink" title="2.2.2 后端路由的缺点:"></a>2.2.2 后端路由的缺点:</h3><ol><li> 一种情况是整个页面的模块都由后端人员来编写和维护的</li><li> 另一种情况是前端开发人员如果要开发网页,需要通过PHP和java等语言来编写页面代码</li><li> 而且通常情况下HTML代码和数据以及对应的逻辑会混合在一起,编写和维护都是非常糟糕的事情。</li></ol><h1 id="三-前后端分离与前端渲染"><a href="#三-前后端分离与前端渲染" class="headerlink" title="三.前后端分离与前端渲染"></a>三.前后端分离与前端渲染</h1><h2 id="3-1-前后端分离"><a href="#3-1-前后端分离" class="headerlink" title="3.1 前后端分离"></a>3.1 前后端分离</h2><p><strong>前后端分离的开发模式</strong></p><ul><li>  随着AJAX的出现,有了前后端的开发模式。</li><li>  后端只提供Api来返回数据,前端通过AJAX获取数据,并且可以通过Javasxript将数据渲染到页面中。</li><li>  这样做最大的优点那就是前后端责任的清晰,后端专注于数据上,前端专注于交互与可视化上。</li><li>  并且当移动端出现后,后端不需要进行任何处理,依然使用之前的一套API即可。</li></ul><h2 id="3-2-前端渲染"><a href="#3-2-前端渲染" class="headerlink" title="3.2 前端渲染"></a>3.2 前端渲染</h2><p>浏览器中显示的网页中的大部分内容,都是由前端写的js代码在浏览器中执行，最后渲染出来的网页。</p><h2 id="3-3-前后端分离没有解决的问题"><a href="#3-3-前后端分离没有解决的问题" class="headerlink" title="3.3 前后端分离没有解决的问题"></a>3.3 前后端分离没有解决的问题</h2><p>但是此时依然使用的是后端路由,也就是从浏览器中输入一个url需要去服务器请求这个url对应的页面。</p><h1 id="四-单页面富应用-SPA"><a href="#四-单页面富应用-SPA" class="headerlink" title="四.单页面富应用(SPA)"></a>四.单页面富应用(SPA)</h1><h2 id="4-1-什么是SPA"><a href="#4-1-什么是SPA" class="headerlink" title="4.1 什么是SPA"></a>4.1 什么是SPA</h2><p>概念:就是只有一张Web页面的应用,Web应用即使不刷新也在不同的页面间切换。</p><p>SPA解决了浏览器前进、后退等机制被破坏等问题。并且页面访问会被浏览器保存。</p><h2 id="4-2-前端路由"><a href="#4-2-前端路由" class="headerlink" title="4.2 前端路由"></a>4.2 前端路由</h2><p>当我们在浏览器中输入一个url时,SPA会将这个url所在的网站的所有页面资源请求下来(其实就是一个包含多个组件的页面),然后当我们再访问这个网站中的任何页面,我们就不再从服务器中去请求这个网站的资源了,而是从我们请求的此网站的页面资源中去筛选出我们想要的页面。</p><p><strong>前端路由:由前端来管理url与页面的映射关系。</strong></p><p><strong>前端路由的核心:改变URL,但是页面不进行整体的刷新。</strong></p><h2 id="4-3-SPA的特点"><a href="#4-3-SPA的特点" class="headerlink" title="4.3 SPA的特点"></a>4.3 SPA的特点</h2><p>SPA最主要的特点就是在前后端分离的基础上加了一层前端路由,也就是我们的vue-router.</p><h1 id="五-vue-router的使用"><a href="#五-vue-router的使用" class="headerlink" title="五.vue-router的使用"></a>五.vue-router的使用</h1><h2 id="5-1-vue-router简介"><a href="#5-1-vue-router简介" class="headerlink" title="5.1 vue-router简介"></a>5.1 vue-router简介</h2><p>vue-router是vue.js官方的路由插件,它和vue.js是深度集成的,适合用于构建SPA。</p><p>vue-router是基于路由和组件的</p><ul><li>  路由用于设定访问路径,将路径和组件映射起来</li><li>  在vue-router的单页面应用中,页面的路径的改变就是组件的切换。</li></ul><h2 id="5-2-vue-router的安装与起步"><a href="#5-2-vue-router的安装与起步" class="headerlink" title="5.2 vue-router的安装与起步"></a>5.2 vue-router的安装与起步</h2><p>步骤一:安装</p><p>步骤二:在模块化过程中使用它</p><ol><li><p> 第一步: 导入路由对象,并且调用Vue.use(VueRouter)</p></li><li><p> 第二步:创建路由实例,并且传入路由映射配置</p></li><li><p>第三步:在Vue实例中挂载创建的路由实例</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1554318/1610279143476-6c20fb13-7548-405e-a8cb-d7444e2a49ca.png" alt="1.png" title="1.png"> </p></li></ol><p>importVuefromvue</p><p>importVueRouterfromvue-router</p><p>Vue.use(VueRouter)</p><p>步骤三:使用vue-router</p><p>第一步:创建路由组件</p><p>第二步:配置路由映射:组件和路径映射关系</p><p>第三步:使用路由:用过<router-link>和<router-view></p><p><router-link>：该标签是一个vue-router已经内置的组件,它会被渲染成一个<a>便签</p><p><router-view>:该标签会根据当前的路径,动态渲染出不同的组件。</p><h2 id="5-3-默认路由"><a href="#5-3-默认路由" class="headerlink" title="5.3 默认路由"></a>5.3 默认路由</h2><p>当我们进入某个网站时,我们希望默认显示首页内容,而不是需要用户点击首页才显示。</p><p>默认路由 配置:</p><p>我们在routes中又配置了一个映射</p><p>path配置的是根路径:/</p><p>redirect是重定向,也就是我们将根路径重定向到/home的路径下,这样就可以得到我们想要的结果了。</p><p>修改路由为history模式</p><p>默认的路由模式里面总是会带一个#符号,我们可以通过在router实例中加mode:”history”来解决此问题</p><h2 id="5-4-router-link的其他属性补充"><a href="#5-4-router-link的其他属性补充" class="headerlink" title="5.4 router-link的其他属性补充"></a>5.4 router-link的其他属性补充</h2><ul><li>  to:指定跳转路径</li><li>  tag:渲染成指定标签</li><li>  active-class:当<router-link>对应得路由匹配成功时,会自动给当前元素设置一个router-link-active的class.设置active-class可以修改默认的名称。</li></ul><p>动态路由的实现</p><p>在某些情况下,一个页面的path路径可能是不确定的,比如我们进入用户界面时,希望是如下的路径:</p><p>/user/aaa或/user/bbb</p><p>除了有前面的/user之外,后面还跟上了用户的ID</p><p>这种path和Component的匹配关系,我们称之为动态路由(也是路由传递数据的一种方式)</p><p>在路由映射中如下配置</p><p> <img src="https://cdn.nlark.com/yuque/0/2021/png/1554318/1610279894205-fbb07f76-5fd7-4c17-b02e-046a69653f4c.png" alt="2.png" title="2.png"> </p><p>path:/user/:userId</p><p>component:User</p><p>在App.vue中</p><p> <img src="https://cdn.nlark.com/yuque/0/2021/png/1554318/1610279997105-8ab9ce5f-1462-4ad4-b4f9-f6e3212f7248.png" alt="4.png" title="4.png"> </p><p>&lt;router-linkv-bind.tour/+userid”/router-link</p><p> <img src="https://cdn.nlark.com/yuque/0/2021/png/1554318/1610279993329-f9dbff5c-b970-48b5-8fe5-11d6028e8a4a.png" alt="3.png" title="3.png"> </p><p>data</p><p>return</p><p>iisi</p><p>userId:</p><p>imgURL:</p><p>在User.vue中</p><p> <img src="https://cdn.nlark.com/yuque/0/2021/png/1554318/1610280047676-010a5e0c-7bfe-4287-bf63-23842d867922.png" alt="5.png" title="5.png"> </p><p>computed:</p><p>userIdO</p><p>returnthis.sroute.param.userId</p><h2 id="5-5-路由懒加载"><a href="#5-5-路由懒加载" class="headerlink" title="5.5 路由懒加载"></a>5.5 路由懒加载</h2><p>官方解释</p><p>当打包构建应用时,javascript包会变得非常大,影响页面加载</p><p>如果我们能把不同路由对于的组件分隔成不同的代码块,然后当路由被访问的时候才加载对于组件,这样就更加高效了</p><p>通俗解释</p><p>首先我们知道路由中通常会定义很多不同的界面。</p><p>这个页面最后被打包到哪里呢？一般情况下,是放在一个JS文件中</p><p>但是,页面这么多放在一个js文件中,必然会造成这个页面非常的发</p><p>如果我们一次性从服务器请求下这个页面,可能需要花费一定的时间甚至用户的电脑上还可能出现短暂空白情况。</p><p>为了避免这种情况,我们可以使用懒加载</p><p>路由懒加载做了什么呢?</p><p>路由懒加载的主要作用就是将路由对应的组件打包成一个个js代码块</p><p>只有在这个路由被访问到的时候,才加载对应的组件</p><p>引用后直接使用与实现懒加载</p><p> <img src="https://cdn.nlark.com/yuque/0/2021/png/1554318/1610281376802-908c32c0-fccf-478c-8f0d-e2a87ec4db78.png" alt="1.png" title="1.png"> </p><p>constroutes</p><p>../components/Home</p><p>importHomefrom</p><p>../components/About</p><p>importaboutfrom</p><p>path://home,</p><p>import(../components/Home”)</p><p>component:O</p><p>Vue.use(VueRouter);</p><p>constroutes</p><p>引用后直接使用</p><p>path:/about’,</p><p>mportC../components/About</p><p>component:(O)</p><p>Path:/home’,</p><p>万,</p><p>cOmponent:Home</p><p>Ji</p><p>S一</p><p>Path:”/about’,</p><p>static</p><p>cOmponent:About</p><p>CSS</p><p>万,</p><p>];</p><p>0.09675c5e37c95c6e65ff.js</p><p>1.266ad04847546fd5bdb2.js</p><p>static</p><p>app.513coad5da30a20ee757.js</p><p>css</p><p>manifest.2307a2fbeao88edd4j</p><p>vendor.426ef21560bb1458790e.js</p><p>app.0c28233891bf98a530js</p><p>010</p><p>index.htmi</p><p>manifest.2a269a05c33dfc65f8.js</p><p>vendor.1748317793fd05195f8.js</p><p>index.html</p><h2 id="5-6-嵌套路由"><a href="#5-6-嵌套路由" class="headerlink" title="5.6 嵌套路由"></a>5.6 嵌套路由</h2><p>嵌套路由是一个很常见的功能</p><p>比如在home页面中,我们希望通过/home/news和/home/message访问一些内容</p><p>一个路径映射一个组件,访问这两个路径也会分别渲染这两个组件。</p><p>实现嵌套路由有两个步骤</p><p>创建对应的子组件,并且在路由映射中配置对应的子路由</p><p>在组件内部使用<code>&lt;router-view&gt;</code>标签</p><h1 id="六-Vuex的基本使用"><a href="#六-Vuex的基本使用" class="headerlink" title="六.Vuex的基本使用"></a>六.Vuex的基本使用</h1><h2 id="6-1-什么是Vuex"><a href="#6-1-什么是Vuex" class="headerlink" title="6.1 什么是Vuex"></a>6.1 什么是Vuex</h2><p>Vuex就是一个状态管理模式，为什么叫模式？因为Vuex包含了一套对state(状态)的操作规范，集中存储管理应用的所有组件的状态</p><blockquote><p>状态管理</p></blockquote><ul><li><p>  简单来说就是管理各个组件共享的数据，类似session  </p></li><li><p>  session可以存数据，存的过程就是管理，数据的每一次赋值就是当次状态。  </p></li><li><p>  Vuex在Vue实例顶层中。</p></li></ul><blockquote><p>什么状态需要Vuex去管理？</p></blockquote><ul><li>  比如用户的登录的状态（token）、用户的信息（头像、名称、地理位置信息）等等</li><li>  比如商品的收藏，购物车的商品等等</li><li>  这些状态应该是响应式的，用户昵称、头像修改了需要响应</li></ul><blockquote><p>Vuex简单模型</p></blockquote><p>网络异常，图片无法展示</p><p>|</p><ul><li>  <strong>state</strong>，驱动应用的数据源；</li><li>  <strong>view</strong>，以声明方式将 <strong>state</strong> 映射到视图；</li><li>  <strong>actions</strong>，响应在 <strong>view</strong> 上的用户输入导致的状态变化。</li><li>  这是一个单页面数据流向，比如想要修改用户昵称，当前用户昵称的状态是A，通过输入框输入了新的昵称B，调用ajax请求后端修改成功后将state改成B，然后视图响应用户昵称的变化从A到B。</li></ul><p>但是，当我们的应用遇到<strong>多个组件共享状态</strong>时，单向数据流的简洁性很容易被破坏：</p><ul><li>  多个视图依赖于同一状态。</li><li>  来自不同视图的行为需要变更同一状态。</li><li>  所以我们需要vuex的规范操作来管理状态。</li></ul><h2 id="6-2-Vuex基本使用"><a href="#6-2-Vuex基本使用" class="headerlink" title="6.2  Vuex基本使用"></a>6.2  Vuex基本使用</h2><p><strong>1.新建一个vuecli2工程</strong></p><p>使用<code>vue init webpack 01-vuex-vuecli2</code>新建一个vue项目。</p><p><strong>2.修改<code>App.vue</code>并新建一个<code>HelloVuex.vue</code>组件</strong></p><blockquote><p>HelloVuex.vue</p></blockquote><p>此时我们使用了父子组件通信来完成子组件<code>HelloVuex</code>获取父组件的<code>count</code>。</p><hr><p>网络异常，图片无法展示</p><p>|</p><p>如果不是父子组件如何通信，此时就需要vuex了，还是这这2个组件，现在不使用父子通信，直接使用vuex。</p><p><strong>3.使用vuex管理状态</strong></p><ul><li><p>  使用<code>npm install vuex --save</code>安装Vuex  </p></li><li><p>  安装插件Vue.use(Vuex)`，在src下新建一个store文件夹，新建一个index.js</p></li><li><p>  修改<code>App.vue</code>和<code>HelloVuex.vue</code>，直接使用<code>$store.state.count</code>获取count值</p></li></ul><p>一般不会直接使用<code>$store.state.count</code>获取vuex中的状态，也不是直接使用<code>$store.state.count++</code>来操作vuex中的状态。</p><h2 id="6-3-Vuex的流程"><a href="#6-3-Vuex的流程" class="headerlink" title="6.3 Vuex的流程"></a>6.3 Vuex的流程</h2><p>网络异常，图片无法展示</p><p>|</p><ul><li><p>  Vue Components是vue组件</p></li><li><p>  Mutations ：更改 Vuex 的 store 中的状态的唯一方法是提交 mutation</p></li><li><p>  State 是vuex中状态的集合</p></li><li><p>  Actions与Mutations 类似，经常与后端交互，不同在于：</p></li><li><p>  Action 提交的是 mutation，而不是直接变更状态。</p></li><li><p>  Action 可以包含任意异步操作。</p></li></ul><p>组件中修改state，通过提交 mutation，修改完成后vuex帮我们响应到vue组件上。</p><blockquote><p>修改index.js使用mutation</p></blockquote><blockquote><p>修改App.vue提交mutation</p></blockquote><blockquote><p>测试</p></blockquote><p>网络异常，图片无法展示</p><p>|</p><p>测试发现没有问题与直接使用<code>$store.state.count++</code>效果一致，通过提交mutation修改了状态state，在<code>vue-devtools</code>中也能跟踪state变化以及提交的mutation。</p><h2 id="6-4-Vuex的核心概念"><a href="#6-4-Vuex的核心概念" class="headerlink" title="6.4 Vuex的核心概念"></a>6.4 Vuex的核心概念</h2><ul><li>  State</li><li>  Getters</li><li>  Mutation</li><li>  Action</li><li>  Moudule</li></ul><h3 id="6-4-1-State（单一状态树）"><a href="#6-4-1-State（单一状态树）" class="headerlink" title="6.4.1 State（单一状态树）"></a>6.4.1 State（单一状态树）</h3><p>Vuex 使用<strong>单一状态树</strong>——是的，用一个对象就包含了全部的应用层级状态。至此它便作为一个“唯一数据源 (<a href="https://en.wikipedia.org/wiki/Single_source_of_truth">SSOT</a>)”而存在。。这也意味着，每个应用将仅仅包含一个 store 实例。单一状态树让我们能够直接地定位任一特定的状态片段，在调试的过程中也能轻易地取得整个当前应用状态的快照。</p><p>简单说就是把数据所有有关的数据封装到一个对象中，这个对象就是store实例，无论是数据的状态（state），以及对数据的操作（mutation、action）等都在store实例中，便于管理维护操作。</p><p>state的操作在19.2.Vuex的基本使用已经了解，直接通过<code>this.$store.state</code>获取state对象。</p><h3 id="6-4-2-Getters"><a href="#6-4-2-Getters" class="headerlink" title="6.4.2 Getters"></a>6.4.2 Getters</h3><p>Getters类似计算属性，帮我们做一些重复的事情。</p><p>例如有这样一个store实例，我们需要获取<strong>年龄大于20岁的学生数量</strong>：</p><p>你可能会这样写这样一个计算属性去获取<strong>年龄大于20岁的学生数量</strong>：</p><p>如果很多组件中需要<strong>年龄大于20岁的学生数量</strong>，你可能会将这个计算属性复制，将filter函数写很多遍，但是如果你有<strong>Getters</strong>。</p><blockquote><p>在store实例中定义getters</p></blockquote><blockquote><p>通过属性调用getters</p></blockquote><p>现在只需要调用getters的getStudents对象，就能获取数量。</p><p>如果你想查询指定ID（传入ID）的学生信息。</p><p>你也可以通过让 getter 返回一个函数，来实现给 getter 传参。在你对 store 里的数组进行查询时非常有用。</p><blockquote><p>定义getters</p></blockquote><blockquote><p>通过方法访问</p></blockquote><p>传入学生ID为110，输出</p><p>网络异常，图片无法展示</p><p>|</p><h3 id="4-5-Mutation（状态更新）"><a href="#4-5-Mutation（状态更新）" class="headerlink" title="4.5 Mutation（状态更新）"></a>4.5 Mutation（状态更新）</h3><ul><li>  Vuex的store状态更新的唯一方式：<strong>提交Mutation</strong></li></ul><ul><li>  Mutation主要包括两个部分：</li></ul><ol><li> 字符串的<strong>事件类型（type）</strong></li><li> 一个<strong>回调函数（handler）</strong>，这个回调函数就是我们实际进行状态更改的地方，该回调函数的<strong>第一个参数就是state</strong></li></ol><ul><li><p>  Mutation的定义方式：</p></li><li><p>  通过Mutation更新</p></li></ul><h4 id="6-5-1-mutation接受单个参数"><a href="#6-5-1-mutation接受单个参数" class="headerlink" title="6.5.1 mutation接受单个参数"></a>6.5.1 mutation接受单个参数</h4><p>mutation携带的参数被称为是mutation的载荷（Payload）</p><p>在19.2的工程的基础上修改，添加2个按钮分别是让state中的<strong>count+5、count+10</strong>，增加2个按钮</p><p>新增<strong>addCount</strong>方法:</p><p>新增一个mutation</p><p>测试：</p><hr><p>网络异常，图片无法展示</p><p>|</p><h4 id="6-5-2-mutation接受多个参数"><a href="#6-5-2-mutation接受多个参数" class="headerlink" title="6.5.2 mutation接受多个参数"></a>6.5.2 mutation接受多个参数</h4><p>如果mutation需要接受多个参数，此时可以传一个对象，例如新增一个功能点击按钮新增一个学生，此时需要传学生的ID、姓名、年龄，可以封装成一个学生对象传入。</p><p><strong>1.新增按钮</strong></p><p><strong>2.新增mutation</strong></p><p>3.<strong>新增方法</strong></p><p><strong>4.测试</strong></p><p>网络异常，图片无法展示</p><p>|</p><h4 id="6-5-3-mutation的提交风格"><a href="#6-5-3-mutation的提交风格" class="headerlink" title="6.5.3 mutation的提交风格"></a>6.5.3 mutation的提交风格</h4><p>1.普通提交风格</p><p>此时count传过去的就是count=10</p><p>2.特殊的提交封装</p><p>此时count传过去是一个对象payload（载荷）</p><h4 id="6-5-4-Vuex的响应式原理"><a href="#6-5-4-Vuex的响应式原理" class="headerlink" title="6.5.4 Vuex的响应式原理"></a>6.5.4 Vuex的响应式原理</h4><ol><li><p> Vuex的store的state是响应式的，当state中的数据发生改变时，Vue组件会自动更新。  </p></li><li><p> 响应式需要遵循规则</p></li></ol><ul><li>  state的对象需要初始化</li><li>  如果需要给state中的对象添加新属性的时候，使用以下方式</li></ul><ol><li><p> 使用Vue.set(obj, ‘newProp’, 123)</p></li><li><p> 用新对象替换就对象</p></li><li><p> 在state中增加一个对象user</p></li></ol><p>4.在app.vue增加按钮修改信息</p><p>5.app.vue增加按updateInfo()方法</p><p>6.在mutation中添加updateInfo()</p><p>7.点击<strong>修改信息</strong>按钮，发现state的值变化了，但是页面没有响应变化</p><p>网络异常，图片无法展示</p><p>|</p><p>8.使用<code>Vue.set()</code>方法支持响应式</p><p>9.再次点击<strong>修改信息</strong>按钮，发现变响应式了</p><p>网络异常，图片无法展示</p><p>|</p><blockquote><p>总结</p></blockquote><ol><li> state未初始化属性（<code>age</code>）</li></ol><ul><li>  使用直接赋值的方式不能响应式</li><li>  需要使用 <code>Vue.set(state.user, &#39;age&#39;, 12)</code></li></ul><ol start="2"><li><p> state已经初始化了，可以使用直接赋值方式  </p></li><li><p> 关于删除属性</p></li></ol><p>// 该方法没有响应式，需要使用vue.delete</p><p>     // delete state.user.age</p><p>     Vue.delete(state.user, age)// 响应式删除age</p><h4 id="6-5-5-mutation的类型常量"><a href="#6-5-5-mutation的类型常量" class="headerlink" title="6.5.5 mutation的类型常量"></a>6.5.5 mutation的类型常量</h4><p>一个vue文件中有关mutation的方法太多了，常常可能写错，所有可以在store文件夹下定义一个<code>mutation-type.js</code>的常量。</p><ol><li> 定义一个<code>mutation-type.js</code>的常量</li></ol><p>2.修改<code>App.vue</code>的updateinfo方法</p><ol start="3"><li> 修改store的<code>index.js</code>，将mutation的方法名也改成常量使用方式</li></ol><p>这样保证了所有的方法都定义在<code>mutation-type.js</code>中，不会出问题。</p><h3 id="6-6-Actions"><a href="#6-6-Actions" class="headerlink" title="6.6 Actions"></a>6.6 Actions</h3><p>使用mutation操作更新state的时候，使用异步修改数据。</p><ol><li><p> 修改updateInfo()方法</p></li><li><p> 点击<strong>修改信息</strong>按钮</p></li></ol><p>网络异常，图片无法展示</p><p>|</p><p>发现页面的数据改变了，但是vue-devtools工具中并未跟踪到改变。所以我们不要在mutation中进行异步操作。</p><blockquote><p>定义</p></blockquote><p>Action 类似于 mutation，不同在于：</p><ul><li>  Action 提交的是 mutation，而不是直接变更状态。</li><li>  Action 可以包含任意异步操作。</li></ul><ol><li><p> 新增一个mutation</p></li><li><p> 新增一个actions</p></li><li><p> 在<code>App.vue</code>中新增一个按钮修改user对象姓名</p></li><li><p> 给按钮新增方法</p></li><li><p> 点击<code>异步修改信息</code>按钮测试</p></li></ol><p>网络异常，图片无法展示</p><p>|</p><p>在点击按钮之后，信息修改了，dev-tools也能跟踪到state的变化。通过<code>$store.dispacth()</code>方法来调用actions，发送异步请求，在actions中需要提交mutation来修改state。</p><p>6.actions回调，在异步操作后，成功或者失败都应该会有回调，<code>$store.dispacth()</code>返回一个Promise对象，修改actions，返回一个Promise对象，成功调用<code>resolve(msg)</code>，将成功的<code>msg</code>传入（<strong>不理解的请看一下18章的Promise对象详解</strong>）。</p><p>7.修改<code>aUpdateInfo()</code>方法，获取回调参数<code>msg</code>，此时的<code>response</code>就是actions中回调的<code>msg</code>，也可以支持失败的回调，只要actions中使用了reject，在<code>aUpdateInfo()</code>方法中catch回调结果就能获取resjct对象回传结果。</p><p>8.再次点击<code>异步修改信息</code>，打印结果信息</p><p> <img src="https://github.com/zhangtianyi0110/VueLearnNotes/raw/master/19-vuex/images/19-12.png"> </p><blockquote><p>Actions 支持同样的载荷方式(<strong>payload</strong>)和对象方式进行分发</p></blockquote><h3 id="6-7-moudules（模块）"><a href="#6-7-moudules（模块）" class="headerlink" title="6.7 moudules（模块）"></a>6.7 moudules（模块）</h3><p>由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。</p><p>为了解决以上问题，Vuex 允许我们将 store 分割成<strong>模块（module）</strong>。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块——从上至下进行同样方式的分割。</p><p>比如这样</p><blockquote><p>模块的局部状态</p></blockquote><ol><li> 模块内部的mutation 和 getter，接收的第一个参数是<strong>模块的局部状态对象</strong>。</li></ol><ol start="2"><li> 模块内部的 action，局部状态是 <code>context.state</code> ，根节点状态则为 <code>context.rootState</code>。</li></ol><ol start="3"><li> 对于模块内部的 getter，第三个参数是根节点状态。</li></ol><blockquote></blockquote><p>注意actions的context</p><p><code>&#123; state, commit, rootState &#125;</code>对应<code>context</code>对象中的属性，使用ES6的对象解构。</p><h3 id="6-8-项目结构"><a href="#6-8-项目结构" class="headerlink" title="6.8 项目结构"></a>6.8 项目结构</h3><p>Vuex 并不限制你的代码结构。但是，它规定了一些需要遵守的规则：</p><ol><li> 应用层级的状态应该集中到单个 store 对象中。</li><li> 提交 <strong>mutation</strong> 是更改状态的唯一方法，并且这个过程是同步的。</li><li> 异步逻辑都应该封装到 <strong>action</strong> 里面。</li></ol><p>只要你遵守以上规则，如何组织代码随你便。如果你的 store 文件太大，只需将 action、mutation 和 getter 分割到单独的文件。</p><p>对于大型应用，我们会希望把 Vuex 相关代码分割到模块中。下面是项目结构示例：</p><p>├── index.html</p><p>├── main.js</p><p>├── api</p><p>│   └── … # 抽取出API请求</p><p>├── components</p><p>│   ├── App.vue</p><p>│   └── …</p><p>└── store</p><p>   ├── index.js          # 我们组装模块并导出 store 的地方</p><p>   ├── actions.js        # 根级别的 action</p><p>   ├── mutations.js      # 根级别的 mutation</p><p>   └── modules</p><p>       ├── cart.js       # 购物车模块</p><p>       └── products.js   # 产品模块</p><p>若有收获，就点个赞吧</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2021/03/03/%E4%B9%98%E9%A3%8E%E7%A0%B4%E6%B5%AA%E5%AD%A6%E4%B9%A0Vue(%E4%B8%AD)/"/>
    <url>/2021/03/03/%E4%B9%98%E9%A3%8E%E7%A0%B4%E6%B5%AA%E5%AD%A6%E4%B9%A0Vue(%E4%B8%AD)/</url>
    
    <content type="html"><![CDATA[<h1 id="乘风破浪学习Vue-中"><a href="#乘风破浪学习Vue-中" class="headerlink" title="乘风破浪学习Vue(中)"></a>乘风破浪学习Vue(中)</h1><h1 id="一-Vue的数据响应式"><a href="#一-Vue的数据响应式" class="headerlink" title="一.Vue的数据响应式"></a>一.Vue的数据响应式</h1><p>首先想要了解Vue的数据响应式,我们得知道什么是Vue的数据响应式。</p><p>解释如下:<strong>数据发生改变的时候，视图会重新渲染，匹配更新为最新的值</strong>。</p><p>那么Vue是如何做到的呢?</p><p>致命三连问</p><p>1、Vue 是怎么知道数据改变？</p><p>2、Vue 在数据改变时，怎么知道通知哪些视图更新？</p><p>3、Vue 在数据改变时，视图怎么知道什么时候更新？</p><p>解决这三个问题的过程中,我们其实就已经Vue的数据响应式有了一定的了解</p><p>当然,工欲善其事必先利其器,要想达到我们的目标,</p><p>我们必须要提前知道一些前置内容。</p><h2 id="1-前置知识"><a href="#1-前置知识" class="headerlink" title="1.前置知识"></a>1.前置知识</h2><h3 id="1-1-前置内容①-Object-defineProperty"><a href="#1-1-前置内容①-Object-defineProperty" class="headerlink" title="1.1 前置内容①: Object.defineProperty"></a>1.1 前置内容①: Object.defineProperty</h3><p>这个方法，是 Vue 响应式系统的精髓，骨髓，脑髓</p><p>使用 Object.defineProperty 可以为对象中的每一个属性，设置 get 和 set 方法</p><p>Object.defineProperty 可以为属性设置很多特性，例如 configurable，enumerable，但是现在不过多解释，重点只放在 get 和 set</p><p><strong>那么 get 和 set 方法有什么用？</strong></p><p>get 值是一个函数，当属性被访问时，会触发 get 函数</p><p>set 值同样是一个函数，当属性被赋值时，会触发 set 函数</p><p>举个例子:</p><p>var obj={  name:”彭一多” } Object.defineProperty(obj,”name”,{  get(){ console.log(“get 被触发”) }, set(val){ console.log(“set 被触发”) } })</p><p>当我访问 obj.name 时，会打印 ‘ get 被触发 ‘</p><p>当我为 obj.name 赋值时，obj.name = 5，会打印 ‘ set 被触发 ‘</p><p>这便可以回答了我开篇的第一个问题</p><p>Vue 是怎么知道数据改变的呢？</p><p>恩，Vue 在 属性的 set 方法中做了手脚，因而当数据改变时，触发 属性的 set 方法，Vue 就能知道数据有改变。</p><h3 id="1-2-前置内容②-依赖收集"><a href="#1-2-前置内容②-依赖收集" class="headerlink" title="1.2 前置内容②:依赖收集"></a>1.2 前置内容②:依赖收集</h3><p>简单地说</p><p>data 中的声明的每个属性，都拥有一个数组，保存着 谁依赖（使用）了 它</p><p>举个例子</p><p>然后 页面A 引用了name</p><p>此时，name 把 页面 A 存在它的后宫中（这个页面依赖我）</p><p><strong>为什么呢？</strong></p><p>因为它知道谁依赖它之后，它就可以在发生改变的时候，通知 依赖它的页面，从而让页面完成更新</p><p><strong>注意</strong></p><p>实际上，会依赖 name 的地方，不只是页面，还会有 computed，watch…. 等等，但是这里我们全部使用页面一词替代。</p><p>这就是依赖收集，把 依赖了我（使用了我的东西），统统保存起来。</p><p>我按上面的例子，从Vue 内部打印一份数据供大家简单了解即可。</p><p> <img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1554318/1610026549393-f11c9ca4-b259-43ad-84e3-cc2507179268.jpeg"> </p><p>可以看到，name 属性，使用了 一个 dep 保存了 页面A 这个依赖，而保存的实际上是 页面A的 Watcher。</p><p><strong>TIP</strong></p><p>简单说一下，watcher 是什么，每个 Vue 实例都会拥有一个专属的 watcher，可用于实例更新</p><p><strong>总结一下</strong></p><p>1、data 中每个声明的属性，都会有一个 专属的依赖收集器 subs</p><p>2、当页面使用到 某个属性时，页面的 watcher 就会被 放到 依赖收集器 subs 中</p><p>数据 是在什么时候进行 收集依赖 的呢？</p><p>答案是，<strong>ObjectdefineProperty - get</strong></p><p>当 页面 A 读取了 name 时，会触发 name 的 get 函数，此时，name 就会保存 页面A 的 watcher 啦！</p><p>这便可以回答了我开篇的第二个问题</p><p>Vue 在数据改变时，怎么知道通知哪些视图更新？</p><p>恩，通知那些存在 依赖收集器中的 视图</p><h3 id="1-3-前置内容③-依然更新"><a href="#1-3-前置内容③-依然更新" class="headerlink" title="1.3 前置内容③:依然更新"></a>1.3 前置内容③:依然更新</h3><p>依赖更新，就是，通知所有的依赖进行更新</p><p>经过上面的讲解，我们都知道，每个属性都会保存有一个 依赖收集器 subs</p><p>而这个 依赖收集器，是用来在 数据变化时，通知更新的</p><p>数据 是在 什么时候进行 依赖更新 的呢？</p><p>答案是，<strong>Object.defineProperty - set</strong></p><p>以上面的 Vue 实例 为例</p><p>当 name 改变的时候，name 会遍历自己的 依赖收集器 subs，逐个通知 watcher，让 watcher 完成更新</p><p>这里 name 会通知 页面A，页面A 重新读取新的 name ，然后完成渲染</p><p>这便可以回答了我开篇的第二个问题</p><p>Vue 在数据改变时，视图怎么知道什么时候更新?</p><p>恩，在数据变化触发 set 函数时，通知视图，视图开始更新</p><p><strong>简单**</strong>总结**</p><p>1、Object.defineProperty  -  get ，用于 依赖收集</p><p>2、Object.defineProperty  -  set，用于 依赖更新</p><p>3、每个 data 声明的属性，都拥有一个的专属依赖收集器 subs</p><p>4、依赖收集器 subs 保存的依赖是 watcher</p><p>5、watcher 可用于 进行视图更新</p><h2 id="2-面试该如何回答"><a href="#2-面试该如何回答" class="headerlink" title="2.面试该如何回答"></a>2.面试该如何回答</h2><p>上文只是对Vue数据响应做了白话文解释。</p><p>更为专业的解释:Vue为MVVM框架，当数据模型data变化时，页面视图会得到响应更新，其原理对data的getter/setter方法进行拦截（Object.defineProperty或者Proxy），利用发布订阅的设计模式，在getter方法中进行订阅，在setter方法中发布通知，让所有订阅者完成响应。</p><p><strong>原理</strong></p><p>在响应式系统中，Vue会为数据模型data的每一个属性新建一个订阅中心作为发布者，而监听器watch、计算属性computed、视图渲染template/render三个角色同时作为订阅者，对于监听器watch，会直接订阅观察监听的属性，对于计算属性computed和视图渲染template/render，如果内部执行获取了data的某个属性，就会执行该属性的getter方法，然后自动完成对该属性的订阅，当属性被修改时，就会执行该属性的setter方法，从而完成该属性的发布通知，通知所有订阅者进行更新。</p><h2 id="3-一个例子"><a href="#3-一个例子" class="headerlink" title="3.一个例子"></a>3.一个例子</h2><p>还是上面那个例子,data中的name就是一个订阅中心,name是一个发布者,当我们在页面A中使用name时,页面A就作为一个订阅者订阅了name属性,当name发生改变时,页面A就必须相应的发生改变。</p><h1 id="二-Vue的两个版本"><a href="#二-Vue的两个版本" class="headerlink" title="二.Vue的两个版本"></a>二.Vue的两个版本</h1><h2 id="1-Vue的两个版本"><a href="#1-Vue的两个版本" class="headerlink" title="1.Vue的两个版本"></a>1.Vue的两个版本</h2><p>Vue有两个版本，分别是完整版和非完整版，</p><h3 id="1-1-完整版"><a href="#1-1-完整版" class="headerlink" title="1.1 完整版"></a>1.1 完整版</h3><p>完整版同时包括编译器(compiler) 和 运行时(runtime)</p><p>Vue程序运行过程包括</p><p>template–(parse解析)–&gt;ast(抽象语法树)–(编译)–&gt;render(functions)–&gt;virtual Dom–&gt;UI</p><h3 id="1-2-只包含运行时版"><a href="#1-2-只包含运行时版" class="headerlink" title="1.2 只包含运行时版"></a>1.2 只包含运行时版</h3><p>只包含运行时版就只有运行时，没有编译器</p><p>Vue程序运行过程包括</p><p>render(functions)–&gt;virtual Dom–&gt;UI</p><p>可以看出 运行时版比完整版省略了前面两步,所以效率更高,代码更少</p><p><strong>前面的template到render函数真的被省略了吗,不是的,而是vue-template-compiler帮我们做了这个事</strong></p><h2 id="2-两个版本的区别"><a href="#2-两个版本的区别" class="headerlink" title="2.两个版本的区别"></a>2.两个版本的区别</h2><p>Vue完整版</p><p>Vue只包含运行时版</p><p>特点</p><p>有compiler</p><p>没有compiler</p><p>视图</p><p>写在HTML里，或者写在template选项里</p><p>写在render函数里，用h创建标签</p><p>cdn引入</p><p>vue.js</p><p>vue.runtime.js</p><p>webpack引入</p><p>需要配置alias</p><p>默认使用</p><p>vue@cli引入</p><p>需要额外配置</p><p>默认使用</p><p>那究竟应该使用哪一个版本呢？</p><p>最佳实践是使用 非完整版，然后用vue-loader引入compiler</p><p>整个流程思路如下：</p><ol><li> 对于用户来说，非完整版 （即runtime版）体积小，用户体验好，但只支持h函数</li><li> 对于程序员来说，只能写h函数的话，开发体验不好，如果有compiler, 开发者就能写更直观更语义化的HTML标签和template, 所以我们需要一个compiler</li><li> vue-loader就可以引入compiler, 把vue文件里的HTML标签和template 会在构建时预编译成 h函数，这样用户和开发者都高兴</li></ol><h1 id="三、template-和-render-的用法"><a href="#三、template-和-render-的用法" class="headerlink" title="三、template 和 render 的用法"></a>三、template 和 render 的用法</h1><p>template标签和JS里的template</p><p>render函数：</p><h1 id="四、快速在线上手Vue的神器"><a href="#四、快速在线上手Vue的神器" class="headerlink" title="四、快速在线上手Vue的神器"></a>四、快速在线上手Vue的神器</h1><p>我们可以在codesandbox里在线写Vue的代码，不用任何本地的安装依赖</p><p><a href="https://codesandbox.io/s/boring-sanderson-7ozng?file=/src/main.js">https://codesandbox.io/s/boring-sanderson-7ozng?file=/src/main.js</a></p><p> <img src="https://cdn.nlark.com/yuque/0/2020/png/540849/1593700793139-55acd1d9-e953-459a-960a-25891c80d0e4.png?x-oss-process=image/resize,w_1492"> </p><h1 id="五-computed与watch的区别"><a href="#五-computed与watch的区别" class="headerlink" title="五.computed与watch的区别"></a>五.computed与watch的区别</h1><h3 id="计算属性computed"><a href="#计算属性computed" class="headerlink" title="计算属性computed"></a>计算属性computed</h3><ul><li>  computed不加括号</li><li>  支持缓存，若依赖的属性没有变化，就不会进行重新计算。</li><li>  不支持异步，当computed内有异步操作时无效，无法监听数据的变化</li><li>  如果一个属性是由其他属性计算而来的，这个属性依赖其他属性，是一个多对一或者一对一，一般用computed</li><li>  如果computed属性属性值是函数，那么默认会走get方法；函数的返回值就是属性的属性值；在computed中的，属性都有一个get和一个set方法，当数据变化时，调用set方法。</li></ul><h3 id="侦听属性watch"><a href="#侦听属性watch" class="headerlink" title="侦听属性watch"></a>侦听属性watch</h3><ul><li>  不支持缓存，数据变，直接会触发相应的操作</li><li>  watch支持异步；监听的函数接收两个参数，第一个参数是最新的值；第二个参数是输入之前的值；</li><li>  当一个属性发生变化时，需要执行对应的操作；一对多；</li><li>  监听数据必须是data中声明过或者父组件传递过来的props中的数据，当数据变化时，触发其他操作，函数有两个参数：</li></ul><p>immediate: watch默认在数据从无到有的过程是不进行监听的，如果需要监听这个过程，可将immediate设置为true；</p><p>deep: deep的意思就是深入观察，监听器会一层层的往下遍历，给对象的所有属性都加上这个监听器，但是这样性能开销就会非常大了，任何修改obj里面任何一个属性都会触发这个监听器里的 handler</p><p>需要注意的是watch内部函数不可使用箭头函数，因为箭头函数本身无this，会继承window，导致箭头函数的this指向window，并非是Vue实例。</p><h3 id="综上所述"><a href="#综上所述" class="headerlink" title="综上所述"></a>综上所述</h3><ul><li>  computed在数据进行复杂运算的时候会简化代码</li><li>  watch监听数据变化的时候可以进行操作</li></ul><h1 id="六-Vue进阶构造属性"><a href="#六-Vue进阶构造属性" class="headerlink" title="六. Vue进阶构造属性"></a>六. Vue进阶构造属性</h1><h2 id="1-directive指令"><a href="#1-directive指令" class="headerlink" title="1.directive指令"></a>1.directive指令</h2><p>全局只用Vue.directive(“x”,{…})</p><p>局部使用options.directive</p><p>作用是减少DOM操作相关重复代码</p><h2 id="2-mixins-混入"><a href="#2-mixins-混入" class="headerlink" title="2.mixins 混入"></a>2.mixins 混入</h2><p>全局用Vue.mixin({…})</p><p>局部使用options.mixins:[mixin1,mixin2]</p><p>作用是减少options里的重复</p><h2 id="3-extends-继承-扩展"><a href="#3-extends-继承-扩展" class="headerlink" title="3.extends 继承/扩展"></a>3.extends 继承/扩展</h2><p>全局用VUe.extends({…})</p><p>局部用options.extend:{…}</p><p>作用跟mixins差不多,只是形式不同</p><h2 id="4-provide-inject-提供和注入"><a href="#4-provide-inject-提供和注入" class="headerlink" title="4.provide/inject 提供和注入"></a>4.provide/inject 提供和注入</h2><p>祖先提供东西,后代注入东西</p><p>作用是大范围,隔N代共享信息</p><h1 id="七-vue-cli简介"><a href="#七-vue-cli简介" class="headerlink" title="七.vue/cli简介"></a>七.vue/cli简介</h1><p>ClI是Command-Line Interface,翻译为命令行界面,但是俗称<strong>脚手架</strong>。</p><p>Vue Cli是一个官方发布的vue.js项目脚手架</p><p>使用vue-cli可以快速搭建Vue开发环境以及对应的webpack配置。</p><p>当我们在开发大型项目时,那么我们需要,并且必然需要使用Vue CLI</p><ul><li>  使用Vue.js开发大型应用时,我们需要考虑代码目录结构,项目结构和部署,热加载,代码单元测试等事情。</li><li>  如果每个项目都要手动完成这些工作,那无疑效率比较低效,所以通常我们会使用一些脚手架工具来帮助完成这些事情。</li></ul><h2 id="1-vue-cli安装"><a href="#1-vue-cli安装" class="headerlink" title="1.vue/cli安装"></a>1.vue/cli安装</h2><p>在安装vue/cli前,我们需要安装</p><p>nodejs(8.9以上版本),npm,webpack</p><p>cnpm更换镜像</p><p>1.安装vue/cli(默认安装 vue/cli3)</p><p>2.自由选择vue/cli版本</p><h2 id="2-vue-cli-2相关"><a href="#2-vue-cli-2相关" class="headerlink" title="2.vue/cli 2相关"></a>2.vue/cli 2相关</h2><p>vue2 构建项目</p><p>初始化项目时配置选项详解</p><p> <img src="https://cdn.nlark.com/yuque/0/2021/png/1554318/1610202734888-3abf2ef4-1873-4782-8fda-911a25011f6a.png?x-oss-process=image/resize,w_1110" alt="Snipaste_2021-01-09_22-28-50.png" title="Snipaste_2021-01-09_22-28-50.png"> </p><p>1.会根谎这个名称创建一个文件夹,存放之后项目的内容</p><p>该名称也会作为默认的项目名称,但是不能包含大写字母算</p><p>2项且名杨,不旋包含大写</p><p>[bogon:yuexmgsvueInitwebpackyvejsproject</p><p>6.ESLIn检测代码规范,看自己的情况</p><p>3.作者的信息,会默认从at中读取信息</p><p>L7Projectnanedyvuejsproject</p><p>7.单元测试</p><p>L7ProjectdescriptionAVuejsorojcct</p><p>果些公司强制雯求写单元测试</p><p>Authorcoderhy3726233269qq.com</p><p>4.后面详纽介绍</p><p>Vuebuiudruntime</p><p>InstaliVUe-router’No</p><p>USEESLINTTOLINTYOURcODEYNO</p><p>5.vue-router,这里我选择/o,后碗自己安装</p><p>SOTUPUNITTESTsNo</p><p>SetupezetestsnithNightwatch?No</p><p>houdWrunopInstattoryouottcrtheprojccthobeencratco</p><p>ended)(Usearrow</p><p>modebycodenwhy</p><p>Yes,UseNPH</p><p>微博:coderwhy</p><p>Yes,UseYarn</p><p>No,IMiLLHandLEthatayselr</p><p>B.2e测试Cndtocnd</p><p>安装Nightwatch,是一个利用selenlum或</p><p>weBdriver或phantomis等进行自动化测试的框架</p><p>9.择用yam或者npm安装都可以</p><h2 id="3-vue-cli-3相关"><a href="#3-vue-cli-3相关" class="headerlink" title="3.vue/cli 3相关"></a>3.vue/cli 3相关</h2><p>1.安装vue/cli(默认安装 vue/cli3)</p><p>2.自由选择vue/cli版本</p><p>vue3 构建项目</p><h2 id="4-vue-cli3与2版本的区别"><a href="#4-vue-cli3与2版本的区别" class="headerlink" title="4.vue-cli3与2版本的区别"></a>4.vue-cli3与2版本的区别</h2><ul><li>  vue-cli 3是基于webpack 4打造,vue-cli还是webpack3</li><li>  vue-cli3的设计原则是”0配置”,移除的配置文件根目录下的,build和config等目录</li><li>  vue-cli 3提供了vue ui 命令,提供了可视化配置,更加人性化</li><li>  移除了static文件夹,新增了public文件夹,并且index.html移动到了public中</li></ul><p>若有收获，就点个赞吧</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2021/03/03/%E4%B9%98%E9%A3%8E%E7%A0%B4%E6%B5%AA%E5%AD%A6%E4%B9%A0Vue(%E4%B8%8A)/"/>
    <url>/2021/03/03/%E4%B9%98%E9%A3%8E%E7%A0%B4%E6%B5%AA%E5%AD%A6%E4%B9%A0Vue(%E4%B8%8A)/</url>
    
    <content type="html"><![CDATA[<h1 id="乘风破浪学习Vue-上"><a href="#乘风破浪学习Vue-上" class="headerlink" title="乘风破浪学习Vue(上)"></a>乘风破浪学习Vue(上)</h1><h2 id="1-Vue基础"><a href="#1-Vue基础" class="headerlink" title="1.Vue基础"></a>1.Vue基础</h2><p><strong>1.1Vue是一个渐进式的框架,什么是渐进式呢?</strong></p><ul><li>  渐进式意味着你可以将Vue作为项目中的一部分嵌入其中,带来更加丰富的交互体验。</li><li>  Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与<a href="https://cn.vuejs.org/v2/guide/single-file-components.html">现代化的工具链</a>以及各种<a href="https://github.com/vuejs/awesome-vue#libraries--plugins">支持类库</a>结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。</li><li>  Vue不支持IE8及以下浏览器</li></ul><p><strong>1.2Vue有很多特点和WEB开发中常见的高级功能</strong></p><ul><li>  解耦视图和数据</li><li>  可复用的组件</li><li>  前端路由技术</li><li>  状态管理</li><li>  虚拟DOM</li></ul><p><strong>1.3Vue的五种安装方式</strong></p><ol><li> CDN</li><li> webpack</li><li> Rollup</li><li> Browserify</li><li> Parcel</li><li> npm</li></ol><p><strong>1.4 Vue中的MVVM</strong></p><p> <img src="https://cdn.nlark.com/yuque/0/2020/png/1554318/1605510142627-0affc2a9-34c8-463b-8680-ac2711ef90d7.png?x-oss-process=image/resize,w_664" alt="Snipaste_2020-11-16_15-01-44.png" title="Snipaste_2020-11-16_15-01-44.png"> </p><p>view层:</p><p>视图层</p><p>在我们前端开发中,通常就是DOM层.</p><p>主要的作用是给用户展示各种信息.</p><p>Model层:</p><p>数据层</p><p>数据可能是我们固定的死数据,更多的是来自我们服务</p><p>器,从网络上请求下来的数据.</p><p>在我们计数器的案例中,就是后面抽取出来的obj,当</p><p>然,里面的数据可能没有这么简单.</p><p>VueModel层:</p><p>视图模型层</p><p>视图模型层是view和Model沟通的桥梁.</p><p>一方面它实现了DataBinding,也就是数据绑定,将</p><p>Model的改变实时的反应到view中</p><p>另一方面它实现了DOMListener,也就是DOM监听,当</p><p>DOM发生一些事件(点击,滚动,touch等)时,可以监听</p><p>到,并在需要的情况下改变对应的Data.</p><p> <img src="https://cdn.nlark.com/yuque/0/2020/png/1554318/1605510250010-a9cb925e-9271-4b8e-a4c6-4c0c7dde8f38.png?x-oss-process=image/resize,w_756" alt="Snipaste_2020-11-16_15-03-52.png" title="Snipaste_2020-11-16_15-03-52.png"> </p><h2>当前计数:tcounter\]/h2><p><a href="I--tbuttonv-on:click-&quot;&#39;counter++&quot;">I--tbuttonv-on:click-&quot;&#39;counter++&quot;</a>+/button&gt;</p><p>tounter–a”‘&gt;-</button>–&gt;</p><p>?htp://w<a href="http://www.w3.rg/1999xhtml?Alt+Enter">www.w3.rg/1999xhtml?Alt+Enter</a></p><p>add”‘s+y/button&gt;</p><p>Vie曹</p><p>utconeogchc</p><p>pn:click-“‘sub”o-buttor&gt;</p><p>&lt;buttonv-on:cli</p><p>&lt;I-一下面是语法精写法–&gt;</p><!--<button@click-"'sub"-</button></div><scriptsrc-"../js/vue.js"xx/scriptYewMdpel<script>newVue01/语法糖:简写constappMonewvue(ie(data::0counter:methods:add:functionconsole.logcadd板行):this.counter++funcTioNOtsub:console.log(sub被执行");this.counter-在Vue中,MVVM也就是view,model,viewmodel的架构中dom结构表示viewnew Vue()中抽离出来的obj表示modelnew Vue()表示viewmodel.它们之间的工作原理:首先ViewModel通过Data Binding让obj中的数据实时的在DOM中显示。其次ViewModel通过DOM Listener来监听DOM事件,并且通过methods中的操作,来改变obj中的数据。**1.5 创建Vue实例传入的options对象**这个options传入时可以包含很多项,目前主要明白三种1.  el1.  类型:string || HTMLElement2.  作用:决定之后Vue实例会管理哪一个DOM.2.  data1.  类型: object || function(组件中的data必须是一个函数)2.  作用:Vue实例对应的数据对象3.  methods1.  类型:{\[key:string\]:function}2.  作用:定义属于Vue的一些方法,可以在其他地方调用,也可以在指令中调用3.    **1.5Vue生命周期**vue每个组件都是独立的，每个组件都有一个属于它的生命周期，从一个组件**创建、数据初始化、挂载、更新、销毁**，这就是一个组件所谓的生命周期。在组件中具体的方法有:   beforeCreate   created   beforeMount   mounted   (       beforeUpdate       updated   )   beforeDestroy   destroyed ![](https://cdn.nlark.com/yuque/0/2020/webp/1554318/1605511021612-88d861ab-0189-4d68-8443-939a4b13b59f.webp?x-oss-process=image%2Fresize%2Cw_600) 2.Vue模板语法---------### 2.1插值操作1.  mustache(胡子语法)1.  <span\>Message: </span\><ol start="2"><li><p> Mustache 标签将会被替代为对应数据对象上 <code>msg</code> property 的值。无论何时，绑定的数据对象上 <code>msg</code> property 发生了改变，插值处的内容都会更新。</p></li><li><p> v-once语法</p></li><li><p> v-once表示该元素或组件只能被渲染一次,不会随着数据的改变而改变,v-once后面不需要接任何表达式。</p></li></ol><p>3.v-html语法</p><ol><li> <em><!-- v-html可以识别内容中的html标签代码 --></em></li></ol><p><em><!-- v-html后面接属性名 --></em></p><p>4.v-text语法</p><ol><li> <em><!-- v-text类似于,可以直接进行插值操作,但是无法识别html标签 –&gt;</em></li></ol><p><em><!-- v-text接属性名 --></em></p><p><em><!-- v-text不够灵活,一般不适用 --></em></p><p>5.v-pre语法</p><ol><li> <em><!-- v-pre表示该元素或组件的内容原封不动的显示出来,不需要任何解析--></em></li></ol><p><em><!-- v-pre后面不需要接任何表达式 --></em></p><p><em>6.v-cloak语法</em></p><p>_ a.<!-- v-cloak 斗篷  -->_</p><p><em><!-- 当设置了v-cloak属性的元素没被vue解析之前,元素中v-cloak依然存在 --></em></p><p><em><!-- 当设置了v-cloak属性的元素被vue解析之后,元素中v-cloak被删除 --></em></p><h3 id="2-2-v-bind绑定属性"><a href="#2-2-v-bind绑定属性" class="headerlink" title="2.2 v-bind绑定属性"></a>2.2 v-bind绑定属性</h3><ol><li><p>  mustache语法无法只能动态改变元素内容,无法动态改变元素属性，v-bind语法可以动态改变元素属性</p></li><li><p> bind作用：动态绑定属性(属性可以是字符串,也可以直接写一个变量)</p></li><li><p> 编写v-bind 语法糖: <strong>:</strong></p></li><li><p> 基本使用 动态绑定图片和链接地址。</p></li></ol><p>2.v-bind动态绑定类名(对象语法)</p><p>将要添加的多个类名,已经决定类名是否出现的boolean值写在对象中,采用键值对的形式来添加多个类名—{类名1:boolean,类名2:boolean}</p><p>注意:对象中的类可以和普通的类共存。</p><p>改进:如果类名太多的话可以用一个函数取代此对象。</p><p>3.v-bind动态绑定类名(数组语法)</p><p>与对象类似,只是这种方法很少用</p><p>如果类名很多的话</p><p> <img src="https://cdn.nlark.com/yuque/0/2020/png/1554318/1605513847843-4be0334a-0fe1-4ae8-ae45-229095545bcf.png" alt="Snipaste_2020-11-16_16-03-49.png" title="Snipaste_2020-11-16_16-03-49.png"> </p><p>用法一:直接通过鲁绑定一个类</p><p><a href="h2:class-&quot;ractive\*\]&quot;Helloworld/h2">h2:class-&quot;ractive\*\]&quot;Helloworld/h2</a></p><p>用法二:也可以传入多个值</p><p><a href="hz:class-&quot;factive&#39;line\*\]&quot;&#39;sHelloworld/h2">hz:class-&quot;factive&#39;line\*\]&quot;&#39;sHelloworld/h2</a></p><p>用法三:和普通的类同时存在,并不冲突</p><p>注:会有title/active/line三个类</p><p>sh2class”title:class-“ractiveline”Helloold/h</p><p>用法四:如果过于复杂,可以在一个methods或者computed中</p><p>注:classes是一个计算属性</p><p>h2dlass-“title:class-lasses”Helloworld/h2&gt;</p><p><strong>4.v-bind()动态绑定style(对象语法)</strong></p><p><strong>在Vue中,对象中的属性值如果没加引号会被解析成变量,加了引号会被解析成字符串。</strong></p><p>v-bind动态绑定样式和动态绑定类名类似,样式们可以用驼峰命名法也可以用-连接。</p><p>如果使用对象语法绑定,记得注意对象中的属性名是否需要加引号。</p><p>同样如果需要很多样式,可以用一个函数代替对象。</p><p><strong>5.**</strong>v-bind()动态绑定style(数组语法)**</p><p><strong>在Vue中,数组中的项如果没加引号会被解析成变量,加了引号会被解析成字符串。</strong></p><h3 id="2-3-计算属性computed"><a href="#2-3-计算属性computed" class="headerlink" title="2.3 计算属性computed"></a>2.3 计算属性computed</h3><p>我们知道,在模板中可以直接通过插值语法显示一些data中的数据。模板内的表达式非常便利，但是设计它们的初衷是用于简单运算的。在模板中放入太多的逻辑会让模板过重且难以维护</p><p>但是在某些情况下,我们可能需要对数据进行一些转化后再显示,或则需要将多个数据结合起来进行显示</p><ul><li>  比如我们有firstName和lastName两个变量,我们需要显示完整的名称。</li><li>  但是如果多个地方都需要显示完整的名称,我们就需要写多个</li></ul><p>我们可以将上面的代码换成计算属性。计算属性写在实例的comptued选项中。</p><h4 id="2-3-1-methods与computed的区别"><a href="#2-3-1-methods与computed的区别" class="headerlink" title="2.3.1 methods与computed的区别"></a>2.3.1 methods与computed的区别</h4><p>为什么methods和computed看起来都可以实现我们的功能,那么为什么还要多一个计算属性这个东西呢?</p><p>原因:计算属性性能更高,computed会进行缓存,如果多次调用时,,对未发生改变的只会调用一次,methods则是调用一次执行一次,当一个属性的计算涉及到其他属性时,用计算属性。比如购物车的总价。</p><h3 id="2-4-事件监听"><a href="#2-4-事件监听" class="headerlink" title="2.4 事件监听"></a>2.4 事件监听</h3><p><strong>1.v-on绑定事件</strong></p><p>v-on的基本使用和语法糖,可以将v-on:click 简写 成 @click</p><p>2.v-on的传参问题</p><p>方法后面不写小括号的情况</p><p>情况一:当不需要传入额外参数,那么方法后面的()可以省略。</p><p>情况二:在事件定义时,写函数时省略了小括号,但是方法本身是需要一个参数的 ,这个时候Vue默认会将浏览器生成的 event事件作为参数传入到方法。</p><p>方法后面写了小括号但没传参数的情况</p><p>情况一:方法需要一个参数时,打印undefined。</p><p>情况二:如果想同时传入浏览器事件和其他参数,可以用$event来传入浏览器事件。</p><p>3.v-on修饰符</p><ul><li>  stop 阻止冒泡</li><li>  prevent 阻止默认事件</li><li>  native 监听自定义组件</li><li>  . + 某个键帽的keyCode值 监听键盘上的某个键帽</li><li>  once  只能被触发一次回调</li><li>  sync 当一个子组件改变了一个 prop 的值时，这个变化也会同步到父组件中所绑定。</li></ul><h3 id="2-5-条件判断"><a href="#2-5-条件判断" class="headerlink" title="2.5 条件判断"></a>2.5 条件判断</h3><p>1.v-if,v-else,v-else-if</p><p>这三个指令与javascript中的if,else,if-else类似</p><p>vue的条件指令可以根据表达式的值在DOM渲染或销毁元素或组件</p><p>2.v-if的原理</p><p>v-if后面的条件为false时,对应的元素以及子元素不会被渲染。</p><p>也就是不会有对应的标签出现在DOM结构中</p><p>3.切换登录类似案例:当v-if为true时,显示用户登录,否则显示邮箱登录。</p><p>注意：这个案例会出现一个bug,就是如果用户已经在输入框中输入了值,那么即使切换了登录类型,里面的值也不会清空。</p><p>原因:因为vue在进行DOM渲染时,出于性能考虑,会尽可能的复用已经存在的元素,而不是创建新的元素。</p><p>解决方案：如果我们不希望vue出现类似的元素或组件复用问题,可以给对于的元素添加:key,并且保证key的不同。</p><p>4.v-if与v-show的区别</p><p>当v-if为false时,v-if后面的元素不会被渲染到DOM结构中。</p><p>当v-show为false时,后面元素依旧会出现在DOM结构中,只是添加了display:none;的属性。</p><p>开发时如何选择</p><p>当需要在显示和隐藏之间切换很频繁时,选择用v-show</p><p>当只切换一次时,选择用v-if</p><h3 id="2-6-循环遍历"><a href="#2-6-循环遍历" class="headerlink" title="2.6 循环遍历"></a>2.6 循环遍历</h3><p>1.v-for循环遍历数组</p><p>注意:当需要用到索引时,可以在item后面添加index。一定要做加一个:key key的值一般是唯一的</p><p>2.v-for循环遍历对象</p><p>注意循环遍历对象时的参数顺序:value(属性值),key(属性名),index(索引号)</p><p>3.v-for绑定和非绑定key的区别</p><p>官方推荐我们在使用v-for时,给对应的元素或组件添加一个:key属性</p><p>当某一层有很多相同的节点时,也就是列表节点时,我们希望插入一个新的节点假设有一个数组里面放着[A,B,C,D,E]</p><ul><li>  我们想在B和C之间加一个F,Diff算法默认执行起来是这样的。</li><li>  即把C更新成F,D更新成C,Ez更新成D,最后再插入E,是不是很没有效率</li></ul><p>所以我们需要使用key来给每个节点做一个唯一标识</p><ul><li>  diff算法就可以正确识别此节点</li><li>  找到正确的位置区插入新的节点</li><li>  key的值最好与数组或对象中的每一项</li></ul><p>原因:为了高效的更新虚拟DOM.</p><p>我的理解:提高我们对数组,对象进行插入,删除,替换操作的效率。</p><p>从diff算法层面解释:<a href="https://www.cnblogs.com/chenyuhang/articles/9924728.html">关于v-for中加:key属性的原因</a></p><p>4.数组中那些方法是响应式的</p><p>1.push,pop,shift,unshift,splice,sort,reverse等。</p><p>注意:通过索引号的方式来修改数组的元素不是响应式的(不是更新)。</p><h3 id="2-7表单与数据的双向绑定"><a href="#2-7表单与数据的双向绑定" class="headerlink" title="2.7表单与数据的双向绑定"></a>2.7表单与数据的双向绑定</h3><p>v-model可以实现表单和数据的双向绑定,就是说一旦表单添加了v-model属性并且连接到了数据中的某个属性,那么这个属性与表单的值就会实现共同变化。</p><p>v-model的原理</p><p>v-model与单选按钮的结合使用</p><p>v-model与复选框的结合使用</p><p>当只有一个复选框时</p><p>当有多个复选框时</p><h3 id="2-8-值绑定"><a href="#2-8-值绑定" class="headerlink" title="2.8 值绑定"></a>2.8 值绑定</h3><p>值绑定其实就是动态的给value赋值而已</p><ul><li>  前面我们value中的值都是我们在定义input时直接给定的。</li><li>  但是真实开发中,这些inpt的值可能是从网络获取或则定义在data中的。</li><li>  多以我们可以通过:value动态的给value绑定值。</li></ul><p>也可以说是v-bind在input的应用</p><h3 id="2-9-v-model修饰符"><a href="#2-9-v-model修饰符" class="headerlink" title="2.9 v-model修饰符"></a>2.9 v-model修饰符</h3><p>lazy修饰符</p><p>默认情况下,v-model默认是在input事件 中同步输入框的数据的。</p><p>也就是说,一旦有数据发生改变,对应的data中的数据就会发生改变。</p><p>lazy修饰符可以让数据在用户敲回车或则输入框失去焦点时更新数据。</p><p>number修饰符</p><p>默认情况下,无论我们在输入框中输入了什么数据,最后都会被转换成字符串型进行处理。</p><p>但是当我们希望出来的数据是数字型时,那么最好将内容当做数字来处理。</p><p>number修饰符可以让输入框中输入的数据自动转化为数字类型。</p><p>trim修饰符</p><p>如果输入的内容左右有很多空格,我们希望去除这些多余的空格。</p><p>trim修饰符可以去除内容左右的额空格。</p><h2 id="3-组件化开发"><a href="#3-组件化开发" class="headerlink" title="3.组件化开发"></a>3.组件化开发</h2><h3 id="1-组件化开发思想"><a href="#1-组件化开发思想" class="headerlink" title="1.组件化开发思想"></a>1.组件化开发思想</h3><ul><li>  如果我们将一个页面中所有的处理逻辑全部放在一起,处理起来就会变得十分复杂,而且不利于以后的管理以及扩展。</li><li>  但如果,我们将一个页面拆分成一个个小小的功能块,每个功能块完成属于自己这部分独立的功能,那么之后整个页面的管理和维护就会变得容易许多。</li></ul><h3 id="2-组件化思想的应用"><a href="#2-组件化思想的应用" class="headerlink" title="2.组件化思想的应用"></a>2.组件化思想的应用</h3><ul><li>  有了组件化的思想,我们在以后的开发中就要充分的利用它。</li><li>  尽可能的将页面拆分成一个个小的,可复用的组件。</li><li>  这样让我们的代码更加方便组织和管理,并且扩展性也很强</li></ul><h3 id="3-注册逐渐的基本步骤"><a href="#3-注册逐渐的基本步骤" class="headerlink" title="3.注册逐渐的基本步骤"></a>3.注册逐渐的基本步骤</h3><p>组件的使用分为三个步骤</p><ol><li> 创建组件构造器(Vue.extend())</li><li> 注册组件(Vue.component())</li><li> 使用组件(在vue实例范围之内)</li></ol><h3 id="4-全局组件和局部组件"><a href="#4-全局组件和局部组件" class="headerlink" title="4.全局组件和局部组件"></a>4.全局组件和局部组件</h3><p><strong>全局组件</strong></p><p>定义在Vue实例外的组件叫做全局组件,全局组件可以供所有的Vue实例使用</p><p><strong>局部组件</strong></p><p>定义在Vue实例中的组件叫做局部组件,局部组件是实例的私有组件,只能在该vue实例中使用</p><h3 id="5-子组件和父组件的区分"><a href="#5-子组件和父组件的区分" class="headerlink" title="5.子组件和父组件的区分"></a>5.子组件和父组件的区分</h3><p>创建组件构造器Vue.extend({})中也是有许多属性的,除了模板属性template以外,还有components组件属性,</p><p>通过这个属性我们可以实现父子组件。</p><p>1.构建子组件。</p><p>2.构建父组件,在父组件中利用components调用子组件。</p><p>3.最后将父组件设置为全局组件或则局部组件。</p><h3 id="6-注册组件的语法糖写法"><a href="#6-注册组件的语法糖写法" class="headerlink" title="6.注册组件的语法糖写法"></a>6.注册组件的语法糖写法</h3><p>注册组件的语法糖写法其实就省略了注册组件的第一步–创建组件构造器。</p><p>当创建全局组件时,Vue.component(“组件标签名”,组件构造器对象)。</p><p>当创建局部变量时,</p><p>components: {</p><p>template: {</p><p>“组件标签名”:字符串模板</p><p>}</p><p>在3.3中我们是这样创建组件的</p><p>语法糖写法</p><h3 id="7-组件模板的抽离写法"><a href="#7-组件模板的抽离写法" class="headerlink" title="7.组件模板的抽离写法"></a>7.组件模板的抽离写法</h3><p>显然让大量HTML代码存在于script中是很不明智的选择,所以我们选择将template后的字符串模板分离出来。</p><p>具体方法:</p><p>1.<script type="text/x-template" ></p><p>组件中需要使用的HTML代码</p><script>2.<template>组件中需要使用的HTML代码</template>没有抽离组件模板之前的代码分离之后的代码注意:记得给分离的代码一个类名或则id名,然后template后面只要写这个类名就可以使用这些被分离的代码啦。在模板中,一般用一个根元素(div)包含我们的代码。### 8.为什么组件的data必须是函数?创建组件构造器Vue.extend({})中的对象还有data属性,专门用来存放组件的数据。组件是一个单独功能模块的封装,它有自己的HTML模板,也有属性自己的数据.这些数据放在data属性中,data属性必须为函数,并且这个函数返回一个存放着组件数据的对象。#### 为什么data属性必须是个函数呢?一个组件可能会在很多页面中使用,如果组件的data是一个对象的话,因为在ES5中对象没有自己的作用域,所以如果有一个组件修改了data那么会影响到其他相同组件的data。这是我们不期待的结果。而反之,函数有自己的作用域,所以使用函数去返回一个对象可以达到每一个组件都有自己的data的目的。如果在某种情景下我们需要组件的data互相影响,可以定义一个对象,然后将此对象的地址给data。4.组件化开发高级---------#### 1.父子组件通信（传值）1.1 父传子props步骤一:定义一个将来会在子组件中使用的组件名。步骤二:将父组件的数据绑定在上一步创建的组件中步骤三: 在子组件中使用第一步创建的组件注意:当props是对象时,可以定义组件名的默认值和限制其类型当参数是变量时,需要使用v-bind,如果是常量,则不需要注意点:当props中的属性名以**驼峰命名法**命名时,我们在子组件中使用props中的属性时,属性名不能用驼峰标识法而要用-连接。2.子传父(自定义事件)步骤一:在子组件中利用this.$emit()发射自定义事件。($event可以接受$emit传过来的参数)步骤二:在挂载的实例中使用将发射过来的自定义事件当做父组件的方法。步骤三:在父组件中使用此方法处理事件。#### 2.父子组件通信(方法)前面提到的props父传子数据与this.$emit()子传父数据传的都是值,没有方法。父子之间方法的传递:子访问父方法this.$parent()访问根 this.$root()2.父访问子方法 this.$refs(常用) 或this.children#### 3.插槽slot是什么**插槽是为了使我们封装的组件更具有扩展性。****让使用者决定组件内部的一些内容到底展示什么**插槽的基本使用<slot><slot>插槽的默认值<slot><button>按钮</button><slot>如果有多个值放到组件中进行替换时,一起作为替换元素。#### 4.具名插槽的使用当我们需要指定替换某一个插槽时,需要使用具名插槽。通俗点来说就是给某一个具体的有名字的插槽替换掉。1.给目标插槽一个name属性。2.在替换它的标签中使用slot="目标插槽name属性的值"具体代码如下上述代码中我们将中间的插槽的内容替换成了标题。### 5.编译作用域决定变量作用范围的是其所在的模板,父组件模板的变量都会在父级作用域下编译,子组件模板的变量都会在子级作用域下编译。#### 5.1 作用域插槽当父组件希望以不同的形式来展示子组件时,我们需要用到作用域插槽。### 6.模块化开发#### 6.1前端代码复杂带来的问题JS最初的目的仅仅是做一些用户交互,表单验证。随着客户端需要完成的业务越来越多,代码量与日剧增。为了应对代码量的剧增,我们通常会将代码组织在多个js文件中,进行维护。但是这种维护方式,依然不能避免一些灾难性的问题。比如全局变量同名问题。JS文件的引入顺序#### 6.2 前端模块化雏形和commonjs我们可以怎样去解决上述问题呢?我们可以使用将需要暴露到外面的变量,使用一个模块作为出口.。前端模块化就建立在这种最基础的封装上。关于前端模块化,我们现在已经有了很多既有的规范,以及对应的实现方案。常见的模块化规范:CommonJS,AMD,CMD,也有ES6的Modules.#### 6.3 commonjs1.用一个变量接受   module.exports({})导出变量及函数。2.用解构赋值和require("导出的变量")具体代码: ![Snipaste_2020-11-20_22-30-17.png](https://cdn.nlark.com/yuque/0/2020/png/1554318/1605882773952-a90f3d1e-6f25-4679-8847-39a48dd0ca79.png "Snipaste_2020-11-20_22-30-17.png") 模块化有两个核心:导出和导入CommonJS的导出:module.exportsflag:true.test(a,b)(return方,demo(a,b)(returnaCommonJS的导入IcommonJs模块lettest.demo,flagrequireCmodulea):1等同于TetmArequireCmodulea);TettestmA.test:letdemomA.demo:letf1agmA.flag:#### 6.4 ES6模块化导出exports用法: ![Snipaste_2020-11-20_22-36-22.png](https://cdn.nlark.com/yuque/0/2020/png/1554318/1605882994387-5eb4a1ab-02ce-4c19-83bd-e6bdad0796bd.png "Snipaste_2020-11-20_22-36-22.png") export指令用于导出变量,比如下面的代码:W/info.jswhyletexportname18exportletagetletheight-1.88export上面的代码还有另外一种写法:AH/info.jsletname-'why"letage-18letheight-1.88exportCname,age.heigh ![Snipaste_2020-11-20_22-34-32.png](https://cdn.nlark.com/yuque/0/2020/png/1554318/1605882907663-70fbd2fc-41ee-42c0-88ad-5d3d69233938.png "Snipaste_2020-11-20_22-34-32.png") 上面我们主要是输出变量,也可以输出函数或者输出类口上面的代码也可以写成这种形式exportfunctiontest(content)tfunctiontest(content)console.1og(content):console.1og(content);classPersonexportclassPersonconstructor(name,agethis.nameename;constructorname,age)this.age-age;this.name-namerthis.age-age;runOfconsoLe.log(this.name在奔跑"):runO在奔跑'conso1e.1og(this.ameexport\[test,person4.导出 export default.export  default addressimpoet add from "文件"5.统一导入所有变量 ![Snipaste_2020-11-20_23-27-27.png](https://cdn.nlark.com/yuque/0/2020/png/1554318/1605886064184-9613964e-bdce-478b-af2d-1f0fd5c03257.png?x-oss-process=image%2Fresize%2Cw_890 "Snipaste_2020-11-20_23-27-27.png") 如果我们希望某个模块中所有的信息都导入,一个个导入显然有些麻烦口通过\*可以导入模块中所有的export变量但是通常情况下我们需要给\*起一个别名,方便后续的使用import\*asinfofrom'./info.jsconsole.logcinfo.nameif.g.hgfofrin####   若有收获，就点个赞吧]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2021/03/03/%E4%BC%9A%E5%8A%A8%E7%9A%84%E5%93%86%E5%95%A6A%E6%A2%A6%E7%9A%84%E8%AF%9E%E7%94%9F/"/>
    <url>/2021/03/03/%E4%BC%9A%E5%8A%A8%E7%9A%84%E5%93%86%E5%95%A6A%E6%A2%A6%E7%9A%84%E8%AF%9E%E7%94%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="会动的哆啦A梦的诞生"><a href="#会动的哆啦A梦的诞生" class="headerlink" title="会动的哆啦A梦的诞生"></a>会动的哆啦A梦的诞生</h1><p>主要业务逻辑:</p><p>将制作哆啦A梦的过程展示出来,隐藏HTML结构,将CSS放在一个字符串中,新建一个字符串2,设置一个定时器,定时的将字符串1中的字符复制到字符串2中并展示到界面里然后同步放入到HTML中的一个style元素中,实现页面展示到什么css，动画就即时的呈现出对应的效果。</p><p>项目难点:如何固定哆啦A梦的位置,如何保证动态代码随着滚动条滚动,在手机端如何呈现效果,如何实现实时预览。</p><p>解决方案:</p><p>使用fixed定位固定哆啦A梦的位置</p><p>window.scrollTo(0,9999)保证动态代码随着滚动条</p><p>手机端预览</p><p>实时预览:将css代码放在一个style元素中,当点击预览按钮时,清空之前css样式,填充新的style.</p><p>若有收获，就点个赞吧</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2021/03/03/webpack%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
    <url>/2021/03/03/webpack%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="webpack的基本使用"><a href="#webpack的基本使用" class="headerlink" title="webpack的基本使用"></a>webpack的基本使用</h1><h2 id="1-下载安装webpack"><a href="#1-下载安装webpack" class="headerlink" title="1.下载安装webpack"></a>1.下载安装webpack</h2><p>切换到指定目录</p><p>执行一下代码,安装webpack</p><p>npm init -y npm install webpack webpack-cli </p><h2 id="2-新建webpack-config-js文件"><a href="#2-新建webpack-config-js文件" class="headerlink" title="2.新建webpack.config.js文件"></a>2.新建webpack.config.js文件</h2><p>新建一个webpack.config.js文件,围绕这个文件来实现我们的配置</p><p>const path = require(‘path’); module.exports = {  mode: “development”, entry: ‘./src/index.js’, output: { path: path.resolve(__dirname, ‘dist’), filename: ‘[name].[contenthash].js’ } }</p><h2 id="3-目标一-用webpack转译JS"><a href="#3-目标一-用webpack转译JS" class="headerlink" title="3.目标一:用webpack转译JS"></a>3.目标一:用webpack转译JS</h2><p>执行webpack工具</p><p>npx webpack</p><p>执行之后,文件目录中生成一个dist文件,里面还有一个main.js,main.js就是对./src/index.js的内容的转译。</p><h2 id="4-目标二-用webpack生成HTML"><a href="#4-目标二-用webpack生成HTML" class="headerlink" title="4.目标二:用webpack生成HTML"></a>4.目标二:用webpack生成HTML</h2><p>第一步:npm install –save-dev html-webpack-plugin</p><p>第二步:在src下创建assets目录,assets中在创建index.html文件</p><p>配置webpack.config.js</p><p>const path = require(‘path’); const HtmlWebpackPlugin = require(‘html-webpack-plugin’); // module.exports = {  mode: ‘development’, entry: ‘./src/index.js’, output: { filename: ‘main.js’, path: path.resolve(__dirname, ‘dist’), filename: ‘[name].[contenthash].js’ }, plugins: [new HtmlWebpackPlugin({ title: ‘My App’, template: “src/assets/index.html”, })], };</p><p>以上代码是说按照 “src/assets/index.html” 为模板，title为MY APP生成一个网页</p><h2 id="5-目标三-用webpack生成css"><a href="#5-目标三-用webpack生成css" class="headerlink" title="5.目标三:用webpack生成css"></a>5.目标三:用webpack生成css</h2><p>第一步:下载css-loader  style-loader</p><p>第二步:配置webpack.config.js</p><p>然后再yarn build</p><p>然后如果引入css, webpack 就会把css标签读出来放到style标签里</p><p> <img src="https://cdn.nlark.com/yuque/0/2020/png/540849/1593616404442-31bb3967-4b75-449e-b827-4ea3c08665bf.png?x-oss-process=image/resize,w_1396"> </p><p>红色圈中的就是加载的css</p><p>现在我们把css放进了style标签</p><p>但如果我们希望单独抽成css文件呢？</p><p>下载插件</p><p>修改webpack.config.js</p><p>打包一下:yarn build</p><h2 id="6-目标四-简化编译-安装webpack-dev-server"><a href="#6-目标四-简化编译-安装webpack-dev-server" class="headerlink" title="6.目标四: 简化编译 安装webpack-dev-server"></a>6.目标四: 简化编译 安装webpack-dev-server</h2><p>每次修改css, 首先是在dist文件夹里 http-server -c-1 开启服务器，如果要修改，就要断掉服务器，然后再改css, 再重新yarn build,  太麻烦了。</p><p>下载插件</p><p>配置webpack.config.js</p><p>package.json中加一句”start”: “webpack serve –open”,</p><p>以后yarn start就可以实时预览了</p><h2 id="7-目标五-据模式选择不同的编译"><a href="#7-目标五-据模式选择不同的编译" class="headerlink" title="7.目标五:据模式选择不同的编译"></a>7.目标五:据模式选择不同的编译</h2><p>开发模式下，把css生成为style标签</p><p>在生产模式下，把css单独抽成文件</p><p>在开发时，我们用yarn start，</p><p>在生产时，我们用yarn build，css生成style标签</p><p>我们能不能配两个config文件，实现这种需求</p><p>但是问题是，这两个文件只有少数几行不一样，其他都完全一样，有没有更好的办法？</p><p>有！使用JS的<strong>继承思想</strong></p><p>首先我们准备一个webpack.config.base.js 把所有的公共属性都放进去</p><h2 id="8-用到的loader和plugin"><a href="#8-用到的loader和plugin" class="headerlink" title="8.用到的loader和plugin"></a>8.用到的loader和plugin</h2><ul><li>  MiniCssExtractPlugin</li><li>  HtmlWebpackPlugin</li><li>  css-loader</li><li>  style-loader</li><li>  file-loader</li><li>  stylus-loader</li><li>  sass-loader</li><li>  UglifyJsPlugin</li></ul><h3 id="8-1-loader与plugin的区别"><a href="#8-1-loader与plugin的区别" class="headerlink" title="8.1 loader与plugin的区别"></a>8.1 loader与plugin的区别</h3><ol><li> 翻译：loader是加载器，plugin是插件</li><li>中文解释：加载器就是用来加载文件的，<br> a. 比如babel loader是用来加载JS的，把高级的JS转译成低版本的JS,<br> b. CSS loader就是用来加载CSS的</li><li> 插件是用来加强webpack功能的，比如HTMLWebpackPlugin是用来加载HTML的，miniCssExtractPlugin可以把多个CSS文件合并成一个CSS文件</li><li> 总的来说，加载器主要用来加载文件，而插件的功能更加丰富</li></ol><p>若有收获，就点个赞吧</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2021/03/03/%E7%99%BD%E9%A3%8E%E8%B5%B7%E5%A7%8B%E9%A1%B5%E7%9A%84%E8%AF%9E%E7%94%9F/"/>
    <url>/2021/03/03/%E7%99%BD%E9%A3%8E%E8%B5%B7%E5%A7%8B%E9%A1%B5%E7%9A%84%E8%AF%9E%E7%94%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="白风起始页的诞生"><a href="#白风起始页的诞生" class="headerlink" title="白风起始页的诞生"></a>白风起始页的诞生</h1><p>白风起始页是我在11月时模仿github上的一个项目而制作一个网站起始页,它主要的功能就是一个以简洁为主题的搜索页,用户可以收藏自己喜欢的网站,删除自己不喜欢的网站,查询自己想要的信息。</p><p>写下这篇笔记既是对自己的第一个小项目的总结,也是对在制作此项目的过程中遇到问题并解决问题的过程做一个记录。</p><p>问题①: 页面应该如何设计与布局</p><p>千里之行始于足下,要做一个起始页首先得美观,可是作为一个程序员,从来没有接触过设计,所以设计一个美观实用的网站成为了我遇到的第一个难题。</p><p>解决方案: 借鉴市场上最受用户欢迎的起始页,然后用figma工具制作出雏形。</p><p>问题②:考虑用什么技术</p><p>页面布局用什么技术,是否考虑兼容性,这些都是需要在一开始就想清楚的。考虑到现在移动端的市场已经非常成熟,而且越来越少的用户使用IE,所以我大胆的尝试使用flex布局,不过由于自己的知识框架还十分狭窄,所以JS还是使用了jQuery。</p><p>功能实现过程</p><p>功能①:新增网站</p><p>业务逻辑:点击新增,弹出对话框,输入需要收藏的网址,在界面添加。</p><p>因为页面显示的网站信息包括网址与网址开头的第一个字母,为了简洁,我只显示网址中间的一小部分,将协议,www和后面的查询参数等信息全部过滤。创建一个元素插在+前。</p><p>功能②:本地储存已添加的网站</p><p>业务逻辑:将所有网站的信息存储在LocalStorage中,这样每次刷新页面,都可以将之前的记录重新渲染。</p><p>功能③:删除已经显示出来的网站</p><p>业务逻辑:点击×图标将被点击的网址从JSON中删除。</p><p>若有收获，就点个赞吧</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2021/03/03/%E5%85%AD%E4%B8%AA%E8%A7%92%E5%BA%A6%E6%B5%85%E6%9E%90%E5%89%8D%E7%AB%AF/"/>
    <url>/2021/03/03/%E5%85%AD%E4%B8%AA%E8%A7%92%E5%BA%A6%E6%B5%85%E6%9E%90%E5%89%8D%E7%AB%AF/</url>
    
    <content type="html"><![CDATA[<h1 id="六个角度浅析前端"><a href="#六个角度浅析前端" class="headerlink" title="六个角度浅析前端"></a>六个角度浅析前端</h1><h2 id="1-什么是前端"><a href="#1-什么是前端" class="headerlink" title="1.什么是前端?"></a>1.什么是前端?</h2><p>前端是一个工作,工作领域是浏览器,它既要和美工,设计打交道,还要懂点后台代码,知道怎么用ajax从后台拿数据,接口怎么调用,最主要的是还要把美工的图完美的在网页中呈现并实现交互效果。</p><p>前端处于设计与后台的中间领域,起到承上启下的作用,这也要求前端工程师的知识面在横向上必须要广。服务器技术要懂,产品与交互也要懂。</p><p>它需要掌握三个基本技能:HTML,CSS,JavaScript。另外还有懂点node.js或则其他后端语言。</p><p>前端工程师主要面向用户,浏览器,数据接口。</p><h2 id="2-前端工程师的价值主要体现在哪里"><a href="#2-前端工程师的价值主要体现在哪里" class="headerlink" title="2.前端工程师的价值主要体现在哪里?"></a>2.前端工程师的价值主要体现在哪里?</h2><p>(1) 让用户更便捷的获取信息。拿到psd,产出线上的代码,中间有很多细节需要认真对待。表单的各种交互m页面不同元素间的信息交互,都需要依靠自己的技术能力和自己对用户的感知去完成。</p><p>(2) 让前端更加规范和标准。不断看各种规范,比较不用版本的区别,并思考引入的新特性的意义(技术或商业)。关注这个行业的最新发展,找出创新点,把自己对问题或bug的解决思路或方案总结并分享,为自己的公司,同行以及整个行业贡献自己的力量,推动前端的发展。</p><h2 id="3-需要掌握的技能"><a href="#3-需要掌握的技能" class="headerlink" title="3.需要掌握的技能"></a>3.需要掌握的技能</h2><p>(1)解决浏览器兼容问题。前端需要懂得至少三种浏览器内核的接口,还要面对各种莫名其妙的bug,前端的技术也是日新月异,css3的规范标准什么时候能确定还是未知。</p><p>(2)横向技能面要广。懂交互设计,懂视觉设计,略懂后台技术,精通http协议,git,vim,svn等;至少熟练一门后端语言,至少使用过一个MVC开发框架,还有前端的各种开源项目(jquery,vue,react,requirejs)；要灵活运用”面向对象”，”面向过程”的编程方法；还要懂设计模式。</p><p>(3)纵向技能要深。js,css,html5,css3….</p><p>(4)关注用户体验,懂得交互设计。帮忙产品经理和交互设计师校验错误是前端工程师的义务和责任。作为页面的实现者,如果不嗯呢该提前预测可能存在的问题,后期的错误会越来越多。</p><h2 id="4-应该具备怎样的知识结构？"><a href="#4-应该具备怎样的知识结构？" class="headerlink" title="4. 应该具备怎样的知识结构？"></a>4. 应该具备怎样的知识结构？</h2><p> <img src="https://cdn.nlark.com/yuque/0/2020/jpeg/1554318/1609036338211-912fdeab-6f30-4ccb-a948-9dff7d279a97.jpeg"> </p><p> <img src="https://cdn.nlark.com/yuque/0/2020/jpeg/1554318/1609036365851-94149bfd-412d-47c8-8d7c-a1b8493b0ee4.jpeg"> </p><h2 id="5-前端在研发团队中的位置"><a href="#5-前端在研发团队中的位置" class="headerlink" title="5.前端在研发团队中的位置?"></a>5.前端在研发团队中的位置?</h2><p>比较理想的情况是前端输入的依然是psd稿,如果产品和设计能力不足,还可能需要前端参与交互设计。输出则是一个可以工作的模块或页面。前端直接从服务器模块开始工作,前后端同学在开始工作前写好页面应该用的变量以及ajax通信的接口,随后独立开发,最后连调测试。这种开始方式,前端可以根据接口和数据结构来设计页面的html结构和css结构,把冗余工作降到最低。这样会让前端发挥更大的主观能动性,也可以让后台更加关注底层算法与数据存储与通信的逻辑。</p><h2 id="6-前端工程师的未来"><a href="#6-前端工程师的未来" class="headerlink" title="6.前端工程师的未来?"></a>6.前端工程师的未来?</h2><p>前端工程师一般由三条路可走,一条向前走,一条向后走,一条一直做前端,深入下去。向前就是向用户体验与交互设计甚至产品设计师上走,这最能体验前端价值,即用户体验。。向后走是做web开发,往数据库和后台开始方向走,不在区分前后端,大家深入产品的研发实现,这条路就是与软件工程师融合的路,这时的价值就体现在业务功能的实现上。最后就是一直深入做前端开发,对前端类库框架的架构设计,对浏览器原理的研究和js的研究,对网络传输协议原理分析等等，这条路因为要涉及很多原理与根本性的东西,走的人也不是很多。</p><p>前端的未来则是:有越来越多的软件开始在浏览器里运行,随着google和火狐的webos的发展,浏览器的api,会替代操作系统的sdk成为原件开发的标准。随着html5的发展,浏览器里运行的早不是简单的页面,而是复杂的web应用。前端工程师也早不是页面制作,而是erb应用工程师。在我看来,未来将会是手机端的时代。</p><p>若有收获，就点个赞吧</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2021/03/03/JS%E5%85%AD%E7%A7%8D%E7%BB%A7%E6%89%BF/"/>
    <url>/2021/03/03/JS%E5%85%AD%E7%A7%8D%E7%BB%A7%E6%89%BF/</url>
    
    <content type="html"><![CDATA[<h1 id="JS六种继承"><a href="#JS六种继承" class="headerlink" title="JS六种继承"></a>JS六种继承</h1><h2 id="1-原型链继承"><a href="#1-原型链继承" class="headerlink" title="1.原型链继承"></a>1.原型链继承</h2><p>function Father(name){  this.name = name; } function Son(name){  this.name = name; } Son.prototype = new Father(); </p><p>重点:让子类的原型等于父类的实例</p><p>特点:子类实例可以继承子类构造函数的属性,父类构造函数的属性,父类原型的属性。</p><p>缺点一:子类实例无法向父类构造函数传参。</p><p>缺点二:子类实例共享了父类构造函数的引用属性</p><h2 id="2-构造函数继承"><a href="#2-构造函数继承" class="headerlink" title="2.构造函数继承"></a>2.构造函数继承</h2><p>function Father(name){  this.name = name; } function Son(name){  this.name = name; Father.call(this); }</p><p>重点:在子类中利用call,apply方法引入父类构造函数。</p><p>特点:子类实例可以继承父类构造函数的属性,子类构造函数的属性,<strong>不会继承父类原型的属性。</strong></p><p>优点一:子类实例之间独立。</p><p>优点二:创建子类实例，可以向父类构造函数传参数。</p><p>优点三:子类实例不共享父类构造函数的引用属性。</p><p>缺点一:只能继承父类构造函数的属性。</p><p>缺点二:子类实例，继承不了父类原型上的属性。</p><h2 id="3-组合继承-组合原型链继承和借用构造函数继承"><a href="#3-组合继承-组合原型链继承和借用构造函数继承" class="headerlink" title="3,组合继承(组合原型链继承和借用构造函数继承)"></a>3,组合继承(组合原型链继承和借用构造函数继承)</h2><p>function Father(name){  this.name = name; } function Son(name){  this.name = name; Father.call(this); } Son.prototype = new Father();</p><p>重点：结合了两种模式的优点，传参和复用</p><p>优点一:可以向父类传参</p><p>优点二:父类的实例方法定义在父类的原型上,实现方法复用</p><p>优点三:子类实例相互独立</p><p>缺点：调用了两次父类构造函数（耗内存），子类的构造函数会代替原型上的那个父类构造函数。</p><p>第一次Son.call(this);从父类拷贝一份父类实例属性，作为子类的实例属性，</p><p>第二次Son.prototype = new Father();创建父类实例作为子类原型，此时这个父类实例就又有了一份实例属性，但这份会被第一次拷贝来的实例属性屏蔽掉，所以多余。</p><h2 id="4-原型继承"><a href="#4-原型继承" class="headerlink" title="4.原型继承"></a>4.原型继承</h2><p>重点:创建一个空对象,指定空对象的原型为object的参数。</p><p>缺点一:所有实例都会继承原型上的属性。</p><p>缺点二:无法实现复用。</p><h2 id="5-寄生继承"><a href="#5-寄生继承" class="headerlink" title="5.寄生继承"></a>5.寄生继承</h2><p>重点:就是给原型式继承外面套了个壳子</p><p>优点：没有创建自定义类型，因为只是套了个壳子返回对象（这个），这个函数顺理成章就成了创建的新对象</p><p>缺点：没用到原型，无法复用</p><h2 id="6-寄生组合式继承（常用）"><a href="#6-寄生组合式继承（常用）" class="headerlink" title="6.寄生组合式继承（常用）"></a>6.寄生组合式继承（常用）</h2><p>优缺点：这是一种完美的继承方式。</p><h2 id="7-ES6中的类与对象"><a href="#7-ES6中的类与对象" class="headerlink" title="7.ES6中的类与对象"></a>7.ES6中的类与对象</h2><p>类抽象了对象的公共部分,它泛指某一大类</p><p>对象特指某一个,通过类实例化一个具体的对象</p><p>面向对象的思维特点:</p><p>1.抽取(抽象)对象共用的属性和行为组织(封装)成一个类。</p><p>2.对类进行实例化,获取类的对象。</p><p>(1)通过class关键字创建类,类名我们还是习惯性定义首字母大写。</p><p>(2)类里面有个constructor函数,可以接受传递过来的参数,同时返回实例对象。</p><p>(3)constructor函数只要new生成实例时,就会自动调用这个函数,如果我们不写这个函数,类也回自动生成这个函数。</p><p>(4)生成实例new不能省略</p><p>(5)最后注意语法规范,创建类 类后面不要加小括号,生成实例 类名后面加小括号,构造函数不需要加function.</p><p>(6)我们类里面所有的函数不需要写function</p><p>(7)多个函数方法之间不需要添加逗号分隔</p><h4 id="创建类"><a href="#创建类" class="headerlink" title="创建类"></a>创建类</h4><h4 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h4><p>现实中的继承:子承父业,比如我们都继承了父亲的姓。</p><p>程序中的继承:子类可以继承父类的一些属性和方法</p><p>语法: 父类名 extends 子类名</p><p>super关键字用于访问和调用对象父类上的函数。</p><p>可以调用父类的构造函数,也可以调用父类的普通函数。</p><p>子类在构造函数中使用super,必须放到this前面(必须先调用父类的构造方法，在使用子类构造方法</p><p>)</p><h4 id="继承中属性或方法的查找原则"><a href="#继承中属性或方法的查找原则" class="headerlink" title="继承中属性或方法的查找原则"></a>继承中属性或方法的查找原则</h4><p>1.继承中,如果实例化子类,输出一个方法,先看子类有没有这个方法,如果有就先执行子类的。</p><p>2.继承中,如果子类 没有,就去查找父类有没有,如果有,就去执行父类的这个方法</p><p>super调用父类构造函数</p><p>super调用父类普通函数</p><p>我们可以用extends使得子类继承父类的属性和方法,但是想调用父类的参数,需要用到super方法。</p><h4 id="ES6中的类和对象三个注意点"><a href="#ES6中的类和对象三个注意点" class="headerlink" title="ES6中的类和对象三个注意点"></a>ES6中的类和对象三个注意点</h4><p>1.在ES6中没有变量提升,所以必须先定义类,才能通过类实例化对象。</p><p>2.类里面的共有的属性和方法一定要加this调用</p><p>3.constructor里面的this指向实例对象,方法里面的this指向这个方法的调用者</p><p>若有收获，就点个赞吧</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2021/03/03/%E5%88%9D%E5%A7%8BPromise/"/>
    <url>/2021/03/03/%E5%88%9D%E5%A7%8BPromise/</url>
    
    <content type="html"><![CDATA[<h1 id="初识Promise"><a href="#初识Promise" class="headerlink" title="初识Promise"></a>初识Promise</h1><p>Promise 是异步编程的一种解决方案，其实是一个构造函数，自己身上有all、reject、resolve这几个方法，原型上有then、catch等方法。</p><p>Promise 用于避免回调地域，让代码看起来更同步</p><p>Promise对象有两个特点</p><p>（1）对象的状态不受外界影响。只有异步操作的结果，可以决定当前是哪一种状态(进行中,已成功,已失败)中的一种。</p><p>（2）一旦状态改变，就不会再变。Promise对象的状态改变，只有两种可能：从执行中变为已成功和从执行中变为已失败。</p><p>创建一个Promise对象</p><p>function fn(){  return new Promise((resolve, reject)=&gt;{ 成功时调用 resolve(data) 失败时调用 reject(reason) }) }</p><p>resolve 对Peomise成功的回调</p><p>reject 对Peomise失败的回调<br>then方法可以接受两个参数，第一个对应resolve的回调，第二个对应reject的回调。</p><p>  function promiseClick(){  let p = new Promise(function(resolve, reject){ setTimeout(function(){ var num = Math.ceil(Math.random()*20); //生成1-10的随机数 console.log(‘随机数生成的值：’,num) if(num&lt;=10){ resolve(num); } else{ reject(‘数字太于10了即将执行失败回调’); } }, 2000); }) return p }  promiseClick().then( function(data){ console.log(‘resolved成功回调’); console.log(‘成功回调接受的值：’,data); }, function(reason){ console.log(‘rejected失败回调’); console.log(‘失败执行回调抛出失败原因：’,reason); } );</p><p>catch就是用来捕获异常的，也就是和then方法中接受的第二参数rejected的回调是一样的</p><p>function promiseClick(){  let p = new Promise(function(resolve, reject){ setTimeout(function(){ var num = Math.ceil(Math.random()*20); //生成1-10的随机数 console.log(‘随机数生成的值：’,num) if(num&lt;=10){ resolve(num); } else{ reject(‘数字太于10了即将执行失败回调’); } }, 2000); }) return p }  promiseClick().then( function(data){ console.log(‘resolved成功回调’); console.log(‘成功回调接受的值：’,data); } ) .catch(function(reason, data){ console.log(‘catch到rejected失败回调’); console.log(‘catch失败执行回调抛出失败原因：’,reason); });</p><p>all方法，该方法提供了并行执行异步操作的能力，并且在所有异步操作执行完后并且执行结果都是成功的时候才执行回调。</p><p>Promise.all可以将多个Promise实例包装成一个新的Promise实例。同时，成功和失败的返回值是不同的，成功的时候返回的是一个结果数组，而失败的时候则返回最先被reject失败状态的值。</p><p>需要特别注意的是，Promise.all获得的成功结果的数组里面的数据顺序和Promise.all接收到的数组顺序是一致的，即p1的结果在前，即便p1的结果获取的比p2要晚。这带来了一个绝大的好处：在前端开发请求数据的过程中，偶尔会遇到发送多个请求并根据请求顺序获取和使用数据的场景，使用Promise.all毫无疑问可以解决这个问题</p><p>Promse.race就是赛跑的意思，意思就是说，Promise.race([p1, p2, p3])里面哪个结果获得的快，就返回那个结果，不管结果本身是成功状态还是失败状态。</p><p>若有收获，就点个赞吧</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2021/03/03/%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D(4%E9%92%9F%E6%96%B9%E6%B3%95)/"/>
    <url>/2021/03/03/%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D(4%E9%92%9F%E6%96%B9%E6%B3%95)/</url>
    
    <content type="html"><![CDATA[<h1 id="数组去重-4种方法"><a href="#数组去重-4种方法" class="headerlink" title="数组去重(4种方法)"></a>数组去重(4种方法)</h1><h2 id="一-利用Map数据结构去重"><a href="#一-利用Map数据结构去重" class="headerlink" title="一.利用Map数据结构去重"></a>一.利用Map数据结构去重</h2><blockquote><p>去重前：[ 1, 1, 2, 2, 3, 4, 4, 5 ]</p><p>去重后：[ 1, 2, 3, 4, 5 ]</p></blockquote><p>主要思路：</p><p>创建一个空Map，遍历原始数组，把数组的每一个元素作为key存到Map中，因为Map中不会出现相同的key值，所以最终得到的Map中的所有key值就是去重后的结果.</p><p>代码</p><p>function arrayNonRepeatfy(arr){  let hashMap = new Map(); let array = new Array(); // 数组用于返回结果 for(let i = 0; i &lt; arr.length; i++){ if(hashMap.has(arr[i])){ // 判断 hashMap 中是否已有该 key 值 hashMap.set(arr[i],true);// 后面的true 代表该 key 值在原始数组中重复了，false反之 } else {    // 如果 hashMap 中没有该 key 值，添加 hashMap.set(arr[i],true); array.push(arr[i]) } } return array; }</p><p>优点:显而易见得是，代码较为复杂，</p><p>缺点:需要使用临时的空间，Map 数据结构，存储中间结果</p><p>参考:<a href="https://segmentfault.com/a/1190000015923301">数组去重-Map实现</a></p><h2 id="二、利用ES6-Set去重（ES6中最常用）"><a href="#二、利用ES6-Set去重（ES6中最常用）" class="headerlink" title="二、利用ES6 Set去重（ES6中最常用）"></a>二、利用ES6 Set去重（ES6中最常用）</h2><p>function unique(arr){  return […new Set(arr)]; } 或者 function unique(arr){  return Array.from(new Set(arr)); }</p><p>优点:不考虑兼容性，这种去重的方法代码最少。</p><p>缺点:这种方法还无法去掉“{}”空对象。</p><h2 id="三、利用for嵌套for，然后splice去重（ES5中最常用）"><a href="#三、利用for嵌套for，然后splice去重（ES5中最常用）" class="headerlink" title="三、利用for嵌套for，然后splice去重（ES5中最常用）"></a>三、利用for嵌套for，然后splice去重（ES5中最常用）</h2><p>function unique(arr){  for(let i = 0; i &lt; arr.length; i++){ for(let j=i+1; j &lt; arr.length; j++){ if(arr[i]===arr[j]){ arr.splice(j,1); //第一个等同于第二个，splice方法删除第二个 j--; } } } return arr; }</p><p>双层循环，外层循环元素，内层循环时比较值。值相同时，则删去这个值</p><p>优点:好理解。</p><p>缺点:事件复杂度,效率低。</p><h2 id="四、利用indexOf去重"><a href="#四、利用indexOf去重" class="headerlink" title="四、利用indexOf去重"></a>四、利用indexOf去重</h2><p>新建一个空的结果数组，for 循环原数组，判断结果数组是否存在当前元素，如果有相同的值则跳过，不相同则push进数组。</p><p>若有收获，就点个赞吧</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2021/03/03/call,apply,bind%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2021/03/03/call,apply,bind%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h1 id="call-apply-bind的区别"><a href="#call-apply-bind的区别" class="headerlink" title="call,apply,bind的区别"></a>call,apply,bind的区别</h1><p>在JS中,这三者都是用来改变this指向的</p><p>三者的相似之处:</p><p>1.都是用来改变this指向的</p><p>2.第一个参数都是this要指向的对象</p><p>3.都可以利用后续参数传参</p><p>那么它们的区别在哪里呢?</p><p>先看一个例子</p><p> var xw = { name : “小王”, gender : “男”, age : 24, say : function() { alert(this.name + “ , “ + this.gender + “ ,今年” + this.age); } } var xh = { name : “小红”, gender : “女”, age : 18 } xw.say();</p><p>毫无疑问,当JS执行第14行时,页面弹出的肯定是 <strong>小王,男,今年24岁。</strong></p><p>但是如果我想现在想让xh也可以调用say()函数。</p><p>对于call可以这样做</p><p>xw.say.call(xh)；</p><p>对于apply可以这样做</p><p>xw.say.call(xh);</p><p>对于bind可以这样做</p><p>xw.say.bind(xh)()</p><p>如果直接写xw.say.bind(xh)不会有任何结果的。</p><p>我们可以发现,<strong>call和apply是对函数的直接调用,而bind方法返回的是一个改变了this指向的函数。</strong></p><p>那么call,apply有什么区别呢</p><p> var xw = { name : “小王”, gender : “男”, age : 24, say : function(school,grade) { alert(this.name + “ , “ + this.gender + “ ,今年” + this.age + “ ,在” + school + “上” + grade); } } var xh = { name : “小红”, gender : “女”, age : 18 } xw.say();</p><p>可以看到say函数多了两个参数</p><p>我们通过call,apply的参数传参</p><p>对于call来说是这样的</p><p>xw.say.call(xh,”实验小学”,”六年级”)</p><p>对于apply来说是这样的</p><p>xw.say.call(xh,[“实验小学”,”六年级”])</p><p>看到区别了吗，call后面的参数与say方法中是一一对应的，而apply的第二个参数是一个数组，数组中的元素是和say方法中一一对应的，这就是两者最大的区别。</p><p>那么bind如何传参呢</p><p>xw.say.bind(xh,”实验小学”,”六年级”)</p><p>由于bind返回的还是一个函数,所以也可以这样传参</p><p>xw.say.bind(xh)(“实验小学”,”六年级”)</p><p>总结:</p><p>call,apply的区别在于,传参的形式不同,前者直接传参,后者通过数组传参</p><p>call,apply和bind的区别在于调用函数的时机不同,前面两个立即调用,后者返回一个函数,在你需要的时候调用。</p><p>若有收获，就点个赞吧</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2021/03/03/Parcel%E4%B9%8Bbuild%E6%96%B9%E6%B3%95/"/>
    <url>/2021/03/03/Parcel%E4%B9%8Bbuild%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="Parcel之build方法"><a href="#Parcel之build方法" class="headerlink" title="Parcel之build方法"></a>Parcel之build方法</h1><h2 id="build是什么"><a href="#build是什么" class="headerlink" title="build是什么"></a>build是什么</h2><h2 id="build的作用"><a href="#build的作用" class="headerlink" title="build的作用"></a>build的作用</h2><h3 id="如何进行build"><a href="#如何进行build" class="headerlink" title="如何进行build"></a>如何进行build</h3><blockquote><p>step1</p></blockquote><p>首先清空dist文件夹</p><p>rm -rf dist</p><blockquote><p>step2</p></blockquote><p>方法一:parcel build <strong>路径(文件夹)/文件</strong> –no-minify –pubilc-url <strong>相对路径</strong></p><p>parcel build src/index.html –no-minify –public-url ./</p><p>方法二:parcel build <strong>路径(文件夹)/文件</strong> –no-minify –pubilc-url <strong>github绝对路径</strong></p><p>parcel build src/index.html –no-minify –pubilc-url <a href="https://frankfang.github.io/nav-1/dist">https://frankfang.github.io/nav-1/dist</a></p><blockquote><p>step3</p></blockquote><ul><li><p>  查看build中dist中的index.html文件，查看路径是否正确</p></li><li><p>路径前面不能存在./</p><p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/1554318/1608729138234-49cea8b1-3aa0-43eb-be01-411046f3fc54.jpeg"> </p></li></ul><blockquote><p>step4</p></blockquote><p>git操作(不清楚的小伙伴请查看我的之前的文章)</p><p><strong>注意：进行到git init即可，先不要提交</strong></p><blockquote><p>step5（视情况操作:如果存在多余文件）</p></blockquote><ul><li><p>  根目录创建.gitignore文件</p></li><li><p>并写入以下文件</p><p><img src="https://cdn.nlark.com/yuque/0/2020/jpg/1554318/1608729138256-fe518581-e240-4497-b5f0-cf260b490c80.jpg"> 隐藏文件（不进行提交）</p></li></ul><blockquote><p>step6</p></blockquote><p><strong>本地git仓库操作：</strong></p><p>操作添加-提交-查看</p><p>git add . git commit -m “版本号/描述” git status</p><blockquote><p>step7</p></blockquote><p><strong>远程git仓库操作 ：</strong></p><p>建立联系-推送到远程git仓库</p><blockquote><p>git remote add origin <a href="mailto:&#x67;&#105;&#116;&#64;&#x67;&#x69;&#116;&#x68;&#117;&#x62;&#46;&#99;&#111;&#x6d;">&#x67;&#105;&#116;&#64;&#x67;&#x69;&#116;&#x68;&#117;&#x62;&#46;&#99;&#111;&#x6d;</a>：用户名/ 远程仓库git push -u origin master</p></blockquote><p>git remote add origin <a href="mailto:&#103;&#105;&#x74;&#64;&#103;&#105;&#116;&#104;&#x75;&#x62;&#46;&#x63;&#x6f;&#x6d;">&#103;&#105;&#x74;&#64;&#103;&#105;&#116;&#104;&#x75;&#x62;&#46;&#x63;&#x6f;&#x6d;</a>：Xinjn / static-server.git  git push -u origin master</p><h2 id="封装build"><a href="#封装build" class="headerlink" title="封装build"></a>封装build</h2><p>yarn build一键发布</p><blockquote><p>step1</p></blockquote><ul><li>  如果存在package.json文件，直接跳过看step2</li><li>  如果不存在通过代码新建package.json文件</li></ul><blockquote><p>step2</p></blockquote><p>在package.json开头写入</p><blockquote><p>step3</p></blockquote><p>完成！！一键build</p><p>若有收获，就点个赞吧</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2021/03/03/%E6%89%8B%E5%86%99JSONP/"/>
    <url>/2021/03/03/%E6%89%8B%E5%86%99JSONP/</url>
    
    <content type="html"><![CDATA[<h1 id="手写JSONP"><a href="#手写JSONP" class="headerlink" title="手写JSONP"></a>手写JSONP</h1><p>function jsonp(url) {  return new Promise((resolve,reject) =&gt; { const random = Math.random(); window[random] = (data) =&gt; { resolve(data); } const script = document.createElement(“script”); script.src = `${url}?callback=${random}`; document.body.appendChild(script); script.onload = () =&gt; { script.remove(); } script.onerror = () =&gt; { reject(); } }) }   jsonp(“http:localhost:8888/friends.js”).then((data)=&gt;{  console.log(data) })</p><p>若有收获，就点个赞吧</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2021/03/03/%E5%88%9D%E5%A7%8Baxios/"/>
    <url>/2021/03/03/%E5%88%9D%E5%A7%8Baxios/</url>
    
    <content type="html"><![CDATA[<h1 id="初识AXIOS"><a href="#初识AXIOS" class="headerlink" title="初识AXIOS"></a>初识AXIOS</h1><p>axios 目前最新的AJAX库。</p><p>axios发送get请求</p><p>GET请求</p><p>带查询参数</p><p>axios.get(‘/user?ID=12345’)  .then(function (response) { console.log(response); }) .catch(function (error) { console.log(error); });</p><p>查询参数(可选)</p><p>axios.get(‘/user’, {  params: { ID: 12345 } }) .then(function (response) { console.log(response); }) .catch(function (error) { console.log(error); });</p><p>axios({  method: ‘get’, url: ‘<a href="http://bit.ly/2mTM3nY&#39;">http://bit.ly/2mTM3nY&#39;</a>, responseType: ‘stream’ })  .then(function(response) { response.data.pipe(fs.createWriteStream(‘ada_lovelace.jpg’)) });</p><p>POST请求</p><p>axios.post(‘/user’, {  firstName: ‘Fred’, lastName: ‘Flintstone’ }) .then(function (response) { console.log(response); }) .catch(function (error) { console.log(error); });  发送一个POST请求 axios({  method: ‘post’, url: ‘/user/12345’, data: { firstName: ‘Fred’, lastName: ‘Flintstone’ } });</p><p>若有收获，就点个赞吧</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2021/03/03/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/"/>
    <url>/2021/03/03/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="异步编程与回调"><a href="#异步编程与回调" class="headerlink" title="异步编程与回调"></a>异步编程与回调</h1><h2 id="异步模式与同步模式"><a href="#异步模式与同步模式" class="headerlink" title="异步模式与同步模式"></a>异步模式与同步模式</h2><p>“同步模式”就是后一个任务等待前一个任务结束，然后再执行，程序的执行顺序与任务的排列顺序是一致的、同步的。</p><p>“异步模式”则完全不同，每一个任务有一个或多个回调函数（callback），前一个任务结束后，不是执行后一个任务，而是执行回调函数，后一个任务则是不等前一个任务结束就执行，所以程序的执行顺序与任务的排列顺序是不一致的、异步的。</p><h2 id="回调callback"><a href="#回调callback" class="headerlink" title="回调callback"></a>回调callback</h2><p>回调函数就是传递一个参数化的函数，就是将这个函数作为一个参数传到另一个主函数里面，当那一个主函数执行完之后，再执行传进去的作为参数的函数。走这个过程的参数化的函数 就叫做回调函数。换个说法也就是<strong>被作为参数传递到另一个函数（主函数）的那个函数</strong>就叫做 <strong>回调函数</strong>。</p><h2 id="异步任务"><a href="#异步任务" class="headerlink" title="异步任务"></a>异步任务</h2><p>如果一个函数的返回值处于</p><p>setTimeOut</p><p>AJAX</p><p>AddEventListener</p><p>这三个东西内部,那么这个函数就是异步函数。</p><h2 id="异步任务与回调的关系"><a href="#异步任务与回调的关系" class="headerlink" title="异步任务与回调的关系"></a>异步任务与回调的关系</h2><p>异步任务无法直接拿到结果</p><p>于是我们传一个回调给异步任务</p><p>异步任务完成时调用回调</p><p>调用的时候把结果作为参数</p><h2 id="Promises对象"><a href="#Promises对象" class="headerlink" title="Promises对象"></a>Promises对象</h2><p>Promises对象是CommonJS工作组提出的一种规范，目的是为异步编程提供<a href="http://wiki.commonjs.org/wiki/Promises/A">统一接口</a>。</p><p>简单说，它的思想是，每一个异步任务返回一个Promise对象，该对象有一个then方法，允许指定回调函数。比如，f1的回调函数f2,可以写成：</p><p>f1().then(f2);</p><p>Promises的优点</p><p>规范回调的名字或顺序</p><p>拒绝回调地狱,让代码可读性更强</p><p>很方便地捕获错误</p><p>1 人点赞</p><ul><li>  <img src="https://gw.alipayobjects.com/zos/rmsportal/wYnHWSXDmBhiEmuwXsym.png?x-oss-process=image/resize,m_fill,w_64,h_64/format,png" alt="彭一多"></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2021/03/03/%E6%89%8B%E5%86%99AJAX/"/>
    <url>/2021/03/03/%E6%89%8B%E5%86%99AJAX/</url>
    
    <content type="html"><![CDATA[<h1 id="手写AJAX"><a href="#手写AJAX" class="headerlink" title="手写AJAX"></a>手写AJAX</h1><p>function ajax(url, method) {  return new Promise((resolve, reject) =&gt; { const request = new XMLHttpRequest() request.open(url, method) request.onreadystatechange = function () { if (request.readyState === 4) { if (request.status === 200) { resolve(request.responseText) } else if (request.status === 404) { reject(new Error(‘404’)) } } else { reject(‘请求数据失败’) } } request.send(null) }) } </p><p>若有收获，就点个赞吧</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2021/03/03/%E8%B7%A8%E5%9F%9F,CROS,JSONP/"/>
    <url>/2021/03/03/%E8%B7%A8%E5%9F%9F,CROS,JSONP/</url>
    
    <content type="html"><![CDATA[<h1 id="跨域-CORS-JSONP"><a href="#跨域-CORS-JSONP" class="headerlink" title="跨域,CORS,JSONP"></a>跨域,CORS,JSONP</h1><h1 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h1><p>源的定义</p><p>window.origin或locati.origin可以得到当前源</p><p>源 = 协议 + 域名 +端口号</p><p>如果两个url的</p><ul><li>  协议</li><li>  域名</li><li>  端口号</li></ul><p>完全一致,那么这两个url就是同源的。</p><p>举例</p><p>https：//qq.com,https：//<a href="http://www.baidu.com不同源/">www.baidu.com不同源</a></p><p>http：//baidu.com,https：//<a href="http://www.baidu.com不同源/">www.baidu.com不同源</a></p><p>完全一致才算同源</p><p>同源策略</p><p>js只能从其运行的源中获取数据,不能获取别的源的数据,这就叫同源策略。</p><p>同源策略：不同源的页面之间,不准互相访问数据。</p><p>其目的是为了保护用户隐私。</p><h1 id="跨域的方法–CORS"><a href="#跨域的方法–CORS" class="headerlink" title="跨域的方法–CORS"></a>跨域的方法–CORS</h1><p>问题根源</p><p>浏览器默认不同源之前互相访问数据</p><p>但是如果我们必须要让两个网站之间互相访问,也是有解决方法的。</p><p>第一个方法就是CORS</p><p>如果要共享数据,我们需要在被分享出去的数据中加一条声明：</p><p>Access-Control-Allow-Origin：  允许访问的网站</p><h1 id="跨域的方法–JSONP"><a href="#跨域的方法–JSONP" class="headerlink" title="跨域的方法–JSONP"></a>跨域的方法–JSONP</h1><p>我们在跨域的时候由于当前浏览器不支持CORS,或其他原因不支持CORS,于是我们就请求一个JS文件, 这个JS文件会执行一个回调,回调里面有我们想要的数据,回调的名字是可以随机生成的一个随机数,我们把这个名字以callback的参数传给后台,后台会把这个callback返回给我们并执行。</p><h1 id="跨域过程测试"><a href="#跨域过程测试" class="headerlink" title="跨域过程测试"></a>跨域过程测试</h1><p>以下是我测试这两种跨域方法的过程</p><p>首先我在VScode中模拟两个网站：</p><p>pengpeng.com端口号为8888,qq.com端口号为8889。</p><p> <img src="https%EF%BC%9A//cdn.nlark.com/yuque/0/2020/png/1554318/1608650820458-79d3c3eb-2736-4a1c-8457-631dfd2014e8.png" alt="Snipaste_2020-12-22_23-26-27.png" title="Snipaste_2020-12-22_23-26-27.png"> </p><p>pengpeng.com</p><p>public</p><p>5</p><p>index.html</p><p>JS</p><p>pengpengj</p><p>JS</p><p>serverjs</p><p>qq.com</p><p>public</p><p>JSfriendsjs</p><p>I</p><p>friendsjson</p><p>5</p><p>index.html</p><p>JS</p><p>qqjs</p><p>JS</p><p>serverjs</p><p>我假设qq.com是qq官方的网站,里面存着许多用户的数据。</p><p>pengpeng.com是黑客的钓鱼网站。</p><p>然后这两个网站分别放着一个server.js服务器。</p><p>我们先测试同源访问,通过qq.js访问friends.json里面的数据</p><p> <img src="https%EF%BC%9A//cdn.nlark.com/yuque/0/2020/png/1554318/1608651332833-26001e3a-d0fb-4a0f-8916-2e9fa00d74ca.png" alt="3.png" title="3.png"> </p><p>localhost：8889/friendsjson</p><p>[查缺补漏|我的2…</p><p>第十一天/素材/品…</p><p>翻译</p><p>应用</p><p>2019年最全最新Vu…</p><p>104道</p><p>吴彦祖”,</p><p>name</p><p>刘德华”</p><p>name</p><p>成功访问</p><p>我们再跨域访问,通过pengpeng.js访问friends.json里面的数据</p><p> <img src="https%EF%BC%9A//cdn.nlark.com/yuque/0/2020/png/1554318/1608651610800-ea779df9-a17a-4a89-8c87-82b822c0a7e9.png" alt="4.png" title="4.png"> </p><p>index.htm1：1</p><p>AccesstoXMLHtpRequestathttp：//ocalhost/rindfm</p><p>biockedbyCORS</p><p>policy：NoAccess-Contro1-</p><p>http：//1ocalhost：8888hasbeenboc</p><p>origin</p><p>A11ow-Origin</p><p>header</p><p>presentontherequested</p><p>resource.</p><p>失败,报错,不能跨域访问数据。</p><h2 id="CORS实现跨域"><a href="#CORS实现跨域" class="headerlink" title="CORS实现跨域"></a>CORS实现跨域</h2><p>为了解决这个问题,在qq.com的服务器中的friends.json中加一条声明</p><p>Access-Control-Allow-Origin： 允许访问的源。</p><p> <img src="https%EF%BC%9A//cdn.nlark.com/yuque/0/2020/png/1554318/1608651941660-d46ba099-bd74-47ed-9f5e-249dd15a5a45.png" alt="5.png" title="5.png"> </p><p>iseif(path–E”/friends.json”)</p><p>200</p><p>response.statuscode</p><p>(‘Content-Type’’text/json;charset-utf-8);</p><p>response.setHeader’co</p><p>“http：//1ocahost：8888”);</p><p>SetHeader(“Access-Control-A11ow-origin”</p><p>response</p><p>response.Write(fs.readFilesync/ubic/friend.”</p><p>response.end)</p><p>这样,pengpeng.com就可以访问qq.com中friends.json的数据了。</p><h2 id="JSONP实现跨域"><a href="#JSONP实现跨域" class="headerlink" title="JSONP实现跨域"></a>JSONP实现跨域</h2><p>我们假如要兼容IE6,7,8,9时,CORS不被兼容,这个时候我们需要通过JSONP来解决</p><p>思路：</p><p>因为JS文件是可以引用的,而例如json等文件是不可以被访问的。</p><p>我们可以通过引用JS文件的形式来间接的访问我们所需的数据。</p><p>前提是我们得将我们需要的数据通过后台,放到一个JS文件中。</p><p>使用JSONP方法在pengpeng.com向qq.com访问friends.json文件数据模拟过程如下</p><p>在pengpeng.com下的pengpeng.js中创建一个script标签并放到body里面进行引用.  </p><p> <img src="https%EF%BC%9A//cdn.nlark.com/yuque/0/2020/png/1554318/1608710065504-8039b968-b3c9-497e-a74f-465b4f42cd87.png" alt="2.png" title="2.png"> </p><p>script</p><p>document.createelement(“script”</p><p>const</p><p>“http：//1ocaihost：8889/friends.j”;</p><p>script.src</p><p>document.body.appendchild(script);</p><p>这个script的src为qq.com中的qq.js</p><p>当访问qq.js时,qq.com的服务器会将friends.json中的数据渲染到qq.js中。</p><p> <img src="https%EF%BC%9A//cdn.nlark.com/yuque/0/2020/png/1554318/1608710107045-896be5f2-40bf-4f5a-81bc-379591fefedc.png" alt="3.png" title="3.png"> </p><p>window.xxx(tdata]]</p><p> <img src="https%EF%BC%9A//cdn.nlark.com/yuque/0/2020/png/1554318/1608710141371-1bfdca87-bf71-45dd-a72e-ad7e74e88e72.png" alt="4.png" title="4.png"> </p><p>e1seif(path—“/friends.js</p><p>response.statuscode-200;</p><p>response.setHeader(content-Type,text/javascriptcharset-ut8)</p><p>conststring二fsreadFilesync./pulic/friend”.</p><p>constdatafsreadFilesyncu</p><p>string.replace(“databb”,data);</p><p>const</p><p>string2</p><p>response.write(string2)</p><p>O);</p><p>response.end</p><p>这样,我们就间接的得到了qq.com中的friends.json中的数据。</p><p> <img src="https%EF%BC%9A//cdn.nlark.com/yuque/0/2020/png/1554318/1608710174916-988f5b1b-3a73-4c5c-bb51-bece97b7c32e.png" alt="5.png" title="5.png"> </p><p>Timing</p><p>Response</p><p>Headers</p><p>Initiator</p><p>Preview</p><p>Name</p><p>“吴彦祖”,tname：”刘德华”]]);</p><p>index.html</p><p>window.XXX(Cin</p><p>iname：</p><p>0：fname：”吴彦祖”</p><p>pengpengjs</p><p>1：tname：”刘德华”]</p><p>friendsjs</p><h3 id="JSONP优化一"><a href="#JSONP优化一" class="headerlink" title="JSONP优化一"></a>JSONP优化一</h3><p>当前的JSONP无法识别访问者的身份</p><p>解决方法：利用requesr.heads[“referer”]识别</p><p> <img src="https%EF%BC%9A//cdn.nlark.com/yuque/0/2020/png/1554318/1608710763529-f463d241-1099-45fa-99f2-e8ce19d79ca4.png" alt="11.png" title="11.png"> </p><p>“/friends.</p><p>if</p><p>else</p><p>path</p><p>if</p><p>request.headerst”referer”j.indexof(Chttp：//localhost：8)</p><p>response.statuscode-200;</p><p>response.setHeader(‘Content-Type</p><p>‘text/javascript;charset-utf-8”)</p><p>c(“./public/friends.js”)tostring);</p><p>conststringfs.readfilesync(“</p><p>fs.readFilesync(./public/friends.json”).ing</p><p>constdata</p><p>string.rep1ace(“databb”,data);</p><p>string2</p><p>const</p><p>response.write(string2)</p><p>response.end();</p><p>4</p><p>else</p><p>response.statuscode-404;</p><p>response.end</p><p>当请求头包含”http：//localhost：8888”时,运行访问,否则不允许。</p><p> <img src="https%EF%BC%9A//cdn.nlark.com/yuque/0/2020/png/1554318/1608710804026-9095d2c9-4164-4fc1-b0f1-1fa8abbe99ce.png?x-oss-process=image/resize,w_1150" alt="6.png" title="6.png"> </p><p>localhost：8888/index.html</p><p>第I一天/索材/品…2019年最全最新Vu…</p><p>[查缺补玩)我的2….</p><p>ES6入门叔星</p><p>其他书签</p><p>从零玩转jQuery原…</p><p>104JCSS面试题…</p><p>应用</p><p>刮译</p><p>Console</p><p>Sources</p><p>Performance</p><p>Network</p><p>Application</p><p>Memory</p><p>Elements</p><p>我是黑客</p><p>O</p><p>了</p><p>Disablecache</p><p>Online</p><p>Search</p><p>Preservelog</p><p>CeFiIter</p><p>HidedataURLs</p><p>xHRJScSSlmg</p><p>HasblockedcookiesOBlockedRequests</p><p>MediaFontDocwsManifestOther</p><p>Groupbyframe</p><p>Uselargereguestrows</p><p>Showoverview</p><p>Capturescreenshots</p><p>50ms</p><p>100ms</p><p>150ms</p><p>ResponselnitiatorTiming</p><p>Preview</p><p>Headers</p><p>Name</p><p>window.xxx([iiname：”吴”.name：”刘德华”]]);</p><p>index.html</p><p>B：iname：”吴产和”</p><p>pengpengJs</p><p>1：tname：”刘德华”]</p><p>friends.js</p><p>1.0kBtransferred</p><p>3requests</p><h3 id="JSONP优化二"><a href="#JSONP优化二" class="headerlink" title="JSONP优化二"></a>JSONP优化二</h3><p>当前只能获取到friends.json里面的数据,如果需要访问很多借口,一个xxx函数显然无法满足我们的需求。</p><p>思路：</p><p>创建一个随机数来代替xxx,然后将此随机数作为查询参数传递给qq.com后台。</p><p> <img src="https%EF%BC%9A//cdn.nlark.com/yuque/0/2020/png/1554318/1608712555607-bf5b58cd-ed1c-4731-93ab-12dcee0dbd85.png" alt="22.png" title="22.png"> </p><p>Math.random(</p><p>random</p><p>const</p><p>window[random]-(data)-&gt;f</p><p>conso1e.g(data);</p><p>Constsciptdocument.createlement”scrit”;</p><p>script.src</p><p>http：//1ocalhost：8889/friends.jackraom</p><p>y.appendchild(script);</p><p>document.body.a</p><p>qq.com后台再用此随机数代替qq.js中的xxx。</p><p> <img src="https%EF%BC%9A//cdn.nlark.com/yuque/0/2020/png/1554318/1608712687080-ee68811d-d925-4953-b54f-7de8a3df567f.png" alt="333.png" title="333.png"> </p><p>window[“txxx”(data</p><p> <img src="https%EF%BC%9A//cdn.nlark.com/yuque/0/2020/png/1554318/1608712733522-9dc8e98e-9ba2-43f2-b374-a3dd5f26a5f7.png" alt="444.png" title="444.png"> </p><p>rerJ.indexof(http：//localhost：8888</p><p>(reguest.headersL’referer</p><p>200;</p><p>response.statuscode</p><p>response.setHeader(content-Type,text/javascript;charset-utf8)</p><p>CONSTStrIngfSrEAdFIeSync.u/riend.</p><p>constdata二fs.readilesyncuini</p><p>cal1back)</p><p>ONSTSTRINGSTRINB.PLAcEC”TDTAP”DaTA).rePLace(TXCLY.</p><p>response.write(string2)</p><p>responsenend();</p><p>else</p><p>response.statuscode-404;</p><p>response,end();</p><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="JSONP相对于AJAX的优点"><a href="#JSONP相对于AJAX的优点" class="headerlink" title="JSONP相对于AJAX的优点"></a>JSONP相对于AJAX的优点</h3><p>兼容IE</p><p>可以跨域</p><h3 id="-1"><a href="#-1" class="headerlink" title=""></a></h3><h3 id="JSONP缺点"><a href="#JSONP缺点" class="headerlink" title="JSONP缺点"></a>JSONP缺点</h3><p>由于它是script标签,拿不到状态码</p><p>只能发get请求,不支持post。</p><p>若有收获，就点个赞吧</p><h1 id="跨域-CORS-JSONP-1"><a href="#跨域-CORS-JSONP-1" class="headerlink" title="跨域,CORS,JSONP"></a>跨域,CORS,JSONP</h1><h1 id="同源策略-1"><a href="#同源策略-1" class="headerlink" title="同源策略"></a>同源策略</h1><p>源的定义</p><p>window.origin或locati.origin可以得到当前源</p><p>源 = 协议 + 域名 +端口号</p><p>如果两个url的</p><ul><li>  协议</li><li>  域名</li><li>  端口号</li></ul><p>完全一致,那么这两个url就是同源的。</p><p>举例</p><p>https：//qq.com,https：//<a href="http://www.baidu.com不同源/">www.baidu.com不同源</a></p><p>http：//baidu.com,https：//<a href="http://www.baidu.com不同源/">www.baidu.com不同源</a></p><p>完全一致才算同源</p><p>同源策略</p><p>js只能从其运行的源中获取数据,不能获取别的源的数据,这就叫同源策略。</p><p>同源策略：不同源的页面之间,不准互相访问数据。</p><p>其目的是为了保护用户隐私。</p><h1 id="跨域的方法–CORS-1"><a href="#跨域的方法–CORS-1" class="headerlink" title="跨域的方法–CORS"></a>跨域的方法–CORS</h1><p>问题根源</p><p>浏览器默认不同源之前互相访问数据</p><p>但是如果我们必须要让两个网站之间互相访问,也是有解决方法的。</p><p>第一个方法就是CORS</p><p>如果要共享数据,我们需要在被分享出去的数据中加一条声明：</p><p>Access-Control-Allow-Origin：  允许访问的网站</p><h1 id="跨域的方法–JSONP-1"><a href="#跨域的方法–JSONP-1" class="headerlink" title="跨域的方法–JSONP"></a>跨域的方法–JSONP</h1><p>我们在跨域的时候由于当前浏览器不支持CORS,或其他原因不支持CORS,于是我们就请求一个JS文件, 这个JS文件会执行一个回调,回调里面有我们想要的数据,回调的名字是可以随机生成的一个随机数,我们把这个名字以callback的参数传给后台,后台会把这个callback返回给我们并执行。</p><h1 id="跨域过程测试-1"><a href="#跨域过程测试-1" class="headerlink" title="跨域过程测试"></a>跨域过程测试</h1><p>以下是我测试这两种跨域方法的过程</p><p>首先我在VScode中模拟两个网站：</p><p>pengpeng.com端口号为8888,qq.com端口号为8889。</p><p> <img src="https%EF%BC%9A//cdn.nlark.com/yuque/0/2020/png/1554318/1608650820458-79d3c3eb-2736-4a1c-8457-631dfd2014e8.png" alt="Snipaste_2020-12-22_23-26-27.png" title="Snipaste_2020-12-22_23-26-27.png"> </p><p>pengpeng.com</p><p>public</p><p>5</p><p>index.html</p><p>JS</p><p>pengpengj</p><p>JS</p><p>serverjs</p><p>qq.com</p><p>public</p><p>JSfriendsjs</p><p>I</p><p>friendsjson</p><p>5</p><p>index.html</p><p>JS</p><p>qqjs</p><p>JS</p><p>serverjs</p><p>我假设qq.com是qq官方的网站,里面存着许多用户的数据。</p><p>pengpeng.com是黑客的钓鱼网站。</p><p>然后这两个网站分别放着一个server.js服务器。</p><p>我们先测试同源访问,通过qq.js访问friends.json里面的数据</p><p> <img src="https%EF%BC%9A//cdn.nlark.com/yuque/0/2020/png/1554318/1608651332833-26001e3a-d0fb-4a0f-8916-2e9fa00d74ca.png" alt="3.png" title="3.png"> </p><p>localhost：8889/friendsjson</p><p>[查缺补漏|我的2…</p><p>第十一天/素材/品…</p><p>翻译</p><p>应用</p><p>2019年最全最新Vu…</p><p>104道</p><p>吴彦祖”,</p><p>name</p><p>刘德华”</p><p>name</p><p>成功访问</p><p>我们再跨域访问,通过pengpeng.js访问friends.json里面的数据</p><p> <img src="https%EF%BC%9A//cdn.nlark.com/yuque/0/2020/png/1554318/1608651610800-ea779df9-a17a-4a89-8c87-82b822c0a7e9.png" alt="4.png" title="4.png"> </p><p>index.htm1：1</p><p>AccesstoXMLHtpRequestathttp：//ocalhost/rindfm</p><p>biockedbyCORS</p><p>policy：NoAccess-Contro1-</p><p>http：//1ocalhost：8888hasbeenboc</p><p>origin</p><p>A11ow-Origin</p><p>header</p><p>presentontherequested</p><p>resource.</p><p>失败,报错,不能跨域访问数据。</p><h2 id="CORS实现跨域-1"><a href="#CORS实现跨域-1" class="headerlink" title="CORS实现跨域"></a>CORS实现跨域</h2><p>为了解决这个问题,在qq.com的服务器中的friends.json中加一条声明</p><p>Access-Control-Allow-Origin： 允许访问的源。</p><p> <img src="https%EF%BC%9A//cdn.nlark.com/yuque/0/2020/png/1554318/1608651941660-d46ba099-bd74-47ed-9f5e-249dd15a5a45.png" alt="5.png" title="5.png"> </p><p>iseif(path–E”/friends.json”)</p><p>200</p><p>response.statuscode</p><p>(‘Content-Type’’text/json;charset-utf-8);</p><p>response.setHeader’co</p><p>“http：//1ocahost：8888”);</p><p>SetHeader(“Access-Control-A11ow-origin”</p><p>response</p><p>response.Write(fs.readFilesync/ubic/friend.”</p><p>response.end)</p><p>这样,pengpeng.com就可以访问qq.com中friends.json的数据了。</p><h2 id="JSONP实现跨域-1"><a href="#JSONP实现跨域-1" class="headerlink" title="JSONP实现跨域"></a>JSONP实现跨域</h2><p>我们假如要兼容IE6,7,8,9时,CORS不被兼容,这个时候我们需要通过JSONP来解决</p><p>思路：</p><p>因为JS文件是可以引用的,而例如json等文件是不可以被访问的。</p><p>我们可以通过引用JS文件的形式来间接的访问我们所需的数据。</p><p>前提是我们得将我们需要的数据通过后台,放到一个JS文件中。</p><p>使用JSONP方法在pengpeng.com向qq.com访问friends.json文件数据模拟过程如下</p><p>在pengpeng.com下的pengpeng.js中创建一个script标签并放到body里面进行引用.  </p><p> <img src="https%EF%BC%9A//cdn.nlark.com/yuque/0/2020/png/1554318/1608710065504-8039b968-b3c9-497e-a74f-465b4f42cd87.png" alt="2.png" title="2.png"> </p><p>script</p><p>document.createelement(“script”</p><p>const</p><p>“http：//1ocaihost：8889/friends.j”;</p><p>script.src</p><p>document.body.appendchild(script);</p><p>这个script的src为qq.com中的qq.js</p><p>当访问qq.js时,qq.com的服务器会将friends.json中的数据渲染到qq.js中。</p><p> <img src="https%EF%BC%9A//cdn.nlark.com/yuque/0/2020/png/1554318/1608710107045-896be5f2-40bf-4f5a-81bc-379591fefedc.png" alt="3.png" title="3.png"> </p><p>window.xxx(tdata]]</p><p> <img src="https%EF%BC%9A//cdn.nlark.com/yuque/0/2020/png/1554318/1608710141371-1bfdca87-bf71-45dd-a72e-ad7e74e88e72.png" alt="4.png" title="4.png"> </p><p>e1seif(path—“/friends.js</p><p>response.statuscode-200;</p><p>response.setHeader(content-Type,text/javascriptcharset-ut8)</p><p>conststring二fsreadFilesync./pulic/friend”.</p><p>constdatafsreadFilesyncu</p><p>string.replace(“databb”,data);</p><p>const</p><p>string2</p><p>response.write(string2)</p><p>O);</p><p>response.end</p><p>这样,我们就间接的得到了qq.com中的friends.json中的数据。</p><p> <img src="https%EF%BC%9A//cdn.nlark.com/yuque/0/2020/png/1554318/1608710174916-988f5b1b-3a73-4c5c-bb51-bece97b7c32e.png" alt="5.png" title="5.png"> </p><p>Timing</p><p>Response</p><p>Headers</p><p>Initiator</p><p>Preview</p><p>Name</p><p>“吴彦祖”,tname：”刘德华”]]);</p><p>index.html</p><p>window.XXX(Cin</p><p>iname：</p><p>0：fname：”吴彦祖”</p><p>pengpengjs</p><p>1：tname：”刘德华”]</p><p>friendsjs</p><h3 id="JSONP优化一-1"><a href="#JSONP优化一-1" class="headerlink" title="JSONP优化一"></a>JSONP优化一</h3><p>当前的JSONP无法识别访问者的身份</p><p>解决方法：利用requesr.heads[“referer”]识别</p><p> <img src="https%EF%BC%9A//cdn.nlark.com/yuque/0/2020/png/1554318/1608710763529-f463d241-1099-45fa-99f2-e8ce19d79ca4.png" alt="11.png" title="11.png"> </p><p>“/friends.</p><p>if</p><p>else</p><p>path</p><p>if</p><p>request.headerst”referer”j.indexof(Chttp：//localhost：8)</p><p>response.statuscode-200;</p><p>response.setHeader(‘Content-Type</p><p>‘text/javascript;charset-utf-8”)</p><p>c(“./public/friends.js”)tostring);</p><p>conststringfs.readfilesync(“</p><p>fs.readFilesync(./public/friends.json”).ing</p><p>constdata</p><p>string.rep1ace(“databb”,data);</p><p>string2</p><p>const</p><p>response.write(string2)</p><p>response.end();</p><p>4</p><p>else</p><p>response.statuscode-404;</p><p>response.end</p><p>当请求头包含”http：//localhost：8888”时,运行访问,否则不允许。</p><p> <img src="https%EF%BC%9A//cdn.nlark.com/yuque/0/2020/png/1554318/1608710804026-9095d2c9-4164-4fc1-b0f1-1fa8abbe99ce.png?x-oss-process=image/resize,w_1150" alt="6.png" title="6.png"> </p><p>localhost：8888/index.html</p><p>第I一天/索材/品…2019年最全最新Vu…</p><p>[查缺补玩)我的2….</p><p>ES6入门叔星</p><p>其他书签</p><p>从零玩转jQuery原…</p><p>104JCSS面试题…</p><p>应用</p><p>刮译</p><p>Console</p><p>Sources</p><p>Performance</p><p>Network</p><p>Application</p><p>Memory</p><p>Elements</p><p>我是黑客</p><p>O</p><p>了</p><p>Disablecache</p><p>Online</p><p>Search</p><p>Preservelog</p><p>CeFiIter</p><p>HidedataURLs</p><p>xHRJScSSlmg</p><p>HasblockedcookiesOBlockedRequests</p><p>MediaFontDocwsManifestOther</p><p>Groupbyframe</p><p>Uselargereguestrows</p><p>Showoverview</p><p>Capturescreenshots</p><p>50ms</p><p>100ms</p><p>150ms</p><p>ResponselnitiatorTiming</p><p>Preview</p><p>Headers</p><p>Name</p><p>window.xxx([iiname：”吴”.name：”刘德华”]]);</p><p>index.html</p><p>B：iname：”吴产和”</p><p>pengpengJs</p><p>1：tname：”刘德华”]</p><p>friends.js</p><p>1.0kBtransferred</p><p>3requests</p><h3 id="JSONP优化二-1"><a href="#JSONP优化二-1" class="headerlink" title="JSONP优化二"></a>JSONP优化二</h3><p>当前只能获取到friends.json里面的数据,如果需要访问很多借口,一个xxx函数显然无法满足我们的需求。</p><p>思路：</p><p>创建一个随机数来代替xxx,然后将此随机数作为查询参数传递给qq.com后台。</p><p> <img src="https%EF%BC%9A//cdn.nlark.com/yuque/0/2020/png/1554318/1608712555607-bf5b58cd-ed1c-4731-93ab-12dcee0dbd85.png" alt="22.png" title="22.png"> </p><p>Math.random(</p><p>random</p><p>const</p><p>window[random]-(data)-&gt;f</p><p>conso1e.g(data);</p><p>Constsciptdocument.createlement”scrit”;</p><p>script.src</p><p>http：//1ocalhost：8889/friends.jackraom</p><p>y.appendchild(script);</p><p>document.body.a</p><p>qq.com后台再用此随机数代替qq.js中的xxx。</p><p> <img src="https%EF%BC%9A//cdn.nlark.com/yuque/0/2020/png/1554318/1608712687080-ee68811d-d925-4953-b54f-7de8a3df567f.png" alt="333.png" title="333.png"> </p><p>window[“txxx”(data</p><p> <img src="https%EF%BC%9A//cdn.nlark.com/yuque/0/2020/png/1554318/1608712733522-9dc8e98e-9ba2-43f2-b374-a3dd5f26a5f7.png" alt="444.png" title="444.png"> </p><p>rerJ.indexof(http：//localhost：8888</p><p>(reguest.headersL’referer</p><p>200;</p><p>response.statuscode</p><p>response.setHeader(content-Type,text/javascript;charset-utf8)</p><p>CONSTStrIngfSrEAdFIeSync.u/riend.</p><p>constdata二fs.readilesyncuini</p><p>cal1back)</p><p>ONSTSTRINGSTRINB.PLAcEC”TDTAP”DaTA).rePLace(TXCLY.</p><p>response.write(string2)</p><p>responsenend();</p><p>else</p><p>response.statuscode-404;</p><p>response,end();</p><h3 id="-2"><a href="#-2" class="headerlink" title=""></a></h3><h3 id="JSONP相对于AJAX的优点-1"><a href="#JSONP相对于AJAX的优点-1" class="headerlink" title="JSONP相对于AJAX的优点"></a>JSONP相对于AJAX的优点</h3><p>兼容IE</p><p>可以跨域</p><h3 id="-3"><a href="#-3" class="headerlink" title=""></a></h3><h3 id="JSONP缺点-1"><a href="#JSONP缺点-1" class="headerlink" title="JSONP缺点"></a>JSONP缺点</h3><p>由于它是script标签,拿不到状态码</p><p>只能发get请求,不支持post。</p><p>若有收获，就点个赞吧</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2021/03/03/%E6%B5%85%E6%9E%90JSON/"/>
    <url>/2021/03/03/%E6%B5%85%E6%9E%90JSON/</url>
    
    <content type="html"><![CDATA[<h1 id="浅析JSON"><a href="#浅析JSON" class="headerlink" title="浅析JSON"></a>浅析JSON</h1><h1 id="一-JSON不是对象-是一门标记语言"><a href="#一-JSON不是对象-是一门标记语言" class="headerlink" title="一.JSON不是对象,是一门标记语言"></a>一.JSON不是对象,是一门标记语言</h1><p>JSON与HTML,CSS,XML,JS一样,是一门语言,而且是一门标记语言。</p><h1 id="二-JSON支持的数据类型"><a href="#二-JSON支持的数据类型" class="headerlink" title="二.JSON支持的数据类型"></a>二.JSON支持的数据类型</h1><p>与JS不一样,JSON支持的数据类型只有6种,它们分别是</p><p>string–只支持双引号</p><p>number</p><p>bool–true和false</p><p>null–没有undefined</p><p>object</p><p>array</p><p>不支持函数,也不支持变量。</p><p>具体参考:<a href="http://json.org/json-zh.html">JSON中文网</a>。</p><h1 id="三-JSON-parse-和-JSON-stringify"><a href="#三-JSON-parse-和-JSON-stringify" class="headerlink" title="三.JSON.parse() 和 JSON.stringify()"></a>三.JSON.parse() 和 JSON.stringify()</h1><h2 id="JSON-parse"><a href="#JSON-parse" class="headerlink" title="JSON.parse()"></a>JSON.parse()</h2><p>JSON.parse()将符合JSON语法的字符串转换为JS对应的数据类型。</p><p>JSON数据=&gt;JS数据</p><p>由于JSON数据只有6种,所以转换成的数据也只有6种。</p><p>如果不符合JSON数据,则直接抛出一个error。</p><h2 id="JSON-stringify"><a href="#JSON-stringify" class="headerlink" title="JSON.stringify()"></a>JSON.stringify()</h2><p>JSON.stringify()将JS数据转换为JSON字符串。<br>JS数据=&gt;JSON数据</p><p>由于JS的数据类型比JSON多,所以不一定能成功。</p><p>如果失败,则直接抛出一个error。</p><p>若有收获，就点个赞吧</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2021/03/03/%E6%B5%85%E6%9E%90AJAX/"/>
    <url>/2021/03/03/%E6%B5%85%E6%9E%90AJAX/</url>
    
    <content type="html"><![CDATA[<h1 id="浅析AJAX"><a href="#浅析AJAX" class="headerlink" title="浅析AJAX"></a>浅析AJAX</h1><p>一.AJAX的原理  </p><p>============</p><ul><li>  Ajax的全称是异步javascript和XML,目前我们一般用JSON代替XML。</li><li>  通俗的理解:在网页中利用XMLHttpRequest对象和服务器进行数据交互的方式,就是Ajax。</li><li>  AJAX 主要用于在不刷新页面的情况下向浏览器发起请求并接受响应，最后局部更新页面。</li><li>  优点是不刷新就可以发起请求并接受响应。</li></ul><h1 id="二-AJAX使用方法"><a href="#二-AJAX使用方法" class="headerlink" title="二.AJAX使用方法"></a>二.AJAX使用方法</h1><p>想要用 JS 发起一个AJAX请求很简单，一共 4 步。</p><p>第一步创建一个XMLHttpRequest对象</p><p>const request = new XMLHttpRequest();</p><p>第二步open方法设置参数</p><p>request.open(“GET”,”/style.css”)</p><p>第三步监听请求成功,并接受响应</p><p>request.onreadystatechange = ()=&gt;{  if(this.readyState === 4){ if(this.status &gt;= 200 &amp;&amp; this.status&lt;300){ console.log(request.response); }else { alert(“请求失败”); } }</p><p>第四步发送请求</p><p>request.send();</p><h2 id="一个请求的一生"><a href="#一个请求的一生" class="headerlink" title="一个请求的一生"></a>一个请求的一生</h2><p>请求在不同阶段会有不同的readyState，了解这个更能理解第三步onreadyStateChange事件</p><p>请求的不同阶段</p><p>readyState</p><p>let request = new XMLHttpRequest()</p><p>0</p><p>request.open(‘GET’, ‘/style.css’)</p><p>1</p><p>request.send()</p><p>2</p><p>第一个响应信息出现在浏览器</p><p>3</p><p>所有响应下载完成</p><p>4</p><h1 id="三-加载CSS"><a href="#三-加载CSS" class="headerlink" title="三.加载CSS"></a>三.加载CSS</h1><p>重点在怎么处理拿到的响应：生成style标签</p><h1 id="四-加载JS"><a href="#四-加载JS" class="headerlink" title="四.加载JS"></a>四.加载JS</h1><p>重点在怎么处理拿到的响应：生成script标签</p><h1 id="五-加载HTML"><a href="#五-加载HTML" class="headerlink" title="五.加载HTML"></a>五.加载HTML</h1><h1 id="六、加载JSON"><a href="#六、加载JSON" class="headerlink" title="六、加载JSON"></a>六、加载JSON</h1><p>JSON.parse 将符合JSON语法的字符串转换成JS对应类型的数据</p><p>JSON.stringify 把JS数据变成JSON字符串</p><p>若有收获，就点个赞吧</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2021/03/03/DOM%E4%BA%8B%E4%BB%B6%E4%B8%8E%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98/"/>
    <url>/2021/03/03/DOM%E4%BA%8B%E4%BB%B6%E4%B8%8E%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98/</url>
    
    <content type="html"><![CDATA[<h1 id="DOM事件与事件委托"><a href="#DOM事件与事件委托" class="headerlink" title="DOM事件与事件委托"></a>DOM事件与事件委托</h1><h2 id="JS事件流"><a href="#JS事件流" class="headerlink" title="JS事件流"></a>JS事件流</h2><p>事件流描述的是从页面中接受事件的顺序。</p><p>事件发生时会在元素节点之间按照特定的顺序传播,这个传播过程叫做DOM事件流。</p><p>DOM事件流分为三个过程</p><p>1.捕获阶段</p><p>事件捕获:从DOM的顶层节点逐级向下传播,最终由最具体的元素接受。</p><p>2.当前目标阶段</p><p>3.冒泡阶段</p><p>事件冒泡:最开始由最具体的元素接受,然后逐级向上传播至DOM的顶层节点。</p><p> <img src="https://cdn.nlark.com/yuque/0/2020/png/1554318/1608189601032-4fce1c29-1417-4f9c-8497-4230aa213e8b.png" alt="image.png" title="image.png"> </p><p>Documcnt</p><p>Elcmcnthtml</p><p>百泡阶段</p><p>纯英价段</p><p>Elemcntbodly</p><p>Elcmerdiv</p><p>DOM事件流</p><p>1 JS代码中只能执行捕获或则冒泡其中的一个阶段</p><p>2.onclick和attachEvent只能得到冒泡阶段。</p><p>3.addEventListener(type,listener[,useCapture]) 第三个参数如果是true，表示在捕获阶段调用事件处理程序,如果是false表示在冒泡阶段调用事件处理程序。</p><p>4.有些事件时没有冒泡的 比如onblur,onfocus,onmouseenter,onmouseleave.</p><p>5.事件冒泡有时候会带来麻烦，有时候又会帮助很巧妙的做某些事情。</p><h2 id="事件冒泡与事件捕获"><a href="#事件冒泡与事件捕获" class="headerlink" title="事件冒泡与事件捕获"></a>事件冒泡与事件捕获</h2><h3 id="事件冒泡"><a href="#事件冒泡" class="headerlink" title="事件冒泡"></a>事件冒泡</h3><p>事件冒泡:事件最开始由最具体的元素接受,然后逐级向上传播至DOM的顶层节点document。</p><p>因此上面的例子在事件冒泡阶段下发生click事件的顺序应该是</p><p><strong>son–&gt;father–&gt;body–&gt;html–&gt;document</strong></p><h3 id="事件捕获"><a href="#事件捕获" class="headerlink" title="事件捕获"></a>事件捕获</h3><p>与事件冒泡相反:事件开始从顶级节点document出发,然后逐级向下传播至最具体的元素。</p><p>还是上面那个例子,在事件捕获阶段下发生的click事件的顺序应该是</p><p>document–&gt;html–&gt;body–&gt;father–&gt;son  </p><p> <img src="https://cdn.nlark.com/yuque/0/2020/png/1554318/1608189601032-4fce1c29-1417-4f9c-8497-4230aa213e8b.png" alt="image.png" title="image.png"> </p><p>Documcnt</p><p>Elcmcnthtml</p><p>百泡阶段</p><p>纯英价段</p><p>Elemcntbodly</p><p>Elcmerdiv</p><p>DOM事件流</p><p>根据这张DOM事件流执行的顺序图,我们可以总结,上面的例子中1-5是捕获阶段,5-6是目标阶段,6-10是冒泡阶段。</p><p>并且是先捕获再冒泡。</p><h3 id="阻止事件冒泡和阻止默认事件"><a href="#阻止事件冒泡和阻止默认事件" class="headerlink" title="阻止事件冒泡和阻止默认事件"></a>阻止事件冒泡和阻止默认事件</h3><p>阻止事件冒泡   event.stopPropagation()</p><p>阻止默认事件   event.prevevtDefault()</p><h2 id="事件委托以及使用场景"><a href="#事件委托以及使用场景" class="headerlink" title="事件委托以及使用场景"></a>事件委托以及使用场景</h2><h3 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h3><p><strong>事件委托就是利用事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。</strong></p><p><strong>通俗点来讲就是:不监听元素 C 自身，而是监听其祖先元素 P，然后判断 e.target 是不是该元素 C（或该元素的子元素）。</strong></p><p>事件委托有两个优点:</p><ul><li>  节省监听数(节省内存)</li><li>  可以监听动态元素</li></ul><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>场景一:</p><p>我们要给100个按钮添加监听事件,咋办?</p><p>答:监听这100个按钮的祖先,等冒泡的时候判断target是不是这100个按钮中的一个。</p><p>代码👇</p><p>场景二:</p><p>我们要监听目前不存在的元素的点击事件,咋办?</p><p>答:监听祖先,等点击的时候看看是不是我们想要监听的事件。</p><p>代码👇</p><p>自己封装一个on事件用于实现事件委托</p><p>代码👇</p><p>更为规范的写法</p><h2 id="手写原生js实现事件代理，注意浏览器兼容"><a href="#手写原生js实现事件代理，注意浏览器兼容" class="headerlink" title="手写原生js实现事件代理，注意浏览器兼容"></a>手写原生js实现事件代理，注意浏览器兼容</h2><h2 id="自定义事件"><a href="#自定义事件" class="headerlink" title="自定义事件"></a>自定义事件</h2><p>如何创建并发布一个自定义事件</p><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h2 id="监听事件的三种方式"><a href="#监听事件的三种方式" class="headerlink" title="监听事件的三种方式"></a>监听事件的三种方式</h2><h3 id="1-传统方式注册事件"><a href="#1-传统方式注册事件" class="headerlink" title="1.传统方式注册事件"></a>1.传统方式注册事件</h3><p>on开头的事件</p><p>传统方式注册事件的特点:</p><p>同一个元素同一个事件只能设置一个处理函数,最后注册的处理函数会覆盖前面注册的处理函数（注册事件的唯一性）。</p><h3 id="2-方法监听注册事件（IE9以上）"><a href="#2-方法监听注册事件（IE9以上）" class="headerlink" title="2.方法监听注册事件（IE9以上）"></a>2.方法监听注册事件（IE9以上）</h3><p>eventTarget.addEventListener(‘type’,function{},[useCapture])方法将指定的监听器注册到目标对象身上 ,当该对象触发指定的事件时,就会执行事件处理函数。</p><p>同一个元素同一个事件可以添加多个监听器(事件处理程序)。</p><p>三个参数：</p><p>type：事件类型**字符串** 比如click,mouseover。不用加on。</p><p>listener: 事件处理函数 事件发生时，会调用该监听函数 function(){}</p><p>useCapture:可选函数，是一个布尔值，默认为false。</p><h3 id="3-方法监听注册事件（IE9以下-IE独有）"><a href="#3-方法监听注册事件（IE9以下-IE独有）" class="headerlink" title="3.方法监听注册事件（IE9以下 IE独有）"></a>3.方法监听注册事件（IE9以下 IE独有）</h3><p>eventTarget.attachEvent(‘事件类型字符串’,事件处理程序)。</p><p>事件类型字符串必须加on。</p><p>.</p><p>若有收获，就点个赞吧</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2021/03/03/jQuery%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    <url>/2021/03/03/jQuery%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="jQuery学习总结"><a href="#jQuery学习总结" class="headerlink" title="jQuery学习总结"></a>jQuery学习总结</h1><h1 id="1-jQuery概述"><a href="#1-jQuery概述" class="headerlink" title="1. jQuery概述"></a>1. jQuery概述</h1><p>javascript库:即library,是一个封装好的特定的集合(包括方法和函数)。从封装一大堆函数的角度理解库,就是在这个库中,封装了很多预先定义好的函数在里面,比如动画animate,hide,show,比如获取元素等。</p><p>简单理解就是:就是为了提高我们的工作效率,摒弃以前苦逼的写原生代码,把用过的函数,方法,放到一个文件里面,想用哪个方法,直接在外边写个接口调用即可。</p><h1 id="2-jQuery优点"><a href="#2-jQuery优点" class="headerlink" title="2.jQuery优点"></a>2.jQuery优点</h1><p>jQuery是一个快速,简介的javascript库,其设计的宗旨是”write Less, Do More”，即倡导写更少的代码,做更多的事情。</p><p>jQuery封装了javascript常用的功能代码,又花了DOM操作,事件处理,动画设计和Ajax交互。</p><p>学习jQUery本质:就是学习调用这些函数(方法)。</p><ul><li>  轻量级。</li><li>  跨浏览器兼容。</li><li>  链式编程,隐式迭代。</li><li>  对事件,样式,动画支持,大大简化DOM操作。</li><li>  支持第三方插件。</li><li>  开源,免费</li></ul><h1 id="3-jQuery的基本使用"><a href="#3-jQuery的基本使用" class="headerlink" title="3.jQuery的基本使用"></a>3.jQuery的基本使用</h1><h2 id="1-jQuery的下载"><a href="#1-jQuery的下载" class="headerlink" title="1.jQuery的下载"></a>1.jQuery的下载</h2><p>版本:1x:兼容IE678等低版本浏览器,官网不再更新。</p><p>版本:2x:兼容IE678等低版本浏览器,官网不再更新。</p><p>2. jquery的入口函数:</p><p>1.$(document).ready(function(){   })   2.$(function() {   })</p><p>注意：</p><p>1.等着DOM结构渲染完毕即可执行内部代码,不必等到所有外部资源加载完成,jQuery帮我们完成了封装。</p><p>2.相当于原生JS中的DOMContentLoaded.</p><h2 id="2-jQuery的顶级对象"><a href="#2-jQuery的顶级对象" class="headerlink" title="2.jQuery的顶级对象$"></a>2.jQuery的顶级对象$</h2><p>1.$是jQuery的别称。</p><p>2.$同时也是jQuery的顶级对象,类似于DOM中的window.</p><p>我们可以将元素包装成jquery对象,然后使用jQuery的方法。</p><p>当jquery中的$与我们其他框架中的$符号冲突时,解决冲突的两种方法:</p><p>1.在使用jquery编写代码前,使用Jquery.noConflict()方法,用jquery代替$。</p><p>2.自定义标识符代替$,</p><p>$被nb所代替。</p><h2 id="3-jQuery对象和DOM对象"><a href="#3-jQuery对象和DOM对象" class="headerlink" title="3.jQuery对象和DOM对象"></a>3.jQuery对象和DOM对象</h2><p>1.DOM对象:用原生JS获取过来的对象就是DOM对象。</p><p>2.jQuery对象:用jQuery方式获取过来的对象是jQuery对象。本质:通过$把DOM元素进行了包装。</p><p>3.jQuery对象只能使用jQuery方法,DOM对象只能使用DOM方法和属性。</p><p>4.jQuery对象和DOM对象的互相转化</p><p>DOM对象与jQuery对象之间是可以相互转换的。</p><p>因为DOM对象的一些方法和函数jQuery没有给我们封装(比如jquery中的video的play方法),因此,要想使用这些属性和方法需要把jQuery转换为DOM对象才能使用。</p><p>DOM对象转换为jQuery对象与jquery转换为DOM对象。</p><p>hasClass不用加引号</p><h1 id="4-jquery常用API"><a href="#4-jquery常用API" class="headerlink" title="4.jquery常用API"></a>4.jquery常用API</h1><h3 id="1-jquery基础选择器"><a href="#1-jquery基础选择器" class="headerlink" title="1.jquery基础选择器"></a>1.jquery基础选择器</h3><p>原生JS获取元素方式很多很杂,而且兼容性情况不一样,因此jquery给我吗做了封装,使获取元素统一标准。</p><p>$(‘选择器’)//里面选择器直接写CS选择器即可,但是要加引号。</p><p> <img src="https://cdn.nlark.com/yuque/0/2020/png/1554318/1608122268969-988e186e-7624-49ab-a66e-6ffcdff68feb.png" alt="image.png" title="image.png"> </p><p>用法</p><p>名称</p><p>描述</p><p>获取指定ID的元素</p><p>ID选择器</p><p>s(#id”</p><p>匹配所有元素</p><p>全选选择器</p><p>s(*“)</p><p>公</p><p>获取同一类class的元素</p><p>类选择器</p><p>sC.cIass”)</p><p>获取同一类标签的所有元素</p><p>s(‘div”)</p><p>标签选择器</p><p>选取多个元素</p><p>s(divp.li”)</p><p>并集选择器</p><p>交集元素</p><p>交集选择器</p><p>s(li.current”)</p><p> <img src="https://cdn.nlark.com/yuque/0/2020/png/1554318/1608122291629-34d46467-c673-42c3-9dc0-c42486a2dd84.png" alt="image.png" title="image.png"> </p><p>描述</p><p>名称</p><p>用法</p><p>使用&gt;号,获取亲儿子层级的元素;注意,并不会获取孙子层级的元素</p><p>子代选择器</p><p>s(“ulz1i”);</p><p>使用空格,代表后代选择器,获取ul下的所有素,包括孙子等</p><p>后代选择器</p><p>s(“ulli”);</p><h3 id="2-隐式迭代-重要"><a href="#2-隐式迭代-重要" class="headerlink" title="2. 隐式迭代(重要)"></a>2. 隐式迭代(重要)</h3><p>遍历内部DOM元素(伪数组形式存储)的过程叫做隐式迭代。</p><p>简单理解:给匹配到的所有元素进行遍历循环,执行相应的方法,而不用我们再进行循环,简化我们的操作,方便我们调用。</p><p>使用前提条件:我们要获取到的所有元素执行同一操作。</p><h3 id="3-jquery筛选选择器"><a href="#3-jquery筛选选择器" class="headerlink" title="3.jquery筛选选择器"></a>3.jquery筛选选择器</h3><p>使用条件:获取多个元素中的某一个元素。</p><p> <img src="https://cdn.nlark.com/yuque/0/2020/png/1554318/1608122381631-6c4dc634-aec5-469a-9771-82d4a1e191e6.png" alt="image.png" title="image.png"> </p><p>描述</p><p>用法</p><p>语法</p><p>获取第一个li元素</p><p>sCli:first”)</p><p>:first</p><p>获取最后一个li元素</p><p>s(li:last”)</p><p>:last</p><p>获取到的|元素中,选择索引号为2的元素,索引号index从o开始.</p><p>s(“liseg(2))</p><p>eg(index)</p><p>获取到的li元素中,选择索引号为奇数的元素</p><p>s(li:odd”)</p><p>:odd</p><p>获取到的i元素中,选择索引号为偶数的元素</p><p>s(li:even”)</p><p>even</p><h3 id="4-jquery筛选方法"><a href="#4-jquery筛选方法" class="headerlink" title="4.jquery筛选方法"></a>4.jquery筛选方法</h3><p> <img src="https://cdn.nlark.com/yuque/0/2020/png/1554318/1608122407750-c1583c0d-10d4-4c71-bc0b-017e3ac5b8d3.png?x-oss-process=image/resize,w_886" alt="image.png" title="image.png"> </p><p>用法</p><p>语法</p><p>说明</p><p>查找父级</p><p>s(1i”).parentO:</p><p>parent)</p><p>相当于s(“ul&gt;li”),最近一级(亲儿子)</p><p>$(“ul”).children(“li”)</p><p>children(selector)</p><p>相当于s(“ulli”)后代选择器</p><p>$(“ul”).find(“1i”):</p><p>FinD(seLector)</p><p>查找兄弟节点,不包括自己本身</p><p>$(“first”).siblings(1i”);</p><p>siblings(selector)</p><p>查找当前元素之后所有的同辈元素</p><p>nextaii([expr])</p><p>sC”.first”).nexta110)</p><p>查找当前元素之前所有的同辈元素</p><p>s(.last”).preva110)</p><p>prevtaii([expr])</p><p>检查当前的元素是否含有某个特定的类,如</p><p>s(div”).hasclass(“protected”)</p><p>hasclass(class)</p><p>果有,则返回true</p><p>相当于s(“li:eq(2)”)index从O开始</p><p>$(“li”).eq(2);</p><p>eg(index)</p><p>prevtALll改为prevAll</p><p>获取祖先级元素parents(“”)</p><h3 id="5-jquery中的排他算法"><a href="#5-jquery中的排他算法" class="headerlink" title="5.jquery中的排他算法"></a>5.jquery中的排他算法</h3><p>想要多选一的效果,排他思想:当前元素这只样式,其他的兄弟清除样式。</p><p>$(this).index()得到当前索引号。</p><h3 id="6-操作css方法"><a href="#6-操作css方法" class="headerlink" title="6.操作css方法"></a>6.操作css方法</h3><p>1.参数只写属性名,则是返回属性值</p><p>$(this).css(“color”);</p><p>2.参数是属性名,属性值,逗号分隔,是设置一组样式,属性必须加引号,值如果是数字可以不加引号和单位。</p><p>$(this).css(“color”,”red”)</p><p>3.参数可以是对象形式,方便设置多组样式。属性名和属性值用,冒号分开.属性可以不用加引号。</p><p>4.设置类样式方法</p><p>作用等同于以前的classList，可以操作类样式,注意操作类里面的参数不要加点。</p><p>区别于原来原生JS中学的className。</p><p>className会覆盖原先里面的类名。jquery里面的类操作只是对指定类进行操作,不影响原先的类名。</p><p>4.1添加类</p><p>$(“div”).addClass(“current”);</p><p>4.2删除类</p><p>$(“div”).removeClass(“current”);</p><p>4.3切换类</p><p>$(“div”).toggleClass(“current”);</p><h2 id="5-jquery效果"><a href="#5-jquery效果" class="headerlink" title="5.jquery效果"></a>5.jquery效果</h2><p>jquery给我们封装了很多动画效果</p><h3 id="1-显示隐藏效果show"><a href="#1-显示隐藏效果show" class="headerlink" title="1.显示隐藏效果show();"></a>1.显示隐藏效果show();</h3><p>显示隐藏的匹配元素。</p><p>这个就是 ‘show( speed, [callback] )’ 无动画的版本。</p><p>如果选择的元素是可见的，这个方法将不会改变任何东西。无论这个元素是通过hide()方法隐藏的还是在CSS里设置了display:none;，这个方法都将有效。</p><p>show([speed],[easing],[fn])</p><p>speed指定的速度,可以设置为slow,normal,fast也可以设置为数字,单位为毫秒。</p><p>easing默认为swing先快再慢再快，linear匀速变化。</p><p>fn,回调函数,动画执行完后调用。</p><h3 id="2-隐藏效果hide"><a href="#2-隐藏效果hide" class="headerlink" title="2.隐藏效果hide()"></a>2.隐藏效果hide()</h3><p>基本与上面描述一致,只不过这个是用来隐藏元素的。</p><h3 id="3-切换显示-隐藏toggle"><a href="#3-切换显示-隐藏toggle" class="headerlink" title="3.切换显示,隐藏toggle()"></a>3.切换显示,隐藏toggle()</h3><p>两个状态通过触发事件来变换。</p><p><strong>动画或效果队列</strong></p><p>动画或效果一旦触发就会执行,如果多次触发,就会造成多个动画或效果排队执行。</p><p>容易造成上个动画效果在视觉上的延迟,影响用户体验。</p><p><strong>stop停止排队</strong></p><p>所以为了解决这个问题,我们必须得用stop()方法阻止上个动画的执行。</p><p>使得每次都执行一个动画，值得注意的是,s<strong>top()必须写到动画的前面</strong>。</p><h3 id="4-淡入淡出效果"><a href="#4-淡入淡出效果" class="headerlink" title="4.淡入淡出效果"></a>4.淡入淡出效果</h3><p>淡入fadeIn([speed],[easing],[callback])</p><p>淡出fadeOut([speed],[easing],[callback])</p><p>淡入淡出切换fadeToggle([speed],[easing],[callback])</p><p>渐进方式调整到指定的不透明度fadeTo(speed,opacity ,[easing],[callback])</p><p>fadeTo的前两个参数是必选的,opacity的范围是0~1.</p><h3 id="5-自定义动画animate"><a href="#5-自定义动画animate" class="headerlink" title="5.自定义动画animate"></a>5.自定义动画animate</h3><p>animate(parame,[speed],[easing],[fn])</p><p>params：想要更改的样式属性以对象的形式传递,必须写。属性名可以不带引号,如果是复合属性则需要采取驼峰命名法</p><h2 id="6-JS属性操作"><a href="#6-JS属性操作" class="headerlink" title="6.JS属性操作"></a>6.JS属性操作</h2><h3 id="1-设置或获取元素固有属性值prop"><a href="#1-设置或获取元素固有属性值prop" class="headerlink" title="1.设置或获取元素固有属性值prop()"></a>1.设置或获取元素固有属性值prop()</h3><p>所谓元素固有属性就是元素本身自带的属性,比如元素里面的href,比如元素里面的type.</p><p>1.获取属性语法:</p><p>prop(“属性”)</p><p>2.设置属性语法</p><p>prop(“属性”,”值”)</p><h3 id="2-设置或获取自定义属性值attr"><a href="#2-设置或获取自定义属性值attr" class="headerlink" title="2.设置或获取自定义属性值attr()"></a>2.设置或获取自定义属性值attr()</h3><p>1.获取属性语法:</p><p>attr(“属性”)</p><p>2.设置属性语法</p><p>attr(“属性”,”值”)</p><p>该方法也可以获取H5自定义属性</p><h3 id="3-数据缓存data"><a href="#3-数据缓存data" class="headerlink" title="3.数据缓存data()"></a>3.数据缓存data()</h3><p>data()方法可以在指定的元素上存取数据,并不会改变DOM结构.一旦页面刷新,之前存放的数据都将被移除。</p><p>1.附加数据语法</p><p>data(“name”,”value”)向被选元素附加数据</p><p>2.获取数据语法</p><p>data(“name”);向被选元素获取数据</p><p>同时还可以读取HTML5自定义属性,不用加data,获取的是数字型</p><p>:checked可以获取选定的复选框。</p><h2 id="7-jquery文本内容操作"><a href="#7-jquery文本内容操作" class="headerlink" title="7.jquery文本内容操作"></a>7.jquery文本内容操作</h2><p>1.普通元素内容html()</p><p>（相当于元素innerHtml）</p><p>html() 获取元素内容</p><p>html(“内容”)修改元素内容</p><p>注意:获取的元素包括标签,同时保留空格和换行</p><p>2.普通元素文本内容text()</p><p>text() 获取元素内容</p><p>text(“内容”)修改元素内容</p><p>只保留文本内容,忽略标签和空格换行。</p><p>3.获取设置表单元素val()</p><p>val()针对表单使用</p><p>toFixed(num)保留几位小数</p><h2 id="8-jquery元素操作"><a href="#8-jquery元素操作" class="headerlink" title="8.jquery元素操作"></a>8.jquery元素操作</h2><p>遍历,创建，添加,删除元素</p><h3 id="1-遍历元素"><a href="#1-遍历元素" class="headerlink" title="1.遍历元素"></a>1.遍历元素</h3><p>jquery隐性迭代是对同一类袁术做了同样的操作。如果想要给同一元素做不同操作,就需要用到遍历。</p><p>第一种方法适合遍历大片DOM元素</p><p>1.each方法遍历匹配的每一个元素。主要用DOM处理</p><p>2.里面的回调函数有两个参数:index是每个元素的索引号,domEle是每个DOM元素对象,不是jquery对象。</p><p>第二种方法适合遍历数组,对象</p><p>语法: $.each(obj,function(index,domEle){}</p><p>index是遍历标签的索引号，domEle是dom元素</p><h3 id="2-创建添加删除元素"><a href="#2-创建添加删除元素" class="headerlink" title="2.创建添加删除元素"></a>2.创建添加删除元素</h3><p>创建元素</p><p>$(“<li></li>“)</p><p>添加元素</p><p>2.1 内部添加</p><p>$(“ul”).append(“<li></li>“) 添加至ul里面子元素的最后面</p><p>$(“ul”).prepend(“<li></li>“)添加至ul里面子元素的最前面</p><p>2.2 外部添加</p><p>element.after() 添加到ul的前面 兄弟关系</p><p>element.before()添加到ul的后面 兄弟关系</p><p>2.3 删除元素</p><p>element.remove()删除匹配的元素本身</p><p>element.empty()删除匹配的元素里面的所有子节点</p><p>element.html(“”)删除匹配的元素里面的所有子节点</p><h2 id="9-jquery事件"><a href="#9-jquery事件" class="headerlink" title="9.jquery事件"></a>9.jquery事件</h2><p>事件处理on()绑定事件</p><p>on()方法在匹配元素上绑定一个或多个事件处理函数</p><p>语法</p><p>element.on(events,[selector],fn)</p><p>1.events:一个或多个用空格分隔的事件类型</p><p>2.selector:元素的子元素选择器</p><p>3.回调函数</p><p>on()方法优势2:</p><p>可以事件委派操作.事件委派的定义就是,把原来加在子元素身上的事件绑定在父元素身上,就是把事件委派给父元素。</p><p>on()方法优势3:动态创建的元素,click()没有办法绑定事件,on()可以给未来动态生成的元素绑定事件。</p><p>事件处理off()解绑事件</p><p>off()方法可以移除通过on()方法添加的事件处理程序</p><p>$(“p”).off()解绑p元素所有事件处理程序</p><p>$(“p”).off(“click”)解绑p元素上面的点击事件 后面的foo是监听函数名</p><p>$(“ul”).off(“click”,li)解绑事件委托</p><p>如果有的事件只想触发一次用one来绑定</p><p>自动触发时间</p><p>1.元素.事件()</p><p>$(“div”).click();会触发元素的默认行为,比如表单的焦点闪烁</p><p>2.元素.trigger(“事件”)</p><p>$(“div”).trigger(“click”);会触发元素的默认行为</p><p>3.元素.triggerHandler(“事件”) 不会触发元素的默认行为</p><h2 id="10-事件对象"><a href="#10-事件对象" class="headerlink" title="10.事件对象"></a>10.事件对象</h2><p>和dom中的基本一致</p><h2 id="11-jquery其他方法"><a href="#11-jquery其他方法" class="headerlink" title="11.jquery其他方法"></a>11.jquery其他方法</h2><p><strong>对象拷贝</strong></p><p><strong>如果想要把某个对象拷贝(合并)给另外一个对象使用,此时可以使用$.extend()方法</strong></p><p>语法</p><p>$.extend([deep],target,object1,[objectN])</p><p>1.deep如果设置为true为深拷贝,默认为false，浅拷贝。</p><p>2.target要拷贝的目标对象</p><p>3.object1 待拷贝到第一个对象的对象</p><p>4.objectN 待拷贝到第N个对象的对象</p><p>5.浅拷贝是把被拷贝的对象<strong>复杂数据中的地址</strong>拷贝给目标对象,修改目标对象会影响被拷贝对象。</p><p>6.深拷贝,前面加true,完全克隆(拷贝的对象,而不是地址),修改目标对象<strong>不会影响</strong>被拷贝对象。</p><p>深拷贝把里面的数据完全复制一份给目标对象,如果里面有不冲突的属性,会合并在一起。</p><p><strong>多库共存</strong></p><p>jquery使用$作为标识符,随着jquery的流行,其他js库也会用$作为标识符,这样会引起冲突</p><p>jquery解决方法1:把里面的$符号统一改为jQuery。</p><p>解决方法2:jquery变量规定新的名称:$noConflict()  var xx= $noConflict();</p><p>以后就用xx代替$.</p><p>若有收获，就点个赞吧</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2021/03/03/jQuery%E7%B2%BE%E5%8D%8E%E6%89%80%E5%9C%A8/"/>
    <url>/2021/03/03/jQuery%E7%B2%BE%E5%8D%8E%E6%89%80%E5%9C%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="jQuery精华所在"><a href="#jQuery精华所在" class="headerlink" title="jQuery精华所在"></a>jQuery精华所在</h1><p>在2020年,jquery库虽然可能已经不如几年前那么盛行一时了,但是作为全球使用最广泛的库,它依然用于不可忽视的影响力,在学习jQuery的过程中,我对这门近乎设计至完美的库其中的一些精华和原理做出了一些总结,为了方便以后对于jQuery的使用,我写下了这篇笔记。</p><p>jQuery的精华所在是在于它的设计模式,在jQuery中出现了很多在jQuery出现之前没有的设计思想，比如重载,闭包隐藏细节,不用new的构造函数,适配器,链式操作等。通过这些设计模式,让我们对网页进行的各种操作变得简单很多。</p><ol><li> jQuery 如何获取元素</li><li> jQuery 的链式操作是怎样的</li><li> jQuery 如何创建元素</li><li> jQuery 如何移动元素</li><li> jQuery 如何修改元素的属性</li></ol><h1 id="1-元素的操作：选中网页元素"><a href="#1-元素的操作：选中网页元素" class="headerlink" title="1.元素的操作：选中网页元素"></a>1.元素的操作：选中网页元素</h1><p>“选择某个网页元素，然后对其进行某种操作”这就是jQuery的基本设计思想和主要用法,并且这是jQuery区别于其他库的根本所在。</p><p>使用jQuery的第一步，往往就是将一个选择表达式，放进构造函数jQuery()（简写为$），然后得到被选中的元素。</p><p>选择表达式可以是CSS选择器:</p><p>$(document)  //选择整个文档 $(“#myname”) //选择id为myname的元素 $(“div.haha”) //选择类名为haha的div元素 $(‘input[name=first]‘) // 选择name属性等于first的input元素</p><p>选择表达式还可以是<a href="https://jquery.cuishifeng.cn/checked_1.html">特有的表达式</a></p><p>$(“div.haha:first”)// 选中网页中第一个类名为haha的div元素 $(“tr:odd”)//选中表格中的奇数行 $(“div:visible”)//选中网页中可见的div元素 $(“:input”) //选中页面中所有的表单元素 $(“input:chekced”)//选中页面中所有被选中的表单元素</p><h1 id="2-元素的操作：过滤器"><a href="#2-元素的操作：过滤器" class="headerlink" title="2.元素的操作：过滤器"></a>2.元素的操作：过滤器</h1><p>jQuery过滤器可以让我们对上面获取的结果集进行筛选。缩小选择结果。</p><p>$(“div”).has(“p”) //选择包含p元素的div元素   $(“div”).not(“.myclass”)//选择类名不为myclass的div元素   $(‘div’).filter(‘.myClass’); //选择class等于myClass的div元素   $(‘div’).first(); //选择第1个div元素   $(‘div’).eq(5); //选择第6个div元素</p><p>有时候，我们需要从结果集出发，移动到附近的相关元素，jQuery也提供了在DOM树上的<a href="http://api.jquery.com/category/traversing/tree-traversal/">移动方法</a>：</p><h1 id="3-元素的操作：链式操作"><a href="#3-元素的操作：链式操作" class="headerlink" title="3.元素的操作：链式操作"></a>3.元素的操作：链式操作</h1><p>jQuery设计思想之三，就是最终选中网页元素以后，可以对它进行一系列操作，并且所有操作可以连接在一起，以链条的形式写出来，比如：</p><p>分解开来，就是下面这样：</p><p>这是jQuery最令人称道、最方便的特点。它的原理在于每一步的jQuery操作，返回的都是一个jQuery对象，所以不同操作可以连在一起。</p><p>jQuery还提供了<a href="http://api.jquery.com/end/">.end()</a>方法，使得结果集可以后退一步：</p><h1 id="4-元素的操作：取值和赋值"><a href="#4-元素的操作：取值和赋值" class="headerlink" title="4.元素的操作：取值和赋值"></a>4.元素的操作：取值和赋值</h1><p>操作网页元素，最常见的需求是取得它们的值，或者对它们进行赋值。</p><p>jQuery设计思想之四，就是使用同一个函数，来完成取值（getter）和赋值（setter），即”取值器”与”赋值器”合一。到底是取值还是赋值，由函数的参数决定。</p><p>常见的取值和赋值函数如下：</p><p>需要注意的是，如果结果集包含多个元素，那么赋值的时候，将对其中所有的元素赋值；取值的时候，则是只取出第一个元素的值（<a href="http://api.jquery.com/text/">.text()</a>例外，它取出所有元素的text内容）。</p><h1 id="5-元素的操作：移动"><a href="#5-元素的操作：移动" class="headerlink" title="5.元素的操作：移动"></a>5.元素的操作：移动</h1><p>jQuery设计思想之五，就是提供两组方法，来操作元素在网页中的位置移动。一组方法是直接移动该元素，另一组方法是移动其他元素，使得目标元素达到我们想要的位置。</p><p>假定我们选中了一个div元素，需要把它移动到p元素后面。</p><p>第一种方法是使用<a href="http://api.jquery.com/insertAfter/">.insertAfter()</a>，把div元素移动p元素后面：</p><p>第二种方法是使用<a href="http://api.jquery.com/after/">.after()</a>，把p元素加到div元素前面：</p><blockquote><p>　　$(‘p’).after($(‘div’));</p></blockquote><p>表面上看，这两种方法的效果是一样的，唯一的不同似乎只是操作视角的不同。但是实际上，它们有一个重大差别，那就是返回的元素不一样。第一种方法返回div元素，第二种方法返回p元素。你可以根据需要，选择到底使用哪一种方法。</p><p>使用这种模式的操作方法，一共有四对：</p><h1 id="6-元素的操作：复制、删除和创建"><a href="#6-元素的操作：复制、删除和创建" class="headerlink" title="6.元素的操作：复制、删除和创建"></a>6.元素的操作：复制、删除和创建</h1><p>除了元素的位置移动之外，jQuery还提供其他几种操作元素的重要方法。</p><p>复制元素使用<a href="http://api.jquery.com/clone/">.clone()</a>。</p><p>删除元素使用<a href="http://api.jquery.com/remove/">.remove()</a>和<a href="http://api.jquery.com/detach/">.detach()</a>。两者的区别在于，前者不保留被删除元素的事件，后者保留，有利于重新插入文档时使用。</p><p>清空元素内容（但是不删除该元素）使用<a href="http://api.jquery.com/empty/">.empty()</a>。</p><p>创建新元素的方法非常简单，只要把新元素直接传入jQuery的构造函数就行了：</p><p>若有收获，就点个赞吧</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2021/03/03/%E5%B0%81%E8%A3%85DOM%E5%BA%93/"/>
    <url>/2021/03/03/%E5%B0%81%E8%A3%85DOM%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<h1 id="封装DOM库"><a href="#封装DOM库" class="headerlink" title="封装DOM库"></a>封装DOM库</h1><p>为了简化原生的复杂的DOM操作,我对DOM的部分增删改查进行了封装,并上传到了我的github上。</p><p>以下是地址:<a href="https://github.com/pen-duo/First-DOM-Liberary">我的DOM库链接</a>.</p><p>若有收获，就点个赞吧</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2021/03/03/DOM%E8%B7%A8%E7%BA%BF%E7%A8%8B%E6%93%8D%E4%BD%9C/"/>
    <url>/2021/03/03/DOM%E8%B7%A8%E7%BA%BF%E7%A8%8B%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h1 id="DOM跨线程操作"><a href="#DOM跨线程操作" class="headerlink" title="DOM跨线程操作"></a>DOM跨线程操作</h1><h1 id="1-一个小疑问"><a href="#1-一个小疑问" class="headerlink" title="1.一个小疑问"></a>1.一个小疑问</h1><p><strong>为什么总是有人会说用DOM来操作元素会使浏览器变得很慢呢?</strong></p><p>浏览器分为渲染引擎和JS引擎,渲染引擎负责HTML和CSS的渲染,JS引擎负责对JS的解释。<br>各线程各司其职</p><p>JS只能操作JS,不能操作页面.</p><p>渲染引擎不能操作JS,只能操作页面.</p><p><strong>那么document.body.appendChild(div)是如何改变页面的呢?</strong></p><p>原因是:</p><p>跨线程通信</p><p>当浏览器发现JS在body里面加了个div对象</p><p>浏览器就会通知渲染引擎在页面也新增一个div对象</p><p>新增的div对象所有属性都照抄div对象.</p><p><strong>这就解释了为什么使用DOM操作页面会变得很慢了</strong></p><p>当我们通过DOM向页面中插入一个标签时</p><p>浏览器会发现JS的意图并通知渲染引擎进行渲染</p><p>如果我们在之后对又div进行了某些操作,可能又会导致浏览器重新渲染div。</p><h1 id="2-属性同步"><a href="#2-属性同步" class="headerlink" title="2.属性同步"></a>2.属性同步</h1><p>标准属性</p><p>对div的标准属性的修改,会被浏览器同步到页面中</p><p>比如id,className,title等</p><p>data-*属性</p><p>同上</p><p>非标准属性</p><p>对非标准属性的修改,只会停留在JS线程中</p><p>不会同步到页面里</p><p>启示</p><p>如果你有自定义属性,又想被同步到页面中,请使用data-作为前缀。</p><h1 id="3-property和attribute的区别"><a href="#3-property和attribute的区别" class="headerlink" title="3.property和attribute的区别"></a>3.property和attribute的区别</h1><p>property一般指的是元素固定的属性</p><p>比如class,id,style等</p><p>attribue一般指的是自定义的属性</p><p>property可以是任意数据类型</p><p>attribute只能是字符串</p><p>若有收获，就点个赞吧</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2021/03/03/DOM%E7%BC%96%E7%A8%8B/"/>
    <url>/2021/03/03/DOM%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="DOM编程"><a href="#DOM编程" class="headerlink" title="DOM编程"></a>DOM编程</h1><h1 id="1-DOM是什么"><a href="#1-DOM是什么" class="headerlink" title="1.DOM是什么"></a>1.DOM是什么</h1><p>文档对象模型是W3C组织推荐的处理可扩展标记语言的**标准程序接口**。简单来理解DOM就是一个<strong>可以处理文档内容的接口</strong>，DOM接口可以改变网页的内容,结构和样式。</p><h1 id="2-DOM树"><a href="#2-DOM树" class="headerlink" title="2.DOM树"></a>2.DOM树</h1><p> <img src="https%EF%BC%9A//cdn.nlark.com/yuque/0/2020/png/1554318/1607931385806-acce14e9-6360-4d73-8d7b-c25b88df49b5.png" alt="image.png" title="image.png"> </p><p>艾档</p><p>根元索：</p><p>chtml&gt;</p><p>元索：</p><p>元素：</p><body><head屏性：<p>元素：</p><p>元素：</p><p>元索：</p><p>href</p><p>ctitle</p><p>chi&gt;</p><p>Can</p><p>艾本：</p><p>文本：</p><p>艾本：</p><p>我的标题</p><p>文档标题</p><p>我的链接”</p><p>文档：一个页面就是一个文档 document</p><p>元素： 页面中所有的标签都是元素 element</p><p>节点：网页中所有的内容都是节点(标签,属性，文本，注释)DOM中用node表示</p><p><strong>DOM把以上内容都看作对象。</strong></p><p>了解了以上内容,我们可以知道,学习DOM其实就是在学习对页面中的元素，以及元素的属性,内容的增删改查。</p><h1 id="3-DOM增删改查"><a href="#3-DOM增删改查" class="headerlink" title="3.DOM增删改查"></a>3.DOM增删改查</h1><h2 id="3-1-对节点的增删改查"><a href="#3-1-对节点的增删改查" class="headerlink" title="3.1 对节点的增删改查"></a>3.1 对节点的增删改查</h2><p>1.创建节点并添加节点</p><p>创建节点</p><p>document.createElement(Tagname)//创建一个节点 Tagname表示标签名 这是动态的创建节点</p><p>创建并添加节点</p><p>假如创建了一个div元素 let div1 = document.createElement(‘div’); 我们还需要把它添加到别的元素中 document.body.appendChild(div1)添加节点(末尾) node.appendChild(child) 将一个节点添加至指定父节点的子节点列表的末尾 node.insertBefore(child,指定元素) 将一个节点添加至指定父节点的子节点列表的前面。</p><p>2.删除节点</p><p>通过父元素把自己删除</p><p>通过自己把自己删除</p><p>3.修改节点</p><p>修改属性</p><p>读取内容</p><p>修改内容</p><p>4.查</p><p>5.克隆节点</p><p>同一个节点不能再页面中出现两次</p><h2 id="3-2-对元素属性增删改查"><a href="#3-2-对元素属性增删改查" class="headerlink" title="3.2 对元素属性增删改查"></a>3.2 对元素属性增删改查</h2><p>1.增</p><p>2.删</p><p>3.改</p><p>参照上一节</p><p>4.查</p><h1 id="4-div完整原型链"><a href="#4-div完整原型链" class="headerlink" title="4.div完整原型链"></a>4.div完整原型链</h1><p> <img src="https%EF%BC%9A//cdn.nlark.com/yuque/0/2020/png/1554318/1607934224951-8385e612-dcd5-4e76-aed0-c58b3849dc72.png?x-oss-process=image/resize,w_970"> </p><ol><li><p> 第一层原型HTMLDivElement.prototype</p></li><li><p> 这里面是所有div共有的属性。</p></li><li><p> 第二层原型HTMLElement.prototype</p></li><li><p> 这里是所有HTML标签共有的属性.</p></li><li><p> 第三层原型Element.protupe</p></li><li><p> 这里是所有的XML,HTML标签的共有属性.</p></li><li><p> 第四层原型Node.prototype</p></li><li><p> 这里面是所有的节点的共有的属性,节点包括XML标签文本注释,HTML标签文本注释等</p></li><li><p> 第五层原型EventTarget.prototype</p></li><li><p> 里面最重要的函数属性是addEventListener</p></li><li><p> 最后一层原型就是Object.prototype</p></li></ol><h1 id="5-节点和元素的区别"><a href="#5-节点和元素的区别" class="headerlink" title="5.节点和元素的区别"></a>5.节点和元素的区别</h1><p>节点Node包括以下几种</p><p>1 表示元素Element,也叫标签Tag</p><p>3 表示文本Text</p><p>8 表示注释</p><p>9 表示文档</p><p>11 表示文档片段</p><p>元素是节点的一种</p><p>若有收获，就点个赞吧</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2021/03/03/JS%E5%8E%9F%E5%9E%8B%E4%B8%89%E5%A4%A7%E5%AE%9A%E7%90%86/"/>
    <url>/2021/03/03/JS%E5%8E%9F%E5%9E%8B%E4%B8%89%E5%A4%A7%E5%AE%9A%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="JS原型三大定理"><a href="#JS原型三大定理" class="headerlink" title="JS原型三大定理"></a>JS原型三大定理</h1><p>1.对象._ <em>proto_</em> = 其构造函数.prototype</p><p>2.Object.prototype是所有对象的直接或间接原型。</p><p>3.所有的函数都是由Function构造的(包括Array,Obiect,Function).</p><p>若有收获，就点个赞吧</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2021/03/03/%E5%9F%BA%E6%9C%AC%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B%E5%92%8Cnew%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
    <url>/2021/03/03/%E5%9F%BA%E6%9C%AC%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B%E5%92%8Cnew%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
    
    <content type="html"><![CDATA[<h1 id="基本包装类型和new操作符"><a href="#基本包装类型和new操作符" class="headerlink" title="基本包装类型和new操作符"></a>基本包装类型和new操作符</h1><h1 id="基本包装类型"><a href="#基本包装类型" class="headerlink" title="基本包装类型"></a>基本包装类型</h1><ul><li>  对象 才有 属性和方法 复杂数据类型才有属性和方法</li><li>  为什么 简单数据类型会有属性呢？</li><li>基本包装类型: 就是把简单数据类型 包装成了 复杂数据类型 这样基本数据类型就有了属性和方法。<br>  js中有三种基本包装类型 String,Number,Boolean</li></ul><p>var s1 = “some text”; var s2 = s1.substring(2);</p><p>对于上面的语句,实际上,后台已经自动完成了一系列的处理。</p><p>1.创建String类型的一个实例。</p><p>2.在实例上调用指定的方法。</p><p>3.销毁这个实例。</p><p>具体过程</p><p>var s1 = new String(“some text”); var s2 = s1.substring(2); s1 = null;</p><p>引用类型和基本包类型最主要的区别是对象的生命周期。</p><p>使用new操作符创建的引用类型的实例,在执行流离开当前作用域之前都一直保持在内存当中。</p><p>而自动创建的基本包装类型的对象,则只存在于一行代码的执行瞬间,然后立即被销毁。</p><h1 id="new操作符"><a href="#new操作符" class="headerlink" title="new操作符"></a>new操作符</h1><p>function Person(){</p><p>}</p><p>var person   =  new Person()</p><p>new操作符做的事</p><p>1.创建一个空对象</p><p>var obj = new Object()</p><p>2.设置原型链</p><p>obj.__proto__ = Person.prototype</p><p>3.让Person的this指向这个空对象</p><p>var result = Person.call(obj)</p><p>4.返回这个对象</p><p>若有收获，就点个赞吧</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2021/03/03/%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
    <url>/2021/03/03/%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
    
    <content type="html"><![CDATA[<h1 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h1><p>二进制运算符</p><p>或,与,否</p><p>|两个位都为0，则结果为0,否则为1</p><p>&amp;两个都为1,则结果为1,否则为0</p><p>~</p><p>异或</p><p>^</p><p>两个位相同,则结果为0,否则为1</p><p>左移右移</p><p>&lt;&lt; 和 &gt;&gt;</p><p>头部补零的右移运算符</p><p>&gt;&gt;&gt;</p><p>使用与运算符判断奇偶</p><p>代码</p><p>偶数 &amp; 1 = 0</p><p>奇数 &amp; 1 = 1</p><p>使用~,&gt;&gt;,&lt;&lt;,&gt;&gt;&gt;，|来取整</p><p>代码</p><p>console.log(~~,6.83)</p><p>console.log(6.83 &gt;&gt; 0)</p><p>console.log(6.83 &lt;&lt; 0)</p><p>console.log(6.83 | 0)</p><p>console.log(6.83 &gt;&gt;&gt; 0)</p><p>使用^来交换a,b的值</p><p>代码</p><p>var a = 5;</p><p>var b = 8;</p><p>a ^= b</p><p>b ^=a</p><p>a ^=b</p><p>console.log(a) //8</p><p>console.log(b)//5</p><p>若有收获，就点个赞吧</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2021/03/03/JS%E5%87%BD%E6%95%B0/"/>
    <url>/2021/03/03/JS%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="JS函数"><a href="#JS函数" class="headerlink" title="JS函数"></a>JS函数</h1><h1 id="函数的四种定义方式"><a href="#函数的四种定义方式" class="headerlink" title="函数的四种定义方式"></a>函数的四种定义方式</h1><h2 id="1-具名函数"><a href="#1-具名函数" class="headerlink" title="1.具名函数"></a>1.具名函数</h2><p>function 函数名(形参1,形参2){</p><p>语句</p><p>return 返回值</p><p>}</p><h2 id="2-匿名函数"><a href="#2-匿名函数" class="headerlink" title="2.匿名函数"></a>2.匿名函数</h2><p>上面的具名函数,去掉函数名就是匿名函数</p><p>let a = function(x,y){return x + y}</p><p>也叫函数表达式</p><h2 id="3-箭头函数"><a href="#3-箭头函数" class="headerlink" title="3.箭头函数"></a>3.箭头函数</h2><p>let f1 = x =&gt; x * x;</p><p>let f2 = (x,y)=&gt;{return x + y}圆括号不能省</p><p>let f3 = (x,y) =&gt; {z = x + y; return z}花括号不能省</p><p>let f4  = (x,y) =&gt; ({name：x,age：y})</p><p>直接返回对象会报错,需要加个圆括号</p><h2 id="4-用构造函数"><a href="#4-用构造函数" class="headerlink" title="4.用构造函数"></a>4.用构造函数</h2><p>let f = new Function(“x”,”y”,”return x + y”);</p><p>基本没人使用。</p><p>所有函数都是Function构造出来的。</p><p>包括Object,Array,Function也是。</p><h1 id="函数的元素"><a href="#函数的元素" class="headerlink" title="函数的元素"></a>函数的元素</h1><p>每个函数都有这些东西</p><ul><li>  调用时机</li><li>  作用域</li><li>  闭包</li><li>  形式参数</li><li>  返回值</li><li>  调用栈</li><li>  函数提升</li><li>  arguments(除了箭头函数)</li><li>  this(除了箭头函数)</li></ul><h2 id="调用时机"><a href="#调用时机" class="headerlink" title="调用时机"></a>调用时机</h2><p>let i; for(i = 0; i &lt; 6; i++){ setTimeout(()=&gt;{ console.log(i) },0) }</p><p>打印6个6</p><ul><li>  为什么打印出的是6?</li></ul><p>因为setTimeout是异步任务,必须等待同步任务执行完以后才能执行。for循环结束后,i的值为6,所以最后打印出来的是6。</p><ul><li>  为什么打印出来6个?</li></ul><p>每次执行for循环,setTimeout会被推入任务队列,总共被推入了六次,但是里面的函数不会被执行,等待for循环一结束,任务队列中的setTimeout里面的函数全部执行,所以会答应出6个6.</p><p>打印0,1,2,3,4,5</p><ul><li>  为什么打印出来的i不一样?</li></ul><p>因为for循环头部的let不仅将i绑定到for循环块中，事实上它将其重新绑定到循环体的每一次迭代中，确保上一次迭代结束的值重新被赋值,实际上这里有6个不同的i。</p><ul><li>  利用闭包打印出0,1,2,3,4,5</li></ul><p>for(var i = 0; i &lt; 6; i++){</p><p>(function(){</p><p>console.log(i)</p><p>})()</p><p>}</p><h2 id="作用域与作用域链"><a href="#作用域与作用域链" class="headerlink" title="作用域与作用域链"></a>作用域与作用域链</h2><p>JS作用域：就是代码名字(变量）在某个范围内起作用和效果。目的：提高程序的可靠性和减少命名冲突。</p><ul><li><p>  js的作用域（es6）之前：全局作用域,局部作用域。</p></li><li><p>  全局作用域：整个script的标签或则是一个单独的js文件</p></li><li><p>  局部(函数作用域：在函数内部就是局部作用域，这个代码的名字只在函数内部起作用。</p></li></ul><p>作用域链<br>内部函数访问外部函数的变量，采取的是遵从就近原则的链式查找到的方式来决定取那个值，这种结构我们称为作用域链。</p><h2 id="全局变量和局部变量"><a href="#全局变量和局部变量" class="headerlink" title="全局变量和局部变量"></a>全局变量和局部变量</h2><ul><li><p>  变量作用域的分类：根据 作用域的不同，我们变量分为全局变量和局部变量。</p></li><li><p>  全局变量：在全局作用域下的变量。可以全局使用。注意：如果在函数内部 没有声明直接赋值的变量也属于全局变量。</p></li><li><p>  局部变量： 在函数作用域下的变量。只能在函数内部使用。注意：函数的形参也可以当局部变量。</p></li><li><p>  在函数内没有声明但是赋值的变量属于全局变量。</p></li><li><p>  函数的形参属于局部变量。</p></li></ul><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>如果一个函数用到了外面的变量,那么这个函数加这个变量就叫做闭包。</p><p>闭包的主要作用<strong>：**</strong>隐藏局部变量，暴露操作函数**</p><p>1.延伸了变量的作用范围。(使得无论是函数内部的作用域还是函数外部的作用域都可以访问这个函数的局部变量)。</p><p>因为ES5中的if和for没有块级作用域,所以很多时候我们必须利用function的作用域来解实现变量的私有化。</p><p>ES6中的let解决了这个问题。</p><p>2.闭包的第二个用途是使我们在函数外部能够访问到函数内部的变量。 通过使用闭包，我们可以通过在外部调用闭包函数，从而在外部访问到函数内部的变量，可以使用这种方法来创建私有变量。</p><p>3.函数的另一个用途是使已经运行结束的函数上下文中的变量对象继续留在内存中，因为闭包函数保留了这个变量对象的引用，所以这个变量对象不会被回收。</p><p>闭包的缺点：</p><p>1.由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。</p><p>2.闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。</p><h2 id="形式参数"><a href="#形式参数" class="headerlink" title="形式参数"></a>形式参数</h2><p>就是非实际参数</p><p>其中x和y就是实际形参,因为并不是实际参数。</p><p>调用add时,1和2就是实际参数,会被赋值给x y。</p><p>形式参数可认为是变量声明</p><p>形式参数可多可少。</p><h2 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h2><ul><li>函数是处理事情的工具，需要将结果返回给函数的调用者。<br>  在我们实际开发里面，我们经常用一个变量来接受 函数的返回结果。</li><li>终止函数的功能：return 后面的代码不会被执行。<br>  return只能返回一个值，如果用逗号分开多个值，以最后一个为准。 如果想返回多个值可以利用数组。<br>  函数有retuen返回return后面的值，如果没有返回undefined。</li></ul><h2 id="调用栈"><a href="#调用栈" class="headerlink" title="调用栈"></a>调用栈</h2><h2 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a>递归函数</h2><h2 id="爆栈"><a href="#爆栈" class="headerlink" title="爆栈"></a>爆栈</h2><h2 id="预解析"><a href="#预解析" class="headerlink" title="预解析"></a>预解析</h2><ol><li>JS解析器在运行JS代码是分两步：预解析和代码执行。</li></ol><p>   * 预解析 JS引擎会把JS里面所有的var和function提升到当前作用域的最前面。</p><p>   * 代码执行 按照代码书写的顺序从上往下执行</p><p>2.  预解析分为变量预解析（变量提升）和函数预解析（函数提升）</p><p>    * 变量提升 就是把所有的变量声明提升到当前作用域的最前面 不提升赋值操作。</p><p>    * 函数提升 就是把所有的函数声明提升到当前作用域的最前面 不调用函数。</p><h2 id="arguments"><a href="#arguments" class="headerlink" title="arguments"></a>arguments</h2><ul><li>  当我们不确定有多少个参数传递的时候，可以用arguments来获取。在JS中，arguments实际上它是当前函数的一个内置对象。所有函数都内置了一个arguments对象。arguments对象中存储了传递的所有实参。</li><li>  arguments展示形式是一个伪数组。因此可以进行遍历。</li><li>  伪数组的特点：1.具有length属性。2.按索引方式存储数据。3.不具有数组的push,pop等方法。</li><li>  只有函数才有argunments,每个函数都内置了arguments.</li></ul><h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><p>如何传this</p><p>目前可以用fn.call(xxx,1,2,3)传this和arguments</p><p>而且xxx会被自动转化为对象。</p><p>如果我们相对一个还不知道名字的对象进行调用。</p><p>一：我们可以通过变量名做到。</p><p>对象</p><p>类</p><p>这种方式并不合理,尤其在类中。还没创建person对象就对其引用。</p><p>此时</p><p>我们想让函数获取对象的引用</p><p>但是并不像通过变量名做到</p><p>JS通过额外的this做到</p><p>person.sayHi()会把person自动传给sayHi,sayHi可以通过this引用person.</p><h3 id="this的两种调用"><a href="#this的两种调用" class="headerlink" title="this的两种调用"></a>this的两种调用</h3><p>小白调用法</p><p>person.sayHi()</p><p>会自动把person传到函数里,作为this</p><p>大师调用法(推荐使用)</p><p>person.sayHi.call(person)</p><p>需要自己手动把person传到函数里,作为this</p><h3 id="绑定this"><a href="#绑定this" class="headerlink" title="绑定this"></a>绑定this</h3><p>使用.bind可以让this不被改变</p><p>function f1(p1,p2){</p><p>console.log(this,p1,p2)</p><p>}</p><p>let f2 = f1.bind({name： ‘frank’})//那么f2就是f1绑定this之后的新函数</p><p>bind还可以绑定其他参数</p><p>let f3 = f1.bind({name： “frank”},”h1”)</p><p>f3()等价于f1.call({name： “frank”},hi)</p><h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><p>箭头函数里面的this就是外面一层的this</p><p>就是用call也没用。</p><h2 id="立即执行函数"><a href="#立即执行函数" class="headerlink" title="立即执行函数"></a>立即执行函数</h2><p>(function(){}) ( ),</p><p>(function(){} ()).</p><p>立即执行函数不需要特意去调用,因为它自己会调用自己。</p><p>立即执行函数最大的作用是独立的创建了一个作用域。</p><p>若有收获，就点个赞吧</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2021/03/03/JS%E6%95%B0%E7%BB%84/"/>
    <url>/2021/03/03/JS%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h1 id="JS数组"><a href="#JS数组" class="headerlink" title="JS数组"></a>JS数组</h1><h2 id="创建一个数组"><a href="#创建一个数组" class="headerlink" title="创建一个数组"></a>创建一个数组</h2><p>let arr = [1,2,3]</p><p>let arr = new Array(1,2,3)</p><p>let arr = new Array(3)</p><h2 id="转化"><a href="#转化" class="headerlink" title="转化"></a>转化</h2><p>let arr = “1,2,3”.split(“,”)</p><p>let rr = “123”.split(“”)</p><p>Array.from(“123”)</p><h2 id="伪数组"><a href="#伪数组" class="headerlink" title="伪数组"></a>伪数组</h2><p>let divList = documengt.querySelectAll(“div”);</p><p>伪数组的原型链中并没有数组的原型。</p><p>伪数组：有下标和length数组的类数组对象。</p><p>Array.from()可以将伪数组转化为数组。</p><p>伪数组没有数组原型中的共有属性。</p><h2 id="合并两个数组-得到新数组"><a href="#合并两个数组-得到新数组" class="headerlink" title="合并两个数组,得到新数组"></a>合并两个数组,得到新数组</h2><p>arr1.concat(arr2)</p><h2 id="截取一个数组的一部分"><a href="#截取一个数组的一部分" class="headerlink" title="截取一个数组的一部分"></a>截取一个数组的一部分</h2><p>arr1.slice(1)//从第二个元素开始</p><p>arr1.slice(0)//全部截取</p><p>注意,JS提供浅拷贝</p><h3 id="数组的增删改查"><a href="#数组的增删改查" class="headerlink" title="数组的增删改查"></a>数组的增删改查</h3><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>1.delete arr[0]—不要使用</p><p>不能直接对数组元素delete操作,虽然不会报错,但是即使这样做了,只是将原本的元素置空了而已,数组的长度没有发生任何变化。</p><p>2.修改arr.length</p><p>let  arr = [1,2,3,4,5];</p><p>arr.length = 1;</p><p>会变成</p><p>arr = [1];</p><p>这实在太奇怪了,所以不要随便改length。</p><p>3.使用数组API</p><p>删除头部的元素</p><p>arr.shift()</p><p>删除尾部的元素</p><p>arr.pop()</p><p>删除中间的原型</p><p>arr.splice(index,1)   //删除从第index个开始的1个元素。</p><p>arr.splice(index,1,”x”)//删除从第index个开始的1个元素并且用”x”替换。</p><p>arr.splice(index,1,”x”)//删除从第index个开始的1个元素并且用”x”，”y”替换。</p><h2 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h2><p>查看所有元素</p><p>遍历查看</p><p>1.for(let  i = 0; i &lt; arr.length; i++){</p><p>console.log(`${i}： ${arr[i]}`)</p><p>}</p><p>2.xxx.forEach(function(item,index){</p><p>console.log(`${index}： ${item}`)</p><p>})</p><p>查看单个元素</p><p>1.使用下标查看</p><p>arr[0]</p><p>2.索引越界</p><p>arr[arr.length] === undefined</p><p>arr[-1] === undefined</p><p>3.查看某个元素是否在数组里</p><p>arr.indexOf(item) //存在返回索引,否则返回-1</p><p>使用条件查找元素</p><p>arr.find(item =&gt; item % 2 === 0) //找第一个偶数</p><p>使用条件查找元素的索引</p><p>arr.findIndex(item =&gt; item % 2 === 0) // 找第一个偶数的索引</p><h2 id="增加"><a href="#增加" class="headerlink" title="增加"></a>增加</h2><p>在尾部加元素</p><p>arr.push(newitem) // 修改arr,返回新长度</p><p>arr.push(item1,item2)//修改arr,返回新长度</p><p>在头部加元素</p><p>arr.unshift(newitem) // 修改arr,返回新长度</p><p>arr.unshift(newitem1,newitem2) // 修改arr,返回新长度</p><p>在中间添加元素</p><p>arr.splice(index,0,”x”) //在index处插入”x”</p><p>arr.splice(index,0,”x”,”y”)//返回由被删除的元素组成的一个数组</p><h2 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h2><p>反转数组</p><p>arr.reverse() // 修改原数组,返回颠倒后的数组</p><p>自定义顺序</p><p>arr.sort((a,b) =&gt; a-b) 升序</p><p>arr.sort((a,b) =&gt; b-a) 将序</p><p>返回排序后的数组</p><p>let scores = [95,91,59,55,42,82,72,85,67,66,55,91]</p><p>let scores2 = scores.filter((item)=&gt;item&gt;60)</p><p>console.log(scores2) //  [95,91,82,72,85,67,66, 91]</p><p>若有收获，就点个赞吧</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2021/03/03/JS%E5%AF%B9%E8%B1%A1%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/"/>
    <url>/2021/03/03/JS%E5%AF%B9%E8%B1%A1%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="JS对象基本用法"><a href="#JS对象基本用法" class="headerlink" title="JS对象基本用法"></a>JS对象基本用法</h1><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>无序的数据集合</p><p>键值对的数据集合</p><h1 id="写法"><a href="#写法" class="headerlink" title="写法"></a>写法</h1><p>let obj = {“name”： “彭一多”,”age”：18}</p><p>let obj = new Object({“name”： “彭一多”,”age”：18})</p><h1 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h1><p>键名是字符串,不是标识符,可以包含任意字符。</p><h1 id="属性名"><a href="#属性名" class="headerlink" title="属性名"></a>属性名</h1><p>所有奇怪的属性名会自动变成字符串</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs dart">let obj = &#123;<br><br><span class="hljs-number">1</span>： <span class="hljs-string">&#x27;a&#x27;</span>,<br><br><span class="hljs-number">3.2</span>： <span class="hljs-string">&#x27;b&#x27;</span>,<br><br><span class="hljs-number">1e2</span>： <span class="hljs-keyword">true</span>,<br><br><span class="hljs-number">1e-2</span>： <span class="hljs-keyword">true</span>,<br><br><span class="hljs-number">.234</span>：<span class="hljs-keyword">true</span>,<br><br><span class="hljs-number">0xFF</span>： <span class="hljs-keyword">true</span><br><br>&#125;;<br><br><span class="hljs-built_in">Object</span>.keys(obj)<br><br>\=&gt;\[<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;100&quot;</span>,<span class="hljs-string">&quot;255&quot;</span>,<span class="hljs-string">&quot;3.2&quot;</span>,<span class="hljs-string">&quot;0.01&quot;</span>,<span class="hljs-string">&quot;0.234&quot;</span>\]<br></code></pre></td></tr></table></figure><h2 id="细节-1"><a href="#细节-1" class="headerlink" title="细节"></a>细节</h2><p>Object.keys(obj)可以得到obj的所有key.</p><h2 id="变量作属性名"><a href="#变量作属性名" class="headerlink" title="变量作属性名"></a>变量作属性名</h2><p>如何用变量作属性名</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs nix"><span class="hljs-keyword">let</span> <span class="hljs-attr">p1</span> = <span class="hljs-string">&quot;name&quot;</span><br><br><span class="hljs-keyword">let</span> <span class="hljs-attr">obj</span> = &#123;p1：<span class="hljs-string">&quot;peng&quot;</span>&#125;这样写,属性名为<span class="hljs-string">&quot;p1&quot;</span><br><br><span class="hljs-keyword">let</span> <span class="hljs-attr">obj</span> = &#123;\[p1\]：<span class="hljs-string">&quot;peng&quot;</span>&#125;这样写,属性名为name<br></code></pre></td></tr></table></figure><h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><p>不加[]的属性名会自动变成字符串</p><p>加了[]则会变成变量求值</p><p>值如果不是字符串,则会自动变成字符串。</p><p>对象的隐藏属性：__proto__</p><p>JS中每一个对象都有一个隐藏属性指向原型对象。</p><h1 id="对象属性的增删改查"><a href="#对象属性的增删改查" class="headerlink" title="对象属性的增删改查"></a>对象属性的增删改查</h1><h2 id="删除属性"><a href="#删除属性" class="headerlink" title="删除属性"></a>删除属性</h2><p>delete obj.xxx或delete obj[‘xxx’]</p><p>即可删除obj的xxx属性</p><p>请区分 属性值为undefined 和 不含属性名</p><h3 id="不含属性名"><a href="#不含属性名" class="headerlink" title="不含属性名"></a>不含属性名</h3><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nix"><span class="hljs-string">&quot;xxx&quot;</span> <span class="hljs-keyword">in</span> <span class="hljs-attr">obj</span>  === <span class="hljs-literal">false</span>;<br></code></pre></td></tr></table></figure><h3 id="含有属性名-但是值为undefined"><a href="#含有属性名-但是值为undefined" class="headerlink" title="含有属性名,但是值为undefined"></a>含有属性名,但是值为undefined</h3><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-string">&quot;xxx&quot;</span> <span class="hljs-keyword">in</span> obj &amp;&amp; obj.xxx === un<span class="hljs-function"><span class="hljs-keyword">def</span><span class="hljs-title">ined</span></span><br></code></pre></td></tr></table></figure><p>注意obj.xxx === undefined不能判断”xxx”是否为obj的属性</p><h2 id="查看所有属性"><a href="#查看所有属性" class="headerlink" title="查看所有属性"></a>查看所有属性</h2><h3 id="查看自身所有属性"><a href="#查看自身所有属性" class="headerlink" title="查看自身所有属性"></a>查看自身所有属性</h3><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Object</span>.</span></span>keys(obj)<br></code></pre></td></tr></table></figure><h3 id="查看自身-共有属性"><a href="#查看自身-共有属性" class="headerlink" title="查看自身+共有属性"></a>查看自身+共有属性</h3><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">console</span>.dir(obj)<br></code></pre></td></tr></table></figure><p>判断一个属性是自身的还是共有的</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">obj</span><span class="hljs-selector-class">.hasOwnProperty</span>(<span class="hljs-string">&quot;toString&quot;</span>)。<br></code></pre></td></tr></table></figure><h3 id="查看属性值"><a href="#查看属性值" class="headerlink" title="查看属性值"></a>查看属性值</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">Object</span>.<span class="hljs-keyword">values</span>(obj)<br></code></pre></td></tr></table></figure><p>先判断一个属性是否存在自身或原型中,再判断这个属性具体在哪</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-string">&quot;xxx&quot;</span> <span class="hljs-keyword">in</span> obj<span class="hljs-operator"> &amp;&amp; </span>obj.has<span class="hljs-constructor">OwnProperty(<span class="hljs-string">&quot;xxx&quot;</span>)</span>;<br></code></pre></td></tr></table></figure><h3 id="查看单个属性"><a href="#查看单个属性" class="headerlink" title="查看单个属性"></a>查看单个属性</h3><p>中括号语法： obj[“key”]</p><p>点语法：obj.key</p><p>注意： obj[key] !== obj[‘key’]   // key是个变量,”key”是个常量</p><p>obj.name = obj[‘name’]</p><h2 id="修改或增加属性"><a href="#修改或增加属性" class="headerlink" title="修改或增加属性"></a>修改或增加属性</h2><h3 id="直接赋值"><a href="#直接赋值" class="headerlink" title="直接赋值"></a>直接赋值</h3><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs nix"><span class="hljs-attr">let</span> = &#123;<span class="hljs-string">&quot;name&quot;</span>： <span class="hljs-string">&quot;frank&quot;</span>&#125;<br><br>obj.<span class="hljs-attr">name</span> = <span class="hljs-string">&quot;frank&quot;</span><br><br>obj\[<span class="hljs-string">&quot;age&quot;</span>\] = <span class="hljs-number">18</span><br></code></pre></td></tr></table></figure><p>使用点语法,或则中括号语法直接赋值</p><h3 id="批量赋值"><a href="#批量赋值" class="headerlink" title="批量赋值"></a>批量赋值</h3><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Object</span>.</span></span>assign(obj,&#123;age：<span class="hljs-number">18</span>,gender：<span class="hljs-string">&quot;man&quot;</span>&#125;);<br></code></pre></td></tr></table></figure><p>第一个参数被赋值。</p><h3 id="修改或增加共有属性"><a href="#修改或增加共有属性" class="headerlink" title="修改或增加共有属性"></a>修改或增加共有属性</h3><p>无法通过自身修改或增加共有属性</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs nix"><span class="hljs-keyword">let</span> <span class="hljs-attr">obj</span> = &#123;&#125;, <span class="hljs-attr">obj2</span> = &#123;&#125;共有<span class="hljs-built_in">toString</span><br><br>obj.<span class="hljs-attr">toString</span> = <span class="hljs-string">&quot;xxx&quot;</span>只会在改obj自身属性<br><br>obj2.<span class="hljs-built_in">toString</span>还是在原型上<br></code></pre></td></tr></table></figure><h3 id="一定要修改或增加原型上的属性"><a href="#一定要修改或增加原型上的属性" class="headerlink" title="一定要修改或增加原型上的属性"></a>一定要修改或增加原型上的属性</h3><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">obj.\_\_proto\_\<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">_</span>.</span></span>toString = <span class="hljs-string">&quot;xxx&quot;</span> <span class="hljs-comment">// 不推荐</span><br><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Object</span>.</span></span>prototype.toString = <span class="hljs-string">&quot;xxx&quot;</span><br></code></pre></td></tr></table></figure><p>一般来说,不要修改原型,会引起很多问题。</p><h3 id="修改隐藏属性"><a href="#修改隐藏属性" class="headerlink" title="修改隐藏属性"></a>修改隐藏属性</h3><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs maxima">不推荐使用\<span class="hljs-symbol">_</span>\_ptoto\<span class="hljs-symbol">_</span>\<span class="hljs-symbol">_</span><br><br><span class="hljs-built_in">let</span> obj = &#123;name： <span class="hljs-string">&quot;peng&quot;</span>&#125;<br><br><span class="hljs-built_in">let</span> obj2 = &#123;name： <span class="hljs-string">&quot;jack&quot;</span>&#125;<br><br><span class="hljs-built_in">let</span> common = &#123;kind： <span class="hljs-string">&quot;jack&quot;</span>&#125;<br><br>obj.\<span class="hljs-symbol">_</span> proto\<span class="hljs-symbol">_</span> = common<br><br>obj2.\<span class="hljs-symbol">_</span> proto\<span class="hljs-symbol">_</span> = common<br></code></pre></td></tr></table></figure><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">推荐使用<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Object</span>.</span></span>create<br><br><span class="hljs-keyword">let</span> obj = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Objec</span>.</span></span>create(common)<br><br>obj.name = <span class="hljs-string">&quot;peng&quot;</span><br><br><span class="hljs-keyword">let</span>  obj2 = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Object</span>.</span></span>create(common)<br><br>obj2.name = <span class="hljs-string">&quot;jack&quot;</span><br></code></pre></td></tr></table></figure><p>“name” in obj 和 obj.hasOwnProperty(“name”)的区别</p><p>“name” in obj 表示的是”name”可能在obj也有可能在obj的原型中</p><p>obj.hasOwnProperty(“name”)表示的是”name”在obj中。</p><p>若有收获，就点个赞吧</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2021/03/03/JS%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <url>/2021/03/03/JS%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h1 id="JS数据类型"><a href="#JS数据类型" class="headerlink" title="JS数据类型"></a>JS数据类型</h1><h2 id="七种数据类型"><a href="#七种数据类型" class="headerlink" title="七种数据类型"></a>七种数据类型</h2><p>四基两空一对象<br>四基:</p><ol><li>数字(Number)</li><li>字符串(String)</li><li>布尔值(boolean)</li><li>symble<br>两空:</li><li>Null</li><li>undefined<br>一对象:</li><li>Object<br>a. Array<br>b. Function<br>c. Date<br>d. ……</li></ol><h2 id="1-数字–Number"><a href="#1-数字–Number" class="headerlink" title="1.数字–Number"></a>1.数字–Number</h2><h3 id="写法"><a href="#写法" class="headerlink" title="写法"></a>写法</h3><ul><li>整数写法–1</li><li>小数写法–0.1</li><li>科学计数法</li><li>1.23e4</li><li>八进制写法(0123或00123或0o123)</li><li>十六进制写法(0x3F或0X3F)</li><li>二进制写法(0b11或0B11)</li></ul><h3 id="特殊值"><a href="#特殊值" class="headerlink" title="特殊值"></a>特殊值</h3><ul><li>正0和负0–都等于0,但是当+0/infinity 结果是infinity 当-0/infinity 结果是 -infinity</li><li>NaN–无法表示的数字<ul><li>但它是一个数字(一个目前还不知道是什么数字的数字)</li></ul></li></ul><h3 id="数字的范围"><a href="#数字的范围" class="headerlink" title="数字的范围"></a>数字的范围</h3><p>Number.MAX_VALUE ~ Number.MIN_VALUE</p><h3 id="数字的精度"><a href="#数字的精度" class="headerlink" title="数字的精度"></a>数字的精度</h3><p>15位有效数字都能精确表示<br>16位有效数字如果小于90开头,也能精确表示</p><h2 id="2-字符串–String"><a href="#2-字符串–String" class="headerlink" title="2.字符串–String"></a>2.字符串–String</h2><h3 id="写法-1"><a href="#写法-1" class="headerlink" title="写法"></a>写法</h3><ul><li>单引号 <ul><li>‘你好’</li></ul></li><li>双引号<ul><li>“你好”</li></ul></li><li>反引号<ul><li><code>你好</code><br>注意:引号不属于字符串的一部分。<br>如果想要在单引号中包含单引号:</li></ul></li></ul><p>1.使用转义字符/<br>‘it&#39;s ok’<br>2.使用反引号<br><code>it&#39;s ok</code></p><h3 id="转义"><a href="#转义" class="headerlink" title="转义"></a>转义</h3><p>–用另一种写法表示你想要的东西<br>&#39;表示’<br>&quot;表示”<br>\n表示回车<br>\r表示tab制表符<br>\表示<br>\a\b\c.length 的长度为3<br>\\\的长度为3.<br>“ “的长度为1</p><h3 id="多行字符串"><a href="#多行字符串" class="headerlink" title="多行字符串"></a>多行字符串</h3><p>如果想要在字符串中回车<br>let s = <code>这样是 可以的 用反引号很容易做到</code><br>以前没有反引号的时候很麻烦,详情请参考：网道教程。</p><h3 id="字符串的属性"><a href="#字符串的属性" class="headerlink" title="字符串的属性"></a>字符串的属性</h3><p>为什么字符串也会有属性:基本包装类型。<br>字符串的长度:length.<br>通过下标读取字符:”apple”[0] === “a”;</p><h3 id="base64转义码"><a href="#base64转义码" class="headerlink" title="base64转义码"></a>base64转义码</h3><p>window.btoa<br>正常字符串转为Base64编码的字符串<br>window.atob<br>Base64编码的字符串转为原理的字符串。<br>作用:一般用来隐藏招聘启事里的简历。</p><h2 id="3-布尔值–Boolean"><a href="#3-布尔值–Boolean" class="headerlink" title="3.布尔值–Boolean"></a>3.布尔值–Boolean</h2><p>只有两个值true和false<br>下列运算符会得到bool值<br>否定运算<br>!value<br>相等运算<br>1==2,1!=2,3===4,3!==4<br>比较运算1&gt;2,1&gt;=2,3&lt;4,3&lt;=4<br>if搭配bool值<br>if(value){…}else{…}<br>除了0,””或则’’,false,undefined,null,NaN这几个有false的意思以外,其他都为true.</p><h2 id="4-null和undefined"><a href="#4-null和undefined" class="headerlink" title="4.null和undefined"></a>4.null和undefined</h2><p>没有本质之处<br>细节一:<br>如果一个变量被声明了但是没有赋值,这个变量默认为undefined.<br>细节二:<br>如果一个函数,没有写return,或则,return后面为空,默认返回undefined。<br>细节三:<br>前端程序员习惯上,把非对象的空值写成undefined,把对象的空值写成null。</p><h2 id="5-Symbol"><a href="#5-Symbol" class="headerlink" title="5.Symbol"></a>5.Symbol</h2><p>Symbol 生成一个全局唯一的值。</p><h2 id="三种声明方式"><a href="#三种声明方式" class="headerlink" title="三种声明方式"></a>三种声明方式</h2><p>var let和const的区别<br>var<br>      1. var 可以重复声明<br>      2.作用域:全局作用域和函数作用域<br>      3.会进行预解析<br>let<br>let只在let命令所在的代码块内有效<br>       1.统一作用域下不能重复声明<br>       2.作用域:全局作用域和块级作用域。<br>       3.不会进行预解析<br>       4.可以再次赋值<br>const<br>       1.用来声明常量<br>       2.不能重复声明,并且声明了一定要赋值<br>       3.const不会被预解析<br>       4.只能赋值一次。</p><p> let,const不能重复声明,有块级作用域,不会进行预解析。<br> const不能重复赋值,必须立马赋值。<br> 常量的含义是指向的对象不能修改,对象的属性可以修改。</p><h2 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h2><p>x–&gt;字符串型</p><ul><li>String(x)</li><li>x.toString()   注意: 数字.toString会报错,因为浏览器默认1.后面应该加数字。<br>字符串型–&gt;数字型</li><li>Number(str)</li><li>parseInt(str,几进制)转换为正数,可以指定转换为几进制,默认10进制</li><li>用+隐式转换<br>x–&gt;布尔值</li><li>Boolean(x)</li><li>!!x<br>六个falsy值<br>两个数字:0,NaN<br>两空:null,undefined<br>一个空字符串:’ ‘<br>一个特殊的接口:document.all()</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2021/03/03/JS%E5%8E%86%E5%8F%B2/"/>
    <url>/2021/03/03/JS%E5%8E%86%E5%8F%B2/</url>
    
    <content type="html"><![CDATA[<h1 id="JS历史"><a href="#JS历史" class="headerlink" title="JS历史"></a>JS历史</h1><p>　　<strong>js的历史</strong></p><p>　　在上个世纪的1995年，当时的网景公司正凭借其Navigator浏览器成为Web时×××启时最著名的第一代互联网公司。</p><p>　　由于网景公司希望能在静态HTML页面上添加一些动态效果，于是叫Brendan Eich这哥们在两周之内设计出了JavaScript语言。你没看错，这哥们只用了10天时间。</p><p>　　为什么起名叫JavaScript?原因是当时Java语言非常红火，所以网景公司希望借Java的名气来推广，但事实上JavaScript除了语法上有点像Java，其他部分基本上没啥关系。</p><p>　　<strong>JavaScript版本兼容性</strong></p><p>　　JavaScript语言是在10天时间内设计出来的，虽然语言的设计者水平非常NB，但谁也架不住“时间紧，任务重”，所以，JavaScript有很多设计缺陷，我们后面会慢慢讲到。</p><p>　　此外，由于JavaScript的标准——ECMAScript在不断发展，最新版ECMAScript 6标准(简称ES6)已经在2015年6月正式发布了，所以，讲到JavaScript的版本，实际上就是说它实现了ECMAScript标准的哪个版本。</p><p>　　由于浏览器在发布时就确定了JavaScript的版本，加上很多用户还在使用IE6这种古老的浏览器，这就导致你在写JavaScript的时候，要照顾一下老用户，不能一上来就用最新的ES6标准写，否则，老用户的浏览器是无法运行新版本的JavaScript代码的。</p><p>　　<strong>js的组成</strong></p><p>　　ECMAScript</p><p>　　ECMAScript是一个标准。</p><p>　　因为网景开发了JavaScript，一年后微软又模仿JavaScript开发了JScript，为了让JavaScript成为全球标准，几个公司联合ECMA(European Computer Manufacturers Association)组织定制了JavaScript语言的标准，被称为ECMAScript标准。</p><p>　　所以简单说来就是，ECMAScript是一种语言标准，而JavaScript是网景公司对ECMAScript标准的一种实现。</p><p>　　那为什么不直接把JavaScript定为标准呢?因为JavaScript是网景的注册商标。</p><p>　　不过大多数时候，我们还是用JavaScript这个词。如果你遇到ECMAScript这个词，简单把它替换为JavaScript就行了。</p><p>　　<strong>DOM</strong></p><p>　　DOM:Document Object Model。文档对象模型，后边我们会有专门的课程来讲解DOM操作</p><p>　**　BOM**</p><p>　　BOM:Browser Object Model。浏览器对象模型，后边我们也会专门来讲bom操作</p><p>**　　JavaScript的特点**</p><p>　　(1)、一种解释性执行的脚本语言。</p><p>　　同其他脚本语言一样，JavaScript也是一种解释性语言，其提供了一个非常方便的开发过程。JavaScript的语法基本结构形式与C、C++、Java十分类似。但在使用前，不像这些语言需要先编译，而是在程序运行过程中被逐行地解释。JavaScript与HTML标识结合在一起，从而方便用户的使用操作。</p><p>　　(2)、一种基于对象的脚本语言。</p><p>　　其也可以被看作是一种面向对象的语言，这意味着JavaScript能运用其已经创建的对象。因此，许多功能可以来自于脚本环境中对象的方法与脚本的相互作用。</p><p>　　(3)、一种简单弱类型脚本语言。</p><p>　　其简单性主要体现在：首先，JavaScript是一种基于Java基本语句和控制流之上的简单而紧凑的设计，从而对于使用者学习Java或其他C语系的编程语言是一种非常好的过渡，而对于具有C语系编程功底的程序员来说，JavaScript上手也非常容易;其次，其变量类型是采用弱类型，并未使用严格的数据类型。</p><p>　　(4)、一种相对安全脚本语言。</p><p>　　JavaScript作为一种安全性语言，不被允许访问本地的硬盘，且不能将数据存入服务器，不允许对网络文档进行修改和删除，只能通过浏览器实现信息浏览或动态交互。从而有效地防止数据的丢失或对系统的非法访问。</p><p>　　(5)、一种事件驱动脚本语言。</p><p>　　JavaScript对用户的响应，是以事件驱动的方式进行的。在网页(Web Page)中执行了某种操作所产生的动作，被称为“事件”(Event)。例如按下鼠标、移动窗口、选择菜单等都可以被视为事件。当事件发生后，可能会引起相应的事件响应，执行某些对应的脚本，这种机制被称为“事件驱动”。</p><p>　　(6)、一种跨平台性脚本语言。</p><p>　　JavaScript依赖于浏览器本身，与操作环境无关，只要计算机能运行浏览器，并支持JavaScript的浏览器，就可正确执行，从而实现了“编写一次，走遍天下”的梦想。</p><p>　　因此，JavaScript是一种新的描述语言，其可以被嵌入到HTML文件中。JavaScript语言可以做到响应使用者的需求事件(例如表单的输入)，而不需要任何的网络来回传输资料。所以当一位使用者输入一项资料时，此资料数据不用经过传给服务器(server)处理再传回来的过程，而直接可以被客户端(client)的应用程序所处理。</p><p>**　　JavaScript的优缺点**</p><p>　　(1)、JavaScript的优点：</p><p>　　&lt;1&gt;.JavaScript减少网络传输。</p><p>　　在JavaScript这样的用户端脚本语言出现之前，传统的数据提交和验证工作均由用户端浏览器通过网络传输到服务器上进行。如果数据量很大，这对于网络和服务器的资源来说实在是一种无形的浪费。而使用JavaScript就可以在客户端进行数据验证。</p><p>　　&lt;2&gt;.JavaScript方便操纵HTML对象。</p><p>　　JavaScript可以方便地操纵各种页面中的对象，用户可以使用JavaScript来控制页面中各个元素的外观、状态甚至运行方式，JavaScript可以根据用户的需要“定制”浏览器，从而使网页更加友好。</p><p>　　&lt;3&gt;.JavaScript支持分布式运算。</p><p>　　JavaScript可以使多种任务仅在用户端就可以完成，而不需要网络和服务器的参与，从而支持分布式的运算和处理。</p><p>　　(2)、JavaScript的局限性：</p><p>　　&lt;1&gt;.各浏览器厂商对JavaScript支持程度不同。</p><p>　　目前在互联网上有很多浏览器，如Firefox、Internet Explorer、Opera等，但每种浏览器支持JavaScript的程度是不一样的，不同的浏览器在浏览一个带有JavaScript脚本的主页时，由于对JavaScript的支持稍有不同，其效果会有一定的差距，有时甚至会显示不出来。</p><p>　　&lt;2&gt;.“Web安全性”对JavaScript一些功能牺牲。</p><p>　　当把JavaScript的一个设计目标设定为“Web安全性”时，就需要牺牲JavaScript的一些功能。因此，纯粹的JavaScript将不能打开、读写和保存用户计算机上的文件。其有权访问的唯一信息就是该JavaScript所嵌入的那个Web主页中的信息，简言之，JavaScript将只存在于它自己的小小世界—Web主页里。</p><p>若有收获，就点个赞吧</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2021/03/03/JS%E8%AF%AD%E6%B3%95/"/>
    <url>/2021/03/03/JS%E8%AF%AD%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="JS语法"><a href="#JS语法" class="headerlink" title="JS语法"></a>JS语法</h1><h1 id="1-语句"><a href="#1-语句" class="headerlink" title="1.语句"></a>1.语句</h1><p>JavaScript 程序的执行单位为行（line），也就是一行一行地执行。一般情况下，每一行就是一个<strong>语句</strong>。</p><p>比如</p><p>var a = 1;</p><p>表达式（expression），指一个为了得到返回值的计算式</p><p>比如  </p><p> 1 + 3</p><p>两者的区别<br>前者主要为了进行某种操作，一般情况下不需要返回值；后者则是为了得到返回值，一定会返回一个值。</p><p>注意</p><p>表达式不需要分号结尾。一旦在表达式后面添加分号，则 JavaScript 引擎就将表达式视为语句，这样会产生一些没有任何意义的语句.</p><h1 id="2-大小写敏感"><a href="#2-大小写敏感" class="headerlink" title="2.大小写敏感"></a>2.大小写敏感</h1><p>比如</p><p>var a; var A;</p><p>上面两个变量是完全不同的两个变量。</p><p>值得注意的还有</p><p>object和Object</p><p>function和Function</p><h1 id="3-空格与回车"><a href="#3-空格与回车" class="headerlink" title="3.空格与回车"></a>3.空格与回车</h1><p>在大部分时候加空格和回车是没有任何意义的,也不会产生任何影响,但是!!!</p><p>值得注意的是</p><p>不能再return 后面加回车(否则会返回undefined).</p><p>function person(){ return     1; } console.log(person())//undefined</p><h1 id="4-标识符"><a href="#4-标识符" class="headerlink" title="4.标识符"></a>4.标识符</h1><p>第一个字符可以是Unicode字母,中文,下划线,$符。</p><p>注意标识符开头不能是数字,标识符也不能是关键字或保留字。</p><h1 id="5-注释"><a href="#5-注释" class="headerlink" title="5.注释"></a>5.注释</h1><p>HTML中的注释&lt;!–&gt;&lt;–&gt;</p><p>CSS中的注释/*  */<br>JS中的单行注释//</p><p>多行注释/*  */</p><p>同时JS也兼容HTML的注释</p><h2 id="注释的分类"><a href="#注释的分类" class="headerlink" title="注释的分类"></a>注释的分类</h2><h3 id="不好的注释"><a href="#不好的注释" class="headerlink" title="不好的注释"></a>不好的注释</h3><p>把代码翻译成中文</p><p>过时的注释</p><p>发泄不满的注释</p><h3 id="好的注释"><a href="#好的注释" class="headerlink" title="好的注释"></a>好的注释</h3><p>踩坑注释</p><p>为什么代码会写得这么奇怪,遇到了什么bug</p><h1 id="6-区块"><a href="#6-区块" class="headerlink" title="6.区块"></a>6.区块</h1><p>把代码包含在一块</p><p>{</p><p>var a = 1;</p><p>var b = 8;</p><p>}</p><p>一般与if,for,while等一起用</p><h1 id="7-if语句"><a href="#7-if语句" class="headerlink" title="7.if语句"></a>7.if语句</h1><p>语法</p><p>if(表达式){语句1}else{语句2}</p><p>{}在语句只有一句的时候可以省略,不建议这样做。</p><p>变态情况</p><p>1.</p><p>最后打印的结果会是    a是1。</p><p>因为在if ( )的判断中,如果括号中是true,它就会执行下面区块包含的语句。</p><p>而 () 一般情况下 只有不是 null ,false, 0 ,’’或含有否定意思的语句都会默认为true</p><p>解决方法</p><p>把 a = 1 写成 a === 1;这也是我们以后编程中始终要坚持养成的习惯。</p><h1 id="8-程序员最戒律二"><a href="#8-程序员最戒律二" class="headerlink" title="8.程序员最戒律二"></a>8.程序员最戒律二</h1><p>使用最没有歧义的写法。</p><h1 id="9-switch语句"><a href="#9-switch语句" class="headerlink" title="9.switch语句"></a>9.switch语句</h1><p>大部分是否不能省略break;</p><p>当多个执行条件的执行代码是一样的时候,可以适当省略。</p><h1 id="10-三元表达式"><a href="#10-三元表达式" class="headerlink" title="10.三元表达式"></a>10.三元表达式</h1><p>if(a &gt; b) {</p><p>console.log(“哈哈哈哈”);<br>} else {</p><p>console.log(“嘻嘻嘻嘻”);</p><p>}</p><p>可以写成</p><p>a &gt; b ? console.log(“哈哈哈哈”)  console.log(“嘻嘻嘻嘻”)。</p><h1 id="11-或-与-非"><a href="#11-或-与-非" class="headerlink" title="11.或,与,非"></a>11.或,与,非</h1><p>II 或</p><p>&amp;&amp; 与</p><p>! 非</p><p>或,与 按短路逻辑执行</p><p>或 从左到右判断时,遇到true就直接返回true,否则返回false.</p><p>与 从左到右判断时,遇到false就直接返回false,否则返回true.</p><h1 id="12-while"><a href="#12-while" class="headerlink" title="12.while"></a>12.while</h1><p>while(表达式){语句}</p><p>判断表达式的正价</p><p>当表达式为真,执行语句,执行完在判断表达式</p><p>当表达式为假,跳过循环,执行后面的语句。</p><h1 id="13-for循环"><a href="#13-for循环" class="headerlink" title="13.for循环"></a>13.for循环</h1><p>for(变量初始化,中止条件,增量) {</p><p>循环体</p><p>}</p><p>先执行语句1</p><p>然后判断表达式2,</p><p>如果为真,执行循环体,然后执行语句3</p><p>如果为假,直接退出循环,执行后面的语句</p><h1 id="14-break和return"><a href="#14-break和return" class="headerlink" title="14.break和return"></a>14.break和return</h1><p>break退出所有循环</p><p>continue退出本次循环</p><h1 id="15-label"><a href="#15-label" class="headerlink" title="15.label"></a>15.label</h1><p>面试</p><p>{</p><p>foo 1</p><p>}</p><p>上面的东西是什么</p><p>回答</p><p>是一个label语句,语句就是个1.</p><p>若有收获，就点个赞吧</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2021/03/03/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    <url>/2021/03/03/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="原型与原型链"><a href="#原型与原型链" class="headerlink" title="原型与原型链"></a>原型与原型链</h1><h4 id="构造函数创建对象"><a href="#构造函数创建对象" class="headerlink" title="构造函数创建对象"></a>构造函数创建对象</h4><p>ES6之前, 面向对象是通过构造函数来实现的，因为我们的公共方法都是放在构造函数里面的,这个会导致产生一个问题,每实例化一个对象,构造函数会为这个方法重新开辟一块内存空间,比较浪费内存。</p><p>为了解决这个问题,我们把这些公共的方法定义到<strong>原型对象</strong>身上,所有的构造函数都有一个prototype属性.指向另一个对象，注意这个prototype就是一个对象,这个对象的所有属性和方法,都会被构造函数所拥有。</p><p>原型对象prototype是每个构造函数都拥有的属性,这个属性是一个指针，指向一个对象，而这个对象的用途是包含有特定类型的所有实例共享的属性和方法。</p><p>一般情况下,我们的公共属性定义到构造函数中,公共方法定义到原型对象中</p><p>对象原型__<strong>proto__</strong>是所有对象都会有的一个属性指向构造函数的prototype原型对象。之所以我们对象可以使用构造函数prototype原型对象的属性和方法,就是因为对象有__proto__原型的存在</p><p> <img src="https://cdn.nlark.com/yuque/0/2020/png/1554318/1606995509071-b7d29f57-70af-4b3d-8e3e-a0c098689aff.png" alt="image.png" title="image.png"> </p><p>Star.prototype</p><p>Star原型对象</p><p>Star构造函</p><p>数</p><p>prototype(存放sing)</p><p>Ldh.</p><p>proto</p><p>ldh对象实例</p><h4 id="constructor构造函数"><a href="#constructor构造函数" class="headerlink" title="constructor构造函数"></a>constructor构造函数</h4><p>对象原型 (<strong>proto</strong> )和构造函数原型对象(prototype)里面都有一个constuctor属性,constructor我们称为构造函数，因为它指向构造函数本身。</p><p>constructor主要用于记录该对象引用于哪个构造函数,它可以让原型对象重新指向原来的构造函数。</p><p>原型对象和对象原型的相同区别:</p><p>对象原型是实例的一个属性,是一个指向原型对象的指针。</p><p>原型对象是构造函数的一个属性,也是一个指针,指向一个对象,里面存放着所有由这个构造函数创建的实例都可以调用的公共方法。</p><p>实例的对象原型实际上等于构造函数的原型对象。</p><p>用代码写出来是这样的:</p><p>o是Star的实例</p><p>o.<strong>proto</strong> === Star.prototype;</p><p>constructor是对象原型和原型对象都拥有的一个属性,</p><p>构造函数可以通过prototype指向原型对象,</p><p>实例可以通过__proto指向原型对象。</p><p>原型对象,对象原型可以通过constructor指向其引用的构造函数。</p><p>constructor最重要的作用是让原型对象重新指向原来的构造函数。</p><p>如果将本应该写在构造函数中的大量公共方法抽取出来放在对象原型中,这时,原本的原型对象会被存放大量方法的新对象覆盖,这时,原型对象中的constructor也会被覆盖不指向原型对象指向的构造函数,为了解决这一问题,</p><p>我们可以在原型对象中重新书写这一值为我们的原型对象引用的构造函数。</p><p>每个函数都有一个prototypr,即显式原型属性,每个实例对象都有一个__<strong>proto__</strong>,可称为隐式原型(属性)。</p><p>总结：函数的prototype属性:在定义函数时自动添加的,默认值是一个空object对象。</p><p>对象的<strong>proto</strong>属性：创建对象时自动添加的,默认值为构造函数的prototypr属性值。</p><p>程序员能直接操作显示原型但是不能直接操作隐式原型(es6之前)</p><p><strong>构造函数,原型对象,实例三种关系如图</strong></p><p> <img src="https://cdn.nlark.com/yuque/0/2020/png/1554318/1606995536638-25eed3a9-39ed-4f21-97d6-825a5d1c6ff2.png" alt="image.png" title="image.png"> </p><p>Star.prototype</p><p>Star原型对象</p><p>star构造函数</p><p>prototype</p><p>Star.prototype.constructor</p><p>ldh.</p><p>proto</p><p>Idh对象实例</p><p>ldh.</p><p>.proto.constructor</p><h4 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h4><p>上述代码中有一个构造函数Star,一个Star的实例ldh.</p><p>ldh对象原型是Star的原型对象,所以打印ldh. <strong>proto</strong> 会输出</p><p>constrcuot:Star;</p><p><strong>proto</strong> :Object;</p><p>因为Star的原型对象也是一个对象,所以也会有<strong>proto</strong>(原型),指向的是Object的原型对象,同样道理,object的原型对象也是一个对象,它的对象原型会想想null.</p><p>原型链的就是利用原型让一个引用类型继承另一个引用类型的属性和方法</p><p>当试图得到一个对象的某个属性时，如果这个对象本身没有这个属性，那么会去它的_proto_（即他的构造函数的prototype）中寻找。如果没有，则会接着往上找，一直上溯到Object.prototype，也就是说所有对象都继承Object.prototype的属性，Object.prototype的原型是null，null没有任何属性和方法。</p><p>若有收获，就点个赞吧</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2021/03/03/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/"/>
    <url>/2021/03/03/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h1><h1 id="一个比喻"><a href="#一个比喻" class="headerlink" title="一个比喻"></a>一个比喻</h1><p>进程与线程的关系可以用一个前辈的比喻来概括:</p><blockquote><p>1.计算机的核心是CPU，它承担了所有的计算任务。它就像一座工厂，时刻在运行。</p><p>2.假定工厂的电力有限，一次只能供给一个车间使用。也就是说，一个车间开工的时候，其他车间都必须停工。背后的含义就是，单个CPU一次只能运行一个任务。</p><p>3.进程就好比工厂的车间，它代表CPU所能处理的单个任务。任一时刻，CPU总是运行一个进程，其他进程处于非运行状态。</p><p>4.一个车间里，可以有很多工人。他们协同完成一个任务。</p><p>5.线程就好比车间里的工人。一个进程可以包括多个线程。</p><p>6.车间的空间是工人们共享的，比如许多房间是每个工人都可以进出的。这象征一个进程的内存空间是共享的，每个线程都可以使用这些共享内存。</p><p>7.可是，每间房间的大小不同，有些房间最多只能容纳一个人，比如厕所。里面有人的时候，其他人就不能进去了。这代表一个线程使用某些共享内存时，其他线程必须等它结束，才能使用这一块内存。</p><p>8.一个防止他人进入的简单方法，就是门口加一把锁。先到的人锁上门，后到的人看到上锁，就在门口排队，等锁打开再进去。这就叫”互斥锁”（Mutual exclusion，缩写 Mutex），防止多个线程同时读写某一块内存区域。</p><p>9.还有些房间，可以同时容纳n个人，比如厨房。也就是说，如果人数大于n，多出来的人只能在外面等着。这好比某些内存区域，只能供给固定数目的线程使用。</p><p>10.这时的解决方法，就是在门口挂n把钥匙。进去的人就取一把钥匙，出来时再把钥匙挂回原处。后到的人发现钥匙架空了，就知道必须在门口排队等着了。这种做法叫做<a href="https://link.zhihu.com/?target=http://en.wikipedia.org/wiki/Semaphore_(programming)">“</a>信号量”（Semaphore），用来保证多个线程不会互相冲突。</p><p>不难看出，mutex是semaphore的一种特殊情况（n=1时）。也就是说，完全可以用后者替代前者。但是，因为mutex较为简单，且效率高，所以在必须保证资源独占的情况下，还是采用这种设计。</p><p>11.操作系统的设计，因此可以归结为三点：</p><p>（1）以多进程形式，允许多个任务同时运行；</p><p>（2）以多线程形式，允许单个任务分成不同的部分运行；</p><p>（3）提供协调机制，一方面防止进程之间和线程之间产生冲突，另一方面允许进程之间和线程之间共享资源。</p></blockquote><h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><p>进程是程序的一次执行过程，是一个动态概念，是程序在执行过程中分配和管理资源的基本单位，每一个进程都有一个自己的地址空间，至少有 5 种基本状态，它们是：初始态，执行态，等待状态，就绪状态，终止状态。</p><h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><p>线程是CPU调度和分派的基本单位，它可与同属一个进程的其他的线程共享进程所拥有的全部资源。</p><h1 id="进程与线程之间的联系"><a href="#进程与线程之间的联系" class="headerlink" title="进程与线程之间的联系"></a>进程与线程之间的联系</h1><p>线程是进程的一部分，一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程。</p><h1 id="进程与线程之间的区别"><a href="#进程与线程之间的区别" class="headerlink" title="进程与线程之间的区别"></a>进程与线程之间的区别</h1><p>根本区别：进程是操作系统资源分配的基本单位，而线程是任务调度和执行的基本单位。</p><p>在开销方面：每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小。</p><p>所处环境：在操作系统中能同时运行多个进程（程序）；而在同一个进程（程序）中有多个线程同时执行（通过CPU调度，在每个时间片中只有一个线程执行）。</p><p>内存分配方面：系统在运行的时候会为每个进程分配不同的内存空间；而对线程而言，除了CPU外，系统不会为线程分配内存（线程所使用的资源来自其所属进程的资源），线程组之间只能共享资源。</p><p>包含关系：没有线程的进程可以看做是单线程的，如果一个进程内有多个线程，则执行过程不是一条线的，而是多条线（线程）共同完成的；线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程。</p><p>当打开一个Chrome标签页时,就相当于打开了一个进程,这个进程下又会有许多线程,比如渲染引擎,JS引擎等。</p><h1 id="JS引擎可以做的事"><a href="#JS引擎可以做的事" class="headerlink" title="JS引擎可以做的事"></a>JS引擎可以做的事</h1><p>1.编译:把JS代码翻译为机器能执行的字节码或机器码。</p><p>2.优化:改写代码，使其更高效。</p><p>3.执行:执行上面的字节码或则机器码</p><p>4.垃圾回收:把JS用完的内存回收,方便之后再次使用。</p><p>声明:截取知乎前辈<a href="https://www.zhihu.com/people/mo-sheng-lu">Victor</a>的文章以便巩固自己进程与线程方面的知识。<a href="https://www.zhihu.com/question/48510028">  </a></p><p>若有收获，就点个赞吧</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2021/03/03/%E6%B5%85%E6%9E%90HTTP/"/>
    <url>/2021/03/03/%E6%B5%85%E6%9E%90HTTP/</url>
    
    <content type="html"><![CDATA[<h1 id="浅析HTTP"><a href="#浅析HTTP" class="headerlink" title="浅析HTTP"></a>浅析HTTP</h1><h1 id="请求与响应"><a href="#请求与响应" class="headerlink" title="请求与响应"></a>请求与响应</h1><h2 id="关于请求-request"><a href="#关于请求-request" class="headerlink" title="关于请求(request)"></a>关于请求(request)</h2><p>请求格式</p><ul><li><p>  请求动词 路径加查询参数 协议名/版本（请求行）</p></li><li><p>  请求头</p></li><li><p>  HOST域名或IP</p></li><li><p>  Accept:text/html</p></li><li><p>  Content-Type:请求体的格式</p></li><li><p>  回车</p></li><li><p>  请求体</p></li></ul><h2 id="关于响应"><a href="#关于响应" class="headerlink" title="关于响应"></a>关于响应</h2><p>响应格式</p><ul><li><p>  协议名/版本 状态码 状态字符串(状态行)</p></li><li><p>  响应头</p></li><li><p>  Content-Type：响应体的格式</p></li><li><p>  回车</p></li><li><p>  响应体</p></li></ul><h2 id="常见的请求方法"><a href="#常见的请求方法" class="headerlink" title="常见的请求方法"></a>常见的请求方法</h2><ul><li>  HTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法</li><li>  HTTP1.1新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT</li></ul><p><code>http/1.1</code>规定了以下请求方法(注意，都是大写):</p><ul><li>  GET：                请求获取Request-URI所标识的资源</li><li>  POST：              在Request-URI所标识的资源后附加新的数据</li><li>  HEAD：             请求获取由Request-URI所标识的资源的响应消息报头</li><li>  PUT：                请求服务器存储一个资源，并用Request-URI作为其标识（修改数据）</li><li>  DELETE：          请求服务器删除对应所标识的资源</li><li>  TRACE：            请求服务器回送收到的请求信息，主要用于测试或诊断</li><li>  CONNECT：      建立连接隧道，用于代理服务器</li><li>  OPTIONS：       列出可对资源实行的请求方法，用来跨域请求</li></ul><p>常见的状态码</p><p>HTTP状态码表示客户端HTTP请求的返回结果、标识服务器处理是否正常、表明请求出现的错误等。</p><p><strong>2XX</strong></p><p><strong>成功（这系列表明请求被正常处理了）</strong></p><p>200</p><p>OK，表示从客户端发来的请求在服务器端被正确处理</p><p>204</p><p>No content，表示请求成功，但响应报文不含实体的主体部分</p><p>206</p><p>Partial Content，进行范围请求成功</p><p><strong>3XX</strong></p><p><strong>重定向（表明浏览器要执行特殊处理）</strong></p><p>301</p><p>moved permanently，永久性重定向，表示资源已被分配了新的 URL</p><p>302</p><p>found，临时性重定向，表示资源临时被分配了新的 URL</p><p>303</p><p>see other，表示资源存在着另一个 URL，应使用 GET 方法获取资源（对于301/302/303响应，几乎所有浏览器都会删除报文主体并自动用GET重新请求）</p><p>304</p><p>not modified，表示服务器允许访问资源，但请求未满足条件的情况（与重定向无关）</p><p>307</p><p>temporary redirect，临时重定向，和302含义类似，但是期望客户端保持请求方法不变向新的地址发出请求</p><p><strong>4XX</strong></p><p><strong>客户端错误</strong></p><p>400</p><p>bad request，请求报文存在语法错误</p><p>401</p><p>unauthorized，表示发送的请求需要有通过 HTTP 认证的认证信息</p><p>403</p><p>forbidden，表示对请求资源的访问被服务器拒绝，可在实体主体部分返回原因描述</p><p>404</p><p>not found，表示在服务器上没有找到请求的资源</p><p><strong>5XX</strong></p><p><strong>服务器错误</strong></p><p>500</p><p>internal sever error，表示服务器端在执行请求时发生了错误</p><p>501</p><p>Not Implemented，表示服务器不支持当前请求所需要的某个功能</p><p>503</p><p>service unavailable，表明服务器暂时处于超负载或正在停机维护，无法处理请求</p><h2 id="用curl命令构建请求"><a href="#用curl命令构建请求" class="headerlink" title="用curl命令构建请求"></a>用curl命令构建请求</h2><p>例子curl -v <a href="http://127.0.0.1:8888/">http://127.0.0.1:8888</a> 查看请求与响应的过程。</p><p>前提是本地已经打开了一个有端口号8888的服务器。</p><p>设置请求动词</p><p>-X POST</p><p>注意大小写</p><p>设置路径和查询参数</p><p>直接在url后加</p><p>设置请求头</p><p>-H  ‘Name:Value’</p><p>设置请求体</p><p>-d ‘内容’</p><h2 id="用Node-js读取请求"><a href="#用Node-js读取请求" class="headerlink" title="用Node.js读取请求"></a>用Node.js读取请求</h2><p>读取请求动词</p><p>request.method</p><p>读取路径</p><p>request.url路径,带查询参数</p><p>path纯路径,不带查询参数</p><p>query只有查询参数</p><p>读取请求头</p><p>request.headers[“Accept”]</p><h2 id="用Node-js设置响应"><a href="#用Node-js设置响应" class="headerlink" title="用Node.js设置响应"></a>用Node.js设置响应</h2><p>设置响应状态码</p><p>response.statusCode = 200</p><p>设置响应头</p><p>response.setHeader(“Content-Type”,”text/html”)</p><p>设置响应体</p><p>response.write(“内容”)</p><p>可追加内容</p><p>若有收获，就点个赞吧</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2021/03/03/%E6%B5%85%E6%9E%90URL/"/>
    <url>/2021/03/03/%E6%B5%85%E6%9E%90URL/</url>
    
    <content type="html"><![CDATA[<h1 id="浅析URL"><a href="#浅析URL" class="headerlink" title="浅析URL"></a>浅析URL</h1><h1 id="1-网络和IP"><a href="#1-网络和IP" class="headerlink" title="1.网络和IP"></a>1.网络和IP</h1><p>什么是IP？</p><p>IP（Internt protocal）网际协议</p><p>主要约定了两件事</p><ul><li>  如何定位一台设备</li><li>  如何封装数据报文,以跟其他设备交流</li></ul><p>一个设备至少有一个独特的IP.</p><h2 id="IP分为内网和外网"><a href="#IP分为内网和外网" class="headerlink" title="IP分为内网和外网"></a>IP分为内网和外网</h2><p>外网我们需要通过路由器获取,只要路由器连接上了运营商的服务器,那么路由器就会拥有一个外网IP,比如[14.17.32.211] 就是一个外网IP。这就是我们在互联网上的位置。</p><p>值得一提的是,当我们重启路由器时,我们的路由器可能会被重新分配外网IP,也就是说,我们的路由器没有固定的外网IP。</p><p>内网,此时我们的设备连接上路由器,我们的手机和电脑上的IP就是内网IP。</p><p>路由器会在我们家里创建一个内网,内网中的设备使用内网IP,一般来说这个IP的格式都是192.168.xxx.xxx。</p><p>然后路由会给每一个外网中的设备分配一个不同的内网。</p><p><strong>路由器的功能</strong></p><ul><li>  现在路由器有两个IP,一个外网IP和一个内网IP</li><li>  内网中的设备可以互相访问,但是不能直接访问外网。</li><li>  内网中的设备想要访问外网,就必须经过路由器中转</li><li>  外网中的设备可以互相访问,但是无法访问我们的内网。</li><li>  外网设备想要把内容送到内网,也必须通过路由器。</li><li>  也就是说内网和外网就像两个隔绝的空间,无法互通,唯一的联通点就是路由器。</li><li>  所以路由器有时候也被叫做网关。</li></ul><h2 id="几个特殊的IP"><a href="#几个特殊的IP" class="headerlink" title="几个特殊的IP"></a>几个特殊的IP</h2><p>分别是</p><p>127.0.0.1表示自己</p><p>localhost通过hosts指定自己</p><p>0.0.0.0不表示任何设备</p><h1 id="2-端口-port"><a href="#2-端口-port" class="headerlink" title="2.端口(port)"></a>2.端口(port)</h1><h2 id="端口的用途"><a href="#端口的用途" class="headerlink" title="端口的用途"></a>端口的用途</h2><p>端口用来指定某台服务器上的某个服务</p><p>IP是用来指定访问那一台设备的,此时我们还需要指定访问这台设备上的特定服务。</p><p>一台机器可以提供很多不同的服务。</p><p>每个服务一个号码,这个号码就叫做端口。</p><hr><h2 id="一台机器可以提供不同服务"><a href="#一台机器可以提供不同服务" class="headerlink" title="一台机器可以提供不同服务"></a>一台机器可以提供不同服务</h2><ul><li>  要提供HTTP服务最好使用80端口</li><li>  要提供HTTPS服务最好使用443端口</li><li>  要提供FTP服务最好使用21端口</li><li>  一共有65535个端口</li></ul><h2 id="端口使用时的一些规则"><a href="#端口使用时的一些规则" class="headerlink" title="端口使用时的一些规则"></a>端口使用时的一些规则</h2><p>规则</p><ul><li>  0-1023号端口是留给系统使用的</li><li>  你只有拥有了管理员权限后,才能使用这1024个端口</li><li>  其他端口可以给普通用户使用</li><li>  比如http-server默认使用8080端口</li><li>  一个端口如果被占用,你就只能换一个端口</li></ul><h1 id="3-域名"><a href="#3-域名" class="headerlink" title="3.域名"></a>3.域名</h1><p>因为数字型的IP实在不符合人类的记忆习惯,于是有人想出了用字符串代替一大串的数字,也就引出了<strong>域名。</strong></p><p><strong>域名就是对IP的别称。</strong></p><p>比如baidu.com对应的IP地址是</p><p>220.181.38.148</p><p>39.156.69.79。</p><h2 id="均衡负载和共享主机"><a href="#均衡负载和共享主机" class="headerlink" title="均衡负载和共享主机"></a>均衡负载和共享主机</h2><p>知识点:</p><p>一个域名可以对用不同的IP。</p><p>这个叫均衡负载,防止一台机器扛不住。</p><p>一个IP可以对应不同域名。</p><p>这个叫共享主机。  </p><h1 id="4-DNS协议"><a href="#4-DNS协议" class="headerlink" title="4.DNS协议"></a>4.DNS协议</h1><p>DNS协议的主要作用就是使域名和IP对应起来.</p><p>当你使用Chrome访问baidu.com</p><p>具体过程:</p><p>你的Chrome浏览器会向电信/联通提供的DNS服务器询问baidu.com对应什么IP</p><p>电信/联通会回答一个IP</p><p>然后Chrome才会向对应IP的80/443端口发送请求</p><p>请求内容是查看baidu.com的首页。</p><p>为什么是80/443端口</p><p>服务器默认用80提供http服务</p><p>服务器默认用443提供https服务</p><p>你可以在开发者工具里看到具体的端口</p><h1 id="5-路径-path"><a href="#5-路径-path" class="headerlink" title="5.路径(path)"></a>5.路径(path)</h1><p>我们此时可以访问指定的服务器中的指定服务,但是我们该如何访问指定服务的不同界面呢?</p><p>路径可以做到这一点。</p><h1 id="6-查询参数"><a href="#6-查询参数" class="headerlink" title="6.查询参数"></a>6.查询参数</h1><p>可以访问同一个页面的不同内容。</p><h1 id="7-锚点"><a href="#7-锚点" class="headerlink" title="7.锚点"></a>7.锚点</h1><p>可以访问同一个内容的不同位置。</p><p>注意:锚点看起来支持中文,实际上不支持。</p><p>锚点无法再Network面板上查看。</p><p>因为锚点不会被传给服务器。</p><h1 id="8-URL"><a href="#8-URL" class="headerlink" title="8.URL"></a>8.URL</h1><p>URL实际上就等于 协议 + 域名或IP + 端口名 + 路径 + 查询字符串 + 锚点。</p><p> <img src="https://cdn.nlark.com/yuque/0/2020/png/1554318/1606898790489-447d3907-8a52-462d-a50f-4658decca993.png" alt="Snipaste_2020-12-02_16-46-21.png" title="Snipaste_2020-12-02_16-46-21.png"> </p><p>wd-hello&amp;rsv_spt-15</p><p>com/s</p><p><a href="https://www.baidu.co/">https://www.baidu.co</a></p><p>查问冬仅锅点</p><p>路经</p><p>域名</p><p>协以</p><p>HTTP/HTTPS端口是默认的80/443</p><h1 id="9-一些比较有用的有关于HTTP的命令"><a href="#9-一些比较有用的有关于HTTP的命令" class="headerlink" title="9.一些比较有用的有关于HTTP的命令"></a>9.一些比较有用的有关于HTTP的命令</h1><p>1.nslookup</p><p>nslookup最简单的用法是查询域名对应的IP地址</p><p>nslookup baidu.com</p><p> <img src="https://cdn.nlark.com/yuque/0/2020/png/1554318/1606900696744-f0412b53-5453-459c-a0c0-be13d9ab95f5.png" alt="Snipaste_2020-12-02_17-17-57.png" title="Snipaste_2020-12-02_17-17-57.png"> </p><p>服务器:ns.jxncptt,net.cn</p><p>ddress:202.101.224.69</p><p>非权威应答:</p><p>名称:</p><p>baidu.</p><p>com</p><p>220.181.38.148</p><p>ddresses:</p><p>39.156.69.79</p><p>2.ping</p><p>ping命令 用于验证与远程计算机的连接。</p><p>ping baidu.com</p><p> <img src="https://cdn.nlark.com/yuque/0/2020/png/1554318/1606900796788-7d7264e2-cdb1-4360-95bd-96c2913ba2ad.png" alt="Snipaste_2020-12-02_17-19-34.png" title="Snipaste_2020-12-02_17-19-34.png"> </p><p>具有32字节的数据:</p><p>正在Ping</p><p>[39.156.69.79]</p><p>baidu.com</p><p>来自</p><p>2时间-33msTTL-47</p><p>的回复:字节-32日</p><p>39.156.69.79</p><p>来自</p><p>的回复:字节-32时间-34msTTL-47</p><p>39.156.69.79</p><p>来自</p><p>的回复:字节-32时间-36msTTL-47</p><p>39.156,69.79</p><p>来自</p><p>的回复:字节-32时间-35msTTL-47</p><p>39.156.69.79</p><p>统计信息:</p><p>的Ping</p><p>39.156.69.79</p><p>4,丢失二1(0%丢失),</p><p>4,已接收</p><p>数据包:已发送</p><p>住返行程的估计时间(以毫秒为单位)</p><p>最长</p><p>36ms,平均-34ms</p><p>最短-33mS,</p><p>3.curl</p><p>最简单的作用就是查看在于远程计算机连接的过程。</p><p>4.ipconfig查询本地内外网IP。</p><p>若有收获，就点个赞吧</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2021/03/03/CSS%E5%8A%A8%E7%94%BB/"/>
    <url>/2021/03/03/CSS%E5%8A%A8%E7%94%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="CSS动画"><a href="#CSS动画" class="headerlink" title="CSS动画"></a>CSS动画</h1><h1 id="动画原理"><a href="#动画原理" class="headerlink" title="动画原理"></a>动画原理</h1><p>定义</p><ul><li>  动画由许多静止的画面(帧)组成</li><li>  以一定速度连续播放时</li><li>  肉眼因视觉残象产生错觉</li><li>  误以为是活动的画面</li></ul><h1 id="transfrom-变形"><a href="#transfrom-变形" class="headerlink" title="transfrom(变形)"></a>transfrom(变形)</h1><p>CSS**<code>transform</code>**属性允许你旋转，缩放，倾斜或平移给定元素。</p><ul><li>  位移translate</li><li>  旋转rotate</li><li>  缩放scale</li><li>  倾斜skew</li></ul><p><strong>注意:一般transform的使用都伴随着transition(过渡)</strong></p><p><strong>inline元素不支持transform</strong></p><h2 id="transform之translate"><a href="#transform之translate" class="headerlink" title="transform之translate"></a>transform之translate</h2><p>常见写法</p><p>transform:translateX(百分比或像素长)</p><p>transform:translateY(百分比或像素长)</p><p>transform:translateZ(百分比或像素长)且父容器perspective</p><p>transform:translate3d(x,y,z)</p><p>经验:</p><p><strong>学会看懂MDN语法示例</strong></p><p><strong>translate(-50%,-50%)可作为绝对定位元素的居中。</strong></p><h2 id="transform之scale"><a href="#transform之scale" class="headerlink" title="transform之scale"></a>transform之scale</h2><p>常见写法</p><p>transform:scaleX(倍数)</p><p>transform:scaleY(倍数)</p><p>transform:scale(宽的倍数,高的倍数)</p><h2 id="transform之rotate"><a href="#transform之rotate" class="headerlink" title="transform之rotate"></a>transform之rotate</h2><p>常见写法</p><ul><li>  rotateX(xxxdeg)</li><li>  rotateY(xxxdeg)</li><li>  rotateZ(xxxdeg)</li></ul><p><strong>一般用于360度旋转制作loading</strong></p><p><strong>用到时再搜索rotateMDN看文档</strong></p><h2 id="transform之skew"><a href="#transform之skew" class="headerlink" title="transform之skew"></a>transform之skew</h2><p><strong><code>skew()</code></strong> 函数定义了一个元素在二维平面上的倾斜转换.</p><p><code>skew()</code> 函数指定一个或两个参数，它们表示在每个方向上应用的倾斜量。</p><p>常见写法</p><p>shewX()</p><p>shewY()</p><p>shew()</p><p>transform多重效果</p><p>组合使用</p><p>transform:scale(0.5) translate(-100%,-100%)</p><p>transform:none;取消所有</p><h1 id="transition-过渡"><a href="#transition-过渡" class="headerlink" title="transition(过渡)"></a>transition(过渡)</h1><p>作用:补充中间帧</p><p>语法</p><p>transition:属性名 时长 过渡方式 延迟时长</p><p>例如:transition:left 200ms linear xxx(ms/s)</p><p>可以用逗号分隔两个不同属性</p><p>transition:left 200ms, top 400ms</p><p>可以用all代表所有属性</p><p>transition:all 200ms</p><p>过渡的方式有:linear | ease | ease-in |ease-out等等</p><p><strong>注意:</strong></p><p><strong>并不是所有属性都能过渡</strong></p><p><strong>display: none =&gt;block没法过渡</strong></p><p><strong>一般改成visibility:hidden =&gt;visible</strong></p><p>过渡必须要有起始,一般一次动画,最多两次。</p><h1 id="animate-动画"><a href="#animate-动画" class="headerlink" title="animate(动画)"></a>animate(动画)</h1><p>多次动画的结合使用animate</p><p>声明关键帧</p><p>添加动画</p><p>1.@keyframes xxx {</p><p>from {</p><p>some code</p><p>}</p><p>to {</p><p>some code</p><p>}</p><p>2.@keyframes xxx {</p><p>0%{some code}</p><p>30%{some code}</p><p>60%{some code}</p><p>100%{some code}</p><p>}</p><p>animation</p><p>缩写语法</p><p>animation:时长|过渡方式|延迟|次数|方向|填充模式|是否暂停|动画迷名</p><p>时长:1s或则1000ms</p><p>过渡方式:ease | linear等</p><p>次数:3或4或则infinite</p><p>方向:reverse | alternate | alternate-reverse</p><p>填充方式:none | forwards | backwards | both</p><p>是否暂停: paused | running</p><p>以上所有属性都有对于的单独属性</p><p>若有收获，就点个赞吧</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2021/03/03/CSS%E5%B8%83%E5%B1%80/"/>
    <url>/2021/03/03/CSS%E5%B8%83%E5%B1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="CSS布局"><a href="#CSS布局" class="headerlink" title="CSS布局"></a>CSS布局</h1><h1 id="float布局"><a href="#float布局" class="headerlink" title="float布局"></a>float布局</h1><p>步骤：</p><ul><li><p>  子元素上加  float:left, 和width</p></li><li><p>  <strong>父元素加上 .clearfix</strong></p></li><li><p>  <strong>父元素加上class:</strong> class=”clearfix”</p></li><li><p>  .clearfix的写法：</p></li></ul><p>.clearfix::after {  content:’’; display:block; clear:both; }</p><p>一些经验：</p><ul><li>  最后一个子元素不设置width， 或者设置max-width</li><li>  img 设置Max-width</li><li>  如果图片下面有多余的空白，就在图片上写上 vertical-align: top或者middle</li><li>  如果border干扰了布局，可以用outline: 1px solid red, outline不占用位置</li><li>  固定元素的块级元素居中的方法： 写上margin: 0 auto; 或者<strong>margin-left: auto; margin-right: auto;(比前者好，因为没有影响上下的Margin)</strong></li><li>  <strong>平均布局的关键点：负Margin</strong></li></ul><h1 id="flex布局"><a href="#flex布局" class="headerlink" title="flex布局"></a>flex布局</h1><p>flex布局两个主题:容器(contaniner)和项目(item)。</p><p>flex盒子两条轴:主轴和侧轴。默认为主轴x轴,侧轴为y轴。</p><p>起步:</p><p>display:flex将一个盒子设置成flex盒子。</p><p>容器属性:</p><p>flex-direction设置主轴方向。</p><p>justify-content设置项目在主轴上的排列方式。</p><p>align-items设置项目在侧轴上的排列方式(单行)。</p><p>align-content设置项目在侧轴上的排列方式(多行)。</p><p>flex-wrap设置项目是否换行。</p><p>flex-flow：主轴方向 是否换行。简写</p><ul><li><p>  flex-direction属性值</p></li><li><p>  row<code>----------&gt;</code></p></li><li><p>  row-reverse(从右到左)<code>&lt;---------</code></p></li><li><p>  column(从上到下)</p></li><li><p>  column-reverse(从下到上)</p></li></ul><ul><li><p>  justify-content属性值</p></li><li><p>  <code>flex-start</code></p></li><li><p>  <code>flex-end</code></p></li><li><p>  <code>center</code></p></li><li><p>  <code>space-around(平均分成若干份)</code></p></li><li><p>  <code>space-between(一左一右紧贴两边,其余的平均分配剩余空间)</code></p></li></ul><ul><li><p>  align-items属性值</p></li><li><p>  flex-start</p></li><li><p>  flex-end</p></li><li><p>  center</p></li><li><p>  stretch(所有项目高度默认与最高的项目一致)</p></li><li><p>  space-around(平均分成若干份)</p></li><li><p>  space-between(一左一右紧贴两边,其余的平均分配剩余空间)</p></li></ul><ul><li><p>  align-content属性值</p></li><li><p>  flex-start</p></li><li><p>  flex-end</p></li><li><p>  center</p></li><li><p>  stretch(所有项目高度默认与最高的项目一致)</p></li><li><p>  space-around(平均分成若干份)</p></li><li><p>  space-between(一左一右紧贴两边,其余的平均分配剩余空间)</p></li></ul><ul><li><p>  flex-wrap属性值</p></li><li><p>  wrap(换行)</p></li><li><p>  wrap-reverse(换行且颠倒)</p></li><li><p>  nowrap(不换行)</p></li></ul><p>项目属性:</p><p>order：决定此项目的排列优先级(越小越靠前)。</p><p>align-self：改变单个项目的排列方式。</p><p>flex-grow：指定了flex容器中剩余空间的多少应该分配给项目（flex增长系数）。</p><p>flex-shrink：指定了 flex 元素的收缩规则，仅在默认宽度之和大于容器的时候才会发生收缩，其收缩的大小是依据 flex-shrink 的值。</p><p>flex-basis：指定了 flex 元素在主轴方向上的初始大小。</p><p>flex: fle-grow flex-shrink flex-basis的简写。</p><p>align-self属性值</p><p>flex-start</p><p>flex-end</p><p>center</p><h1 id="grid布局"><a href="#grid布局" class="headerlink" title="grid布局"></a>grid布局</h1><p>grid布局:新的table布局</p><p>起步:display:grid将盒子设置为grid盒子。</p><p>grid-template-columns: 40px 50px auto 50px 40px;</p><p>grid-template-rows: 60px 400px 200px;</p><p>表示5列3行</p><p>用法展示:</p><p><a href="http://js.jirengu.com/yuwifamowe/1/edit?html,css,output">http://js.jirengu.com/yuwifamowe/1/edit?html,css,output</a></p><p>fr的用法：</p><p><a href="http://js.jirengu.com/zokevujila/1/edit?html,css,output">http://js.jirengu.com/zokevujila/1/edit?html,css,output</a></p><p>用fr来实现平均布局，就不在需要写负Margin了</p><p><a href="http://js.jirengu.com/somodiyoda/1/edit?html,css,output">http://js.jirengu.com/somodiyoda/1/edit?html,css,output</a></p><p>grid用法总结：</p><ol><li><p> 用grid-template-areas 设计大致的布局</p></li><li><p>示例：</p><p>grid-template-areas: “big mid1” “big mid2” “sm1 mid2” “sm2 mid3” “sm3 mid3”</p></li><li><p> 用<strong>grid-template-rows</strong>和<strong>grid-template-columns</strong>指定每一行每一列的高度和宽度</p></li><li><p> <strong>示例：</strong></p></li><li><p> <strong>grid-template-rows:</strong> 240px repeat(4, 120px);</p></li><li><p> <strong>grid-template-columns:</strong> 250px 250px;</p></li><li><p> 对于每一个小块，用grid-area和grid-template-areas 里布局的字符串对应</p></li></ol><p>示例：</p><p>.demo &gt; .image:first-child{  grid-area: big; border: 1px solid red; }</p><p>grid尤其适合用来做不规则布局</p><p>假设我们想做以下布局：</p><p> <img src="https://cdn.nlark.com/yuque/0/2020/png/540849/1592386399540-98a24c5b-e892-4258-b81b-4e1cc90f2a6d.png" alt="gird.PNG" title="gird.PNG"> </p><p>代码示例：</p><p><a href="http://js.jirengu.com/qififesuga/1/edit?html,css,output">http://js.jirengu.com/qififesuga/1/edit?html,css,output</a></p><p>若有收获，就点个赞吧</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>CSS文档流</title>
    <link href="/2021/01/15/CSS%E6%96%87%E6%A1%A3%E6%B5%81/"/>
    <url>/2021/01/15/CSS%E6%96%87%E6%A1%A3%E6%B5%81/</url>
    
    <content type="html"><![CDATA[<h2 id="前言-和我一起开始CSS文档流的学习吧"><a href="#前言-和我一起开始CSS文档流的学习吧" class="headerlink" title="前言:和我一起开始CSS文档流的学习吧"></a>前言:和我一起开始CSS文档流的学习吧</h2><h1 id="CSS文档流"><a href="#CSS文档流" class="headerlink" title="CSS文档流"></a>CSS文档流</h1><h2 id="文档流"><a href="#文档流" class="headerlink" title="文档流"></a>文档流</h2><h2 id="流动方向"><a href="#流动方向" class="headerlink" title="流动方向"></a>流动方向</h2><p>• inline元素从左到右,一直到最右边才换行<br>• block元素从上到下,每一个都另起一行<br>• inline-block也是从左到右</p><h2 id="宽度"><a href="#宽度" class="headerlink" title="宽度"></a>宽度</h2><p>• inline宽度为内部inline元素的和,不能用width指定<br>• block宽度为默认自动计算宽度,可用width指定<br>• inline-block宽度结合前两点的特点,可指定宽度。</p><h2 id="高度"><a href="#高度" class="headerlink" title="高度"></a>高度</h2><p>• inline高度为line-height间接指定,跟height无关(默认不为0)<br>• block高度由内部文档流指定,可以设置height (默认为0)</p><ul><li>inline-block跟block类似,可以设置height</li></ul><h2 id="overflow溢出"><a href="#overflow溢出" class="headerlink" title="overflow溢出"></a>overflow溢出</h2><p>当内容大于容器<br>• 当内容的宽度或高度大于容器,会溢出<br>• 可以overflow来设置是否显示滚动条<br>• auto是灵活设置<br>• scroll是永远显示hidden是永远隐藏溢出效果<br>• visible是永远显示溢出效果</p><h2 id="脱离文档流"><a href="#脱离文档流" class="headerlink" title="脱离文档流"></a>脱离文档流</h2><p>• float<br>• position:absoluate/fixed会导致脱离文档流</p><h2 id="两种盒模型"><a href="#两种盒模型" class="headerlink" title="两种盒模型"></a>两种盒模型</h2><p>CSS盒模型有两种盒模型<br>content-box内容盒模型 width = 内容宽度<br>border-box边框盒模型 width = 内容宽度 + padding + border<br>一般使用border-box<br>()[<a href="https://cdn.nlark.com/yuque/0/2020/png/1554318/1606737360898-b065aabc-183a-4a00-9c24-5e4f50ad6e39.png?x-oss-process=image/resize,w_1256%5D">https://cdn.nlark.com/yuque/0/2020/png/1554318/1606737360898-b065aabc-183a-4a00-9c24-5e4f50ad6e39.png?x-oss-process=image%2Fresize%2Cw_1256]</a></p><p>如图:<br>第一个设置了content-box的盒子宽度为width(100px) + padding(20px) + border(30px)<br>第二个设置了border-box的盒子宽度为width(100px)</p><h2 id="margin合并"><a href="#margin合并" class="headerlink" title="margin合并"></a>margin合并</h2><p>那些情况会合并<br>• 父子合并<br>()[<a href="https://cdn.nlark.com/yuque/0/2020/png/1554318/1606740072235-97d5e83d-a4d4-4a54-839c-9e5f33b64b4d.png?x-oss-process=image/resize,w_1472%5D">https://cdn.nlark.com/yuque/0/2020/png/1554318/1606740072235-97d5e83d-a4d4-4a54-839c-9e5f33b64b4d.png?x-oss-process=image%2Fresize%2Cw_1472]</a></p><p>parent的上外边距会和son的上外边距合并,取两者中较大的一个。<br>• 兄弟合并<br>()[<a href="https://cdn.nlark.com/yuque/0/2020/png/1554318/1606739802670-5bf1c4c9-594c-4341-ba44-34401205e71a.png?x-oss-process=image/resize,w_1472%5D">https://cdn.nlark.com/yuque/0/2020/png/1554318/1606739802670-5bf1c4c9-594c-4341-ba44-34401205e71a.png?x-oss-process=image%2Fresize%2Cw_1472]</a><br>box1的下外边距和box2上外边距不会累加,而是会去两者中较大的。</p><p>如何阻止合并<br>• 父子合并用padding/border挡住<br>• 父子合并用overflow:hidden挡住<br>• 父子合并用display:flex挡住<br>• 第三种方式是给parent加overflow:hidden<br>  • margin能合并就是因为父子的Margin之间没有其他的东西，如果加了border或者Padding就等于在父子的Margin中间加了东西，因此就无法合并margin了<br>• 兄弟合并用display:inline-block;</p><h2 id="在线测试连接"><a href="#在线测试连接" class="headerlink" title="在线测试连接"></a>在线测试连接</h2><p>()[<a href="http://js.jirengu.com/ridagabubu/2/edit?html,css,output%5D">http://js.jirengu.com/ridagabubu/2/edit?html,css,output]</a><br><strong>border-box更好用</strong></p><h2 id="基本单位"><a href="#基本单位" class="headerlink" title="基本单位"></a>基本单位</h2><p>• 长度单位<br>• px<br>• em 相对自身font-size的倍数</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>CSS语法</title>
    <link href="/2021/01/15/CSS%E8%AF%AD%E6%B3%95/"/>
    <url>/2021/01/15/CSS%E8%AF%AD%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="前言-和我一起开始CSS语法的学习吧"><a href="#前言-和我一起开始CSS语法的学习吧" class="headerlink" title="前言:和我一起开始CSS语法的学习吧"></a>前言:和我一起开始CSS语法的学习吧</h2><h1 id="CSS语法"><a href="#CSS语法" class="headerlink" title="CSS语法"></a>CSS语法</h1><h2 id="CSS厉害之处"><a href="#CSS厉害之处" class="headerlink" title="CSS厉害之处"></a>CSS厉害之处</h2><p>层叠样式表<br>层叠指的是什么?</p><ul><li>样式层叠<ul><li>可以多次对同一选择器进行层叠</li></ul></li><li>选择器层叠<ul><li>可以用不同选择器对同一样式进行层叠</li></ul></li><li>文件层叠<ul><li>可以用多个文件层叠</li></ul></li></ul><p>太灵活所以导致css的缺点也很明显。</p><h2 id="css在各种浏览器的兼容性"><a href="#css在各种浏览器的兼容性" class="headerlink" title="css在各种浏览器的兼容性"></a>css在各种浏览器的兼容性</h2><p>推荐网站:<a href="https://caniuse.com/?search=grid(csniuse.com)">https://caniuse.com/?search=grid(csniuse.com)</a></p><h2 id="学习语言的方法"><a href="#学习语言的方法" class="headerlink" title="学习语言的方法"></a>学习语言的方法</h2><ul><li>语法</li><li>调试方法(如何查看自己哪里写错了)</li><li>在哪里查资料(为了抄代码)</li><li>标准制定者是谁</li></ul><h2 id="如何学"><a href="#如何学" class="headerlink" title="如何学"></a>如何学</h2><ul><li>CRM学习法</li><li>Copy-抄文档</li><li>Run-在自己机器上运行成功</li><li>Modify-加入一点自己的思想,重新运行</li></ul><h2 id="CSS语法-1"><a href="#CSS语法-1" class="headerlink" title="CSS语法"></a>CSS语法</h2><p>语法一： </p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">选择器 &#123;<br>属性名: 属性值：<span class="hljs-regexp">/*注释*/</span><br>&#125;<br></code></pre></td></tr></table></figure><p>语法二:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-keyword">@charset</span> <span class="hljs-string">&quot;UTF-8&quot;</span>;<br><span class="hljs-keyword">@import</span> url(<span class="hljs-number">2</span>.css);<br><span class="hljs-keyword">@media</span> (<span class="hljs-attribute">min-width:</span> <span class="hljs-number">100px</span>) <span class="hljs-keyword">and</span> (<span class="hljs-attribute">max-width:</span> <span class="hljs-number">200px</span>) &#123;<br>语法一<br>&#125;<br></code></pre></td></tr></table></figure><p>注意:@charset “UTF-8”;必须放第一行<br>前两个at必须以;结尾<br>charest是字符集,UTF-8是字符编码</p><h2 id="如何调试"><a href="#如何调试" class="headerlink" title="如何调试"></a>如何调试</h2><ul><li>使用w3c在线调试工具(太麻烦)</li><li>使用VSCode看颜色</li><li>使用 WebStorm看颜色</li><li>使用浏览器开发中工具看警告<ul><li>找到你脑中的标签</li><li>看它是否有选择器</li><li>看它样式是否被划掉</li><li>看它样式是否出警告</li></ul></li><li>border调试法<ul><li>给你怀疑出错的元素加border</li><li>border没出现,说明选择器错了,或则语法错了</li><li>border出现了,看边界是否符合预期</li><li>bug解决了猜能删除border</li></ul></li></ul><h2 id="在哪查资料"><a href="#在哪查资料" class="headerlink" title="在哪查资料"></a>在哪查资料</h2><p>网站推荐</p><ul><li>要查的关键词 + MDN</li><li>CSS tricks</li><li>张鑫旭的博客</li></ul><h2 id="在哪里找素材"><a href="#在哪里找素材" class="headerlink" title="在哪里找素材"></a>在哪里找素材</h2><ul><li>PSD<ul><li>freepik找PSD web(外国网站)</li><li>中文的比较少(365的UI组件)</li></ul></li><li>效果图(不提供下载)<ul><li>dribbble.com顶级设计师社区</li></ul></li><li>商业网站<ul><li>熟悉的电商网</li></ul></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>HTML常用标签</title>
    <link href="/2021/01/14/HTML%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/"/>
    <url>/2021/01/14/HTML%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/</url>
    
    <content type="html"><![CDATA[<h2 id="前言-今天我们来了解一下HTML的常用标签"><a href="#前言-今天我们来了解一下HTML的常用标签" class="headerlink" title="前言:今天我们来了解一下HTML的常用标签"></a>前言:今天我们来了解一下HTML的常用标签</h2><h1 id="HTML常用标签"><a href="#HTML常用标签" class="headerlink" title="HTML常用标签"></a>HTML常用标签</h1><h2 id="1-a标签"><a href="#1-a标签" class="headerlink" title="1.a标签"></a>1.a标签</h2><p>属性</p><ul><li>href</li><li>target</li><li>download(不常使用)</li><li>rel=noopener</li></ul><p>href的取值</p><ul><li>网址<ul><li><a href="https://www.google.com/">https://www.google.com</a></li><li><a href="http://www.google.com/">http://www.google.com</a></li><li>//google.com</li></ul></li><li>路径<ul><li>/a/b/c或./a/b/c</li><li>index.html以及./index.html</li></ul></li><li>伪协议<ul><li>javascript:代码;</li><li>mailto:邮箱地址</li><li>tel:手机号</li></ul></li><li>id</li><li>href=#xxx</li></ul><p>注意:以后调试不直接双击页面打开,而是使用http-server包打开。<br>因为:直接双击打开路径是从file(本地根目录)开始,而使用http-server是从开启hppt服务的根目录开始。<br>使用方法:http-server . -c-1</p><p>target的取值</p><ul><li>内置名字<ul><li>_blank(新页面打开)</li><li>_self(原页面打开)</li><li>_top(如果页面中嵌套了框架,从页面最顶层打开)</li><li>_parent(如果页面嵌套了框架,从当前页面的上一级页面的打开)</li></ul></li></ul><h2 id="2-iframe"><a href="#2-iframe" class="headerlink" title="2.iframe"></a>2.iframe</h2><p>内嵌窗口,现在很少使用了,只有一些老系统还在使用</p><h2 id="3-table标签"><a href="#3-table标签" class="headerlink" title="3.table标签"></a>3.table标签</h2><p>表格<br>相关的标签</p><ul><li>table</li><li>thead</li><li>tbody</li><li>tfoot</li><li>tr</li><li>th</li><li>td<br>相关的样式</li><li>table-layout:auto/fixed(表格宽度是否根据字体数自适应)</li><li>border-collapse(合并两个表格的边框)</li><li>border-spacing(两个表格之间的间距)</li></ul><h2 id="4-img标签"><a href="#4-img标签" class="headerlink" title="4.img标签"></a>4.img标签</h2><p>作用:发送get请求,展示以上图片<br>属性</p><ul><li>src</li><li>alt</li><li>height</li><li>width<br>事件</li><li>onload</li><li>onerror<br>响应式<br>max-width:100%<br>可替换元素:[][<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Replaced_element]">https://developer.mozilla.org/zh-CN/docs/Web/CSS/Replaced_element]</a></li></ul><h2 id="5-form表单"><a href="#5-form表单" class="headerlink" title="5.form表单"></a>5.form表单</h2><p>作用:发送get或post请求,然后刷新页面<br>属性</p><ul><li>action</li><li>autocomplete</li><li>method</li><li>target<br>事件<br>onsubmit</li></ul><h2 id="6-input标签"><a href="#6-input标签" class="headerlink" title="6.input标签"></a>6.input标签</h2><p>作用:让用户输入内容<br>属性:<br>类型type:text/password/radio/checkbox/submit/number/tel/button/email/file/hidden/search<br>其他:disabled/checked/placeholder/value/name/maxlength/autofocus<br>事件</p><ul><li>onchange</li><li>onfocus</li><li>onblur<br>验证器(html5新增)<br>required</li></ul><h2 id="7-其他输入标签"><a href="#7-其他输入标签" class="headerlink" title="7.其他输入标签"></a>7.其他输入标签</h2><ul><li>select+option</li><li>textarea</li><li>label<br>注意事项:<br>一般不监听input的click事件<br>form里面的input要用name属性<br>form里面要放一个submit的input才能触发submit事件</li></ul><h2 id="8-其他标签"><a href="#8-其他标签" class="headerlink" title="8.其他标签"></a>8.其他标签</h2><p>标签<br>video<br>audio<br>canvas<br>svg</p><p>注意事项:<br>这些标签的兼容性一定得查看文档</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>HTML入门</title>
    <link href="/2021/01/14/HTML%E5%85%A5%E9%97%A8/"/>
    <url>/2021/01/14/HTML%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="前言-今天我们继续HTML5的学习"><a href="#前言-今天我们继续HTML5的学习" class="headerlink" title="前言:今天我们继续HTML5的学习"></a>前言:今天我们继续HTML5的学习</h2><h2 id="HTML是谁发明的"><a href="#HTML是谁发明的" class="headerlink" title="HTML是谁发明的"></a>HTML是谁发明的</h2><p>1990年左右，Tim Berners-Lee（蒂姆·伯纳斯·李）发明了万维网（亦作“WWW”英文全称为“World Wide Web”），同时发明了HTML、HTTP和URL。李爵士写了第一个浏览器，写了第一个服务器，并且用自己的浏览器访问了自己的服务器。</p><h2 id="HTML起手式"><a href="#HTML起手式" class="headerlink" title="HTML起手式"></a>HTML起手式</h2><p>写HTML首先应该写什么？<br><a href="https://cdn.nlark.com/yuque/0/2020/png/540849/1591635940872-c0193de6-fab9-4a23-979e-985cc090755d.png"></a><br>我们可以把语言改为中文<code>&lt;html lang=&quot;ch-ZN&quot;&gt;</code></p><h2 id="章节标签"><a href="#章节标签" class="headerlink" title="章节标签"></a>章节标签</h2><p>标题 h1~h6<br>章节 section<br>文章 article<br>段落 p<br>头部 header<br>脚部 footer<br>主要内容 main<br>旁支内容 aside<br>划分 div</p><p>小tips:<br>©的写法： <code>&amp;copy;</code></p><h2 id="全局属性：所有标签都有的属性"><a href="#全局属性：所有标签都有的属性" class="headerlink" title="全局属性：所有标签都有的属性"></a>全局属性：所有标签都有的属性</h2><ul><li>class<ul><li><code>&lt;div class=&quot;middle bordered&quot;&gt;&lt;/div&gt;</code></li></ul></li><li>contenteditable 让用户可以直接编辑内容</li><li>hidden<ul><li>隐藏标签</li></ul></li><li>id<ul><li>加上id以后可以调css</li><li>加上id以后可以用js<ul><li>id.style.border = “1px solid red”</li><li>但不提倡用这种写法， 因为这种写法对id的命名有要求，比如用parent, top, self等命名id就不行。因为window里有很多已经定义好的*局属性，不可以和这些属性同名。</li><li>所以不到万不得已不要用id，用class</li></ul></li></ul></li><li>style<ul><li>设置内联样式</li><li>对于style的优先级：<ul><li>JS &gt; HTML的style标签 &gt; CSS</li></ul></li></ul></li><li>tabindex<ul><li>正数，如tabindex=1 / 2/ 3/，表示按顺序访问</li><li>0， 表示最后访问</li><li>-1， 表示不要用tab访问</li></ul></li><li>title</li><li>用来显示完整内容</li><li>应用场景：文字超长变省略号</li><li>单行文字溢出：<ul><li>调整css</li><li>white-space: nowrap; 不要换行</li><li>text-overflow: ellipsis 溢出的部分用….</li><li>overflow: hidden; 溢出的部分隐藏</li></ul></li><li>但我希望，当鼠标移动到省略的地方上时，可以浮动地显示完整内容，就可以在title=”完整内容”，即可</li></ul><h2 id="如何让-lt-style-gt-标签显示在页面上？"><a href="#如何让-lt-style-gt-标签显示在页面上？" class="headerlink" title="如何让&lt;style&gt;标签显示在页面上？"></a>如何让<code>&lt;style&gt;</code>标签显示在页面上？</h2><p>把<code>&lt;style&gt;</code>放在<code>&lt;body&gt;</code>里面<br>然后设置 <code>style &#123;display: block&#125;</code><br>[][<a href="http://js.jirengu.com/xevecakopu/1/edit]">http://js.jirengu.com/xevecakopu/1/edit]</a><br>什么时候用class或Id？<br>不到万不得已不用Id。</p><h2 id="内容标签"><a href="#内容标签" class="headerlink" title="内容标签"></a>内容标签</h2><p>潜规则：HTML 代码里的多处空格、回车、tab 等内容，默认会被转化为一个空格<br>如果想保留多处空格、回车、tab等，就要用pre</p><ul><li><code>&lt;pre&gt;&lt;/pre&gt;</code> 保留空格、回车键； 其他标签会把多余的空格和回车键转换为一个空格</li><li><code>&lt;code&gt;&lt;/code&gt; </code>代码<ul><li>如果需要写换行的代码，嵌套一个pre标签即可</li><li><code>&lt;pre&gt;&lt;code&gt;var aaa = 1; console.log(a)&lt;/code&gt;&lt;/pre&gt;</code></li></ul></li><li><code>&lt;hr&gt;</code> 水平分隔线</li><li><code>&lt;br&gt;</code> 换行</li><li>ol li 有序列表</li><li>ul li 无序列表</li><li>dl + dt 要描述的对象 + dd 要描述的内容</li><li><code>&lt;em&gt;</code>和<code>&lt;strong&gt;</code> 表示强调<ul><li>em 表示语气上的强调</li><li>strong 表示内容本身很重要</li></ul></li><li>quote 行内引用</li><li>blockquote 换行的引用</li></ul><h2 id="reset-css-修改HTML默认样式"><a href="#reset-css-修改HTML默认样式" class="headerlink" title="reset.css 修改HTML默认样式"></a>reset.css 修改HTML默认样式</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs css">* &#123;<br>  <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">box-sizing</span>: border-box;<br>&#125;<br>*<span class="hljs-selector-pseudo">::before</span>,<br>*<span class="hljs-selector-pseudo">::after</span> &#123;<br>  <span class="hljs-attribute">box-sizing</span>: border-box;<br>&#125;<br><span class="hljs-selector-tag">a</span> &#123;<br>  <span class="hljs-attribute">color</span>: inherit;<br>  <span class="hljs-attribute">text-decoration</span>: none;<br>&#125;<br><span class="hljs-selector-tag">input</span>,<br><span class="hljs-selector-tag">button</span> &#123;<br>  <span class="hljs-attribute">font-family</span>: inherit;<br>&#125;<br><span class="hljs-selector-tag">ol</span>,<br><span class="hljs-selector-tag">ul</span> &#123;<br>  <span class="hljs-attribute">list-style</span>: none;<br>&#125;<br><span class="hljs-selector-tag">table</span> &#123;<br>  <span class="hljs-attribute">border-collapse</span>: collapse;<br>  <span class="hljs-attribute">border-spacing</span>: <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>HTML5语法概览</title>
    <link href="/2021/01/14/HTML5%E8%AF%AD%E6%B3%95%E6%A6%82%E8%A7%88/"/>
    <url>/2021/01/14/HTML5%E8%AF%AD%E6%B3%95%E6%A6%82%E8%A7%88/</url>
    
    <content type="html"><![CDATA[<h2 id="前言-今天我们正式开始HTML5的学习"><a href="#前言-今天我们正式开始HTML5的学习" class="headerlink" title="前言:今天我们正式开始HTML5的学习"></a>前言:今天我们正式开始HTML5的学习</h2><h1 id="HTML5语法概览"><a href="#HTML5语法概览" class="headerlink" title="HTML5语法概览"></a>HTML5语法概览</h1><h2 id=""><a href="#" class="headerlink" title=""></a><!DOCTYPE html></h2><p>DOCTYPE就是文档类型，这句话就是告诉浏览器：我是HTML, 请按照解析HTML的方式解析我</p><h3 id="内容"><a href="#内容" class="headerlink" title="内容"></a><tag attr=value>内容</tag></h3><p>属性值加引号的规则：</p><ol><li>如果是普通字符，可以不用加引号</li><li>如果属性名包含特殊字符，如空格，则要加引号，如<code>&lt;div id=&quot;a c fun&quot;&gt;hello world&lt;/div&gt;</code></li></ol><h3 id="内容-1"><a href="#内容-1" class="headerlink" title="内容"></a><tag attr>内容</tag></h3><p>例子：<code>&lt;input type=&quot;checkbox&quot; checked&gt;</code><br>如果写了checked, 这个<br><a href="https://cdn.nlark.com/yuque/0/2020/png/540849/1591603063830-fdc32e6c-cbae-4d43-8d47-638de860a004.png"></a></p><p>需要注意的是，<em>只要写了chekced, 复选框就会被勾上，即使写成checked=”false”也会被勾上</em></p><h3 id="-1"><a href="#-1" class="headerlink" title=""></a><tag attr=value></h3><p>标签自动闭合，不需要再写<code>&lt;/tag&gt;</code>，也不需要多加一个斜杠<code>&lt;tag attr=value /&gt;</code></p><h2 id="标签大小写有区别吗？"><a href="#标签大小写有区别吗？" class="headerlink" title="标签大小写有区别吗？"></a>标签大小写有区别吗？</h2><p>功能在没有区别，但最好是用小写</p><h2 id="HTML如何调试"><a href="#HTML如何调试" class="headerlink" title="HTML如何调试"></a>HTML如何调试</h2><ol><li>看 VSCode 的颜色提示，虽然大部分时候看不出来</li><li>看 WebStorm 的颜色提示</li><li>使用 HTML5 验证器(npm i -g node-w3c-validator)<h2 id="在哪里查询HTML的资料"><a href="#在哪里查询HTML的资料" class="headerlink" title="在哪里查询HTML的资料"></a>在哪里查询HTML的资料</h2>谷歌 mdn + 标签</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>git远程仓库</title>
    <link href="/2021/01/13/git%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/"/>
    <url>/2021/01/13/git%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<h2 id="前言-和我一起开始git远程仓库的学习吧"><a href="#前言-和我一起开始git远程仓库的学习吧" class="headerlink" title="前言:和我一起开始git远程仓库的学习吧"></a>前言:和我一起开始git远程仓库的学习吧</h2><h1 id="git远程仓库"><a href="#git远程仓库" class="headerlink" title="git远程仓库"></a>git远程仓库</h1><h2 id="1-利用ssh-sky方式本地连接远程"><a href="#1-利用ssh-sky方式本地连接远程" class="headerlink" title="1.利用ssh sky方式本地连接远程"></a>1.利用ssh sky方式本地连接远程</h2><hr><h3 id="如果有本地仓库"><a href="#如果有本地仓库" class="headerlink" title="如果有本地仓库:"></a>如果有本地仓库:</h3><p>ssh-keygen -t rsa -b 4096 -C “<a href="mailto:&#x79;&#111;&#x75;&#114;&#x5f;&#101;&#x6d;&#97;&#x69;&#x6c;&#x40;&#101;&#x78;&#97;&#109;&#112;&#x6c;&#x65;&#x2e;&#99;&#x6f;&#109;">&#x79;&#111;&#x75;&#114;&#x5f;&#101;&#x6d;&#97;&#x69;&#x6c;&#x40;&#101;&#x78;&#97;&#109;&#112;&#x6c;&#x65;&#x2e;&#99;&#x6f;&#109;</a>“(新建项目中有代码直接赋值)<br>一直回车,直到没有提示<br>cat ~/.ssh/id-rsa.pub得到公钥内容,黏贴到github设置中的ssh-key中.(如果成功会出现一段很长的公钥代码)<br>测试:ssh -T <a href="mailto:&#103;&#105;&#116;&#x40;&#103;&#105;&#x74;&#x68;&#x75;&#x62;&#x2e;&#99;&#111;&#x6d;">&#103;&#105;&#116;&#x40;&#103;&#105;&#x74;&#x68;&#x75;&#x62;&#x2e;&#99;&#111;&#x6d;</a> (如果成功,出现名字以及带success字眼的句子)</p><h3 id="如果没有本地仓库"><a href="#如果没有本地仓库" class="headerlink" title="如果没有本地仓库"></a>如果没有本地仓库</h3><p>git init<br>git add xxx<br>git commit -v<br>先创建一个本地仓库在进行上述操作。<br>不想上传的文件可以放在.ignore文件中。</p><hr><h2 id="2-上传与下载"><a href="#2-上传与下载" class="headerlink" title="2.上传与下载"></a>2.上传与下载</h2><h3 id="上传"><a href="#上传" class="headerlink" title="上传"></a>上传</h3><hr><p>与远程仓库链接好后就可以进行上传以及下载了</p><p>git remote add origin git@xxxxx(上传到远程的master分支)<br>在本地添加远程仓库<br>origin是远程仓库,可以换,建议不换<br>不要使用https://,每次都需要密码</p><p>git push -u origin master<br>推送本master分支到远程origin的master分支<br>如果提示一个git pull一下,就git pull一下<br>git是先把远程分支合并到本地对于的分支<br>如果远程分支没有更新过就忽略git pull<br>-u origin master的意思是设置上游分支<br>之后就不用设置上游分支了,直接git pull;git push</p><p>如何上传其他分支<br>git push origin x:x</p><p>可以指定版本提交<br>git reset –hard XXXXXX指定版本的前六位<br>git log/git reflog可以查看指点版本<br>注意:在切换版本之前一定要确定所有主要的内容都被git commit了,否则没有被提交的会被删除</p><hr><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><hr><p>git clone git@xxxx[目标路径].git<br>如果是不同路径,要写上传的新的ssh key(一机一key)<br>cd 目标路径<br>git add//git commit//[git pull]//git push四连操作</p><p>git clone <a href="mailto:&#x67;&#105;&#116;&#x40;&#120;&#x78;&#120;&#x2e;&#x67;&#105;&#116;">&#x67;&#105;&#116;&#x40;&#120;&#x78;&#120;&#x2e;&#x67;&#105;&#116;</a> yyy<br>会在本地创建yyy目录<br>cd进yyy目录</p><p>git clone git@xxxx[目标路径].git .<br>最后一个字符是.,注意有空格<br>不会创建新目录<br>使用当前目录容纳代码和.git<br>当前目录最好是空目录</p><p>如何下载某个分支<br>先下载整个仓库,然后git checkout分支名</p><hr><h2 id="3-切换远程仓库"><a href="#3-切换远程仓库" class="headerlink" title="3.切换远程仓库"></a>3.切换远程仓库</h2><hr><p>git remote -v查看当前连接的远程仓库<br>git remote set-url origin 项目ssh地址</p><hr><h2 id="4-切换到制定版本"><a href="#4-切换到制定版本" class="headerlink" title="4.切换到制定版本"></a>4.切换到制定版本</h2><p>git reser –hard<br>经验之谈:当新建了一个远程仓库并且需要向此远程仓库添加最近的项目时记得新建一个本地仓库git init。</p><h2 id="5-一些踩坑经历"><a href="#5-一些踩坑经历" class="headerlink" title="5.一些踩坑经历"></a>5.一些踩坑经历</h2><p>【git 端口拒绝解决方案】ssh: connect to host github.com port 22: Connection refused<br>连接:<a href="https://blog.csdn.net/s740556472/article/details/80318886">https://blog.csdn.net/s740556472/article/details/80318886</a></p><p>删除远程仓库进入该仓库–&gt;setting–&gt;Danger Zone–&gt;Delete repository</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1554318/1606966460157-caba2081-209d-4f5c-800c-e8da61ad48e8.png"></p><p>从本地删除远程仓库中的文件<br><a href="https://blog.csdn.net/weixin_43228497/article/details/83176755?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.control&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.control">神秘地址</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>git本地仓库</title>
    <link href="/2021/01/13/git%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93/"/>
    <url>/2021/01/13/git%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<h2 id="前言-和我一起开始git本地仓库的学习吧"><a href="#前言-和我一起开始git本地仓库的学习吧" class="headerlink" title="前言:和我一起开始git本地仓库的学习吧"></a>前言:和我一起开始git本地仓库的学习吧</h2><h1 id="git本地仓库"><a href="#git本地仓库" class="headerlink" title="git本地仓库"></a>git本地仓库</h1><h2 id="1-git是什么"><a href="#1-git是什么" class="headerlink" title="1.git是什么"></a>1.git是什么</h2><p>git是开启github的钥匙<br>git只是一个命令而已,Bash命令行中有很多命令<br>git可以解决的问题:版本控制。</p><h2 id="2-git-config配置git"><a href="#2-git-config配置git" class="headerlink" title="2.git config配置git"></a>2.git config配置git</h2><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs verilog">git <span class="hljs-keyword">config</span> --<span class="hljs-keyword">global</span> user<span class="hljs-variable">.name</span> 你的英文名<br>git <span class="hljs-keyword">config</span> --<span class="hljs-keyword">global</span> user<span class="hljs-variable">.email</span> 你的邮箱<br>git <span class="hljs-keyword">config</span> --<span class="hljs-keyword">global</span> push<span class="hljs-variable">.default</span> simple<br>git <span class="hljs-keyword">config</span> --<span class="hljs-keyword">global</span> core<span class="hljs-variable">.quotepath</span> false<br>git <span class="hljs-keyword">config</span> --<span class="hljs-keyword">global</span> core<span class="hljs-variable">.editor</span> <span class="hljs-string">&quot;code --wait&quot;</span><br>git <span class="hljs-keyword">config</span> --<span class="hljs-keyword">global</span> core<span class="hljs-variable">.autocrlf</span> <span class="hljs-keyword">input</span><br></code></pre></td></tr></table></figure><p>注意：上面的英文名和邮箱跟 GitHub 没有关系。<br>可以跟 GitHub 的用户名和邮箱保持一致，<br>也可以不一致。我的是一致的。</p><p>注意：你需要保证 code 是可以直接在命令行执行的。<br>如果不能执行，你需要安装 VSCode 并配置 PATH。<br>我的 PATH 里添加的内容是<br>C:\Users\Fang\AppData\Local\Programs\Microsoft VS Code\bin</p><h2 id="3-git-常见命令"><a href="#3-git-常见命令" class="headerlink" title="3.git 常见命令"></a>3.git 常见命令</h2><ul><li>git init 初始化<ul><li>git init会创建.git目录</li></ul></li><li>git add 路径 标记要被提交的文件</li><li>.gitignore 一个文件 里面放着那些不要被提交的文件</li><li>git commit -m 字符串  提交并说明理由(字符串中如果有空格就用””包起来)</li><li>git commit -v 功能同上 不过会打开vscode文件写注释(推荐使用) </li><li>git log 查看历史创建版本以及注释 只会查看当前最新版本之前的所有版本</li><li>git reset –hard 版本前六位  返回指定版本</li><li>git reflog  查看全部历史版本(高级)</li><li>git status  状态信息</li><li>git status -sb 状态简写</li><li>git branch x 创建另外一个版本(虚的)</li><li>git checkout x/master 切换分支 ()</li><li>git branch 查看当前在那条线上</li><li>git merge 将一个分支合并到当前分支<ul><li>注意:如果合并时产生冲突<ul><li>解决步骤:</li></ul><ol><li>发现冲突(conflict)并使用git status查看哪个文件冲突了</li><li>解决冲突<ol><li>依次打开文件</li><li>搜索====四个等号</li><li>在上下两部分中选择要保留的代码</li><li>可以只选择上面,也可以只选择下面</li><li>删除不用的代码,删除====,&gt;&gt;&gt;&gt;,&lt;&lt;&lt;&lt;这些标记</li><li>git add对应文件</li><li>再次git status -sb ，解决下一个文件的冲突。</li><li>直到没有冲突,运行git commit(注意不需要选项)。</li><li>git branch -d x删除无用的x 分支</li></ol></li></ol></li></ul></li></ul><p>一些细节:</p><ul><li>大部分时候,只需要使用git add.和git commit -v操作即可</li><li>使用时git reset –hard 指定版本前六位之前必须确保所有重要代码都commit了,因为处于被add标识过但是没有commit的文件全部都会被删除</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>npm命令行入门</title>
    <link href="/2021/01/13/%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%85%A5%E9%97%A8/"/>
    <url>/2021/01/13/%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="前言-和我一起开始npm的学习吧"><a href="#前言-和我一起开始npm的学习吧" class="headerlink" title="前言:和我一起开始npm的学习吧"></a>前言:和我一起开始npm的学习吧</h2><h1 id="npm命令行入门"><a href="#npm命令行入门" class="headerlink" title="npm命令行入门"></a>npm命令行入门</h1><h2 id="1-查"><a href="#1-查" class="headerlink" title="1.查"></a>1.查</h2><ul><li>pwd 查看当前路径</li><li>ls 查看当前路径的内容</li><li>ls 路径 查看指定路径的内容</li><li>查看文件内容<ul><li>cat 路径  全部打印</li><li>head 路径  打印前10行<ul><li>设置参数看前14行</li><li>head ./style.css -n 14</li></ul></li><li>tail 路径 打印后10行</li><li>less 路径 翻页<ul><li>退出less: 按q (q就是quit)</li></ul></li></ul></li></ul><h2 id="2-增"><a href="#2-增" class="headerlink" title="2.增"></a>2.增</h2><ul><li>创建1.txt<ul><li>touch 1.txt</li><li>echo xxxx &gt; 2.txt</li><li>echo hi &gt; 2.txt</li><li>2.txt 的内容只有hi, 没有xxxx</li><li><blockquote><p>会覆盖掉之前的文件内容，如果要追加，应该用两个&gt;&gt;</p></blockquote></li><li>echo world &gt;&gt; 2.txt<ul><li>现在2.txt里面就有hi world</li></ul></li><li>如果想同时添加多行内容，用参数-e, 用引号里写上\n,”a\nb”<ul><li>echo -e “hungry\nPanda” &gt;&gt;2.txt</li></ul></li></ul></li><li>创建目录 a/<ul><li>mkdir a/</li></ul></li><li>创建多层目录<ul><li>mkdir -p a/b/c</li></ul></li><li>同时创建多个文件<ul><li>touch 1.txt 2.txt</li></ul></li><li>同时创建多个目录<ul><li>mkdir -p a/b/c a/d/c</li></ul></li><li>复制文件<ul><li>cp 1.txt 2.txt</li></ul></li><li>复制文件夹，要用-r参数<ul><li>cp -r a b    把a文件夹的内容递归地复制到b文件夹</li></ul></li></ul><h2 id="3-删"><a href="#3-删" class="headerlink" title="3.删"></a>3.删</h2><ul><li>rm 1.txt</li><li>rm -r a  删除a文件夹</li></ul><h2 id="4-改"><a href="#4-改" class="headerlink" title="4.改"></a>4.改</h2><ol><li>改文件名字， 移动和重命名是同一个操作<br>mv 1.txt 2.txt<br>mv 1.txt  a/1.txt  把1.txt 移动到a文件夹</li><li>更新文件的最后更新时间<br>touch 文件名</li></ol><hr><p>记不住命令行用法咋办？<br>npm i ig tldr 安装tldr插件<br>tldr 命令 就可以查看此命令的具体操作啦<br>ls –help | less 翻页查看</p><hr>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>高颜值命令行工具cmder</title>
    <link href="/2021/01/12/%E9%AB%98%E9%A2%9C%E5%80%BC%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7cmder/"/>
    <url>/2021/01/12/%E9%AB%98%E9%A2%9C%E5%80%BC%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7cmder/</url>
    
    <content type="html"><![CDATA[<h1 id="cmder简介"><a href="#cmder简介" class="headerlink" title="cmder简介"></a>cmder简介</h1><p>如果你对windows环境下的cmd命令行工具的界面感觉不友好，是时候考虑换一个舒心的工具了<br>Cmder是一款Windows环境下非常简洁美观易用的cmd替代者，它支持了大部分的Linux命令。</p><hr><h2 id="cmder下载安装"><a href="#cmder下载安装" class="headerlink" title="cmder下载安装"></a>cmder下载安装</h2><p>如果你网络不好下载慢，就用这些国内链接吧，下载超快<br>cmder 安装包<br>下载链接：<a href="https://free-2019.oss-cn-beijing.aliyuncs.com/cmder.zip">cmder</a><br>下载完之后，解压到 cmder 文件夹。然后把 cmder 文件夹放到 D:\Software 之类的目录里。<br>解压后，cmder.exe 的路径应该是 D:\Software\cmder\cmder.exe<br>这两种都是错误的：</p><ul><li>D:\Software\cmder.exe 错，因为少了一个 cmder 目录</li><li>D:\Software\cmder\cmder\cmder.exe 错，因为多了一个 cmder 目录</li></ul><p>请仔细核对路径，如果错了，就删掉目录重新再解压，一定要准确无误。</p><p>安装完之后打开cmder<br>长这样<br><img src="data:image/jpeg;base64,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" alt="cmder"></p><h2 id="cmder配置相关"><a href="#cmder配置相关" class="headerlink" title="cmder配置相关"></a>cmder配置相关</h2><p>关于配置,由于个人有个人的爱好,我是参考这篇文章进行配置的,在此推荐给大家。<br><a href="https://www.jianshu.com/p/5b7c985240a7">使用Cmder替换cmd，让开发更高效</a></p><h2 id="VSCode-中关于-Cmder-的配置"><a href="#VSCode-中关于-Cmder-的配置" class="headerlink" title="VSCode 中关于 Cmder 的配置"></a>VSCode 中关于 Cmder 的配置</h2><p>VSCode用ctrl+shift+p打开配置json<br>将json中的git.enabled,git.path,terminal.integrated.<br>请自行替换 cmder 根目录，不要完全照搬（Mac/Linux 用户不需要配置）</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-string">&quot;git.enabled&quot;</span>: <span class="hljs-literal">true</span>,<br><span class="hljs-string">&quot;git.path&quot;</span>: <span class="hljs-string">&quot;D:<span class="hljs-subst">\\</span>Fang<span class="hljs-subst">\\</span>Software<span class="hljs-subst">\\</span>cmder<span class="hljs-subst">\\</span>vendor<span class="hljs-subst">\\</span>git-for-windows<span class="hljs-subst">\\</span>cmd<span class="hljs-subst">\\</span>git.exe&quot;</span>,<br><span class="hljs-string">&quot;terminal.integrated.shell.windows&quot;</span>: <span class="hljs-string">&quot;D:<span class="hljs-subst">\\</span>Fang<span class="hljs-subst">\\</span>Software<span class="hljs-subst">\\</span>cmder<span class="hljs-subst">\\</span>vendor<span class="hljs-subst">\\</span>git-for-windows<span class="hljs-subst">\\</span>bin<span class="hljs-subst">\\</span>bash.exe&quot;</span>,<br></code></pre></td></tr></table></figure><p>第二行必须是 git.exe 结尾，第三行必须是 bash.exe 结尾。不能写成 git-bash.exe</p><p>然后重启VSCode,按下crtl+`就可以在VSCode打开cmder</p><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><p>问：在 cmder 里运行 cd ~ 提示找不到目录怎么办？<br>答：打开cmder的设置，按下图设置启动任务<br><a href="https://static.xiedaimala.com/xdml/image/3ac7c224-c23d-491f-84b5-4fabfbeab9b8/2019-8-27-13-18-2.png">images</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Surf_the_Internet(git篇)</title>
    <link href="/2021/01/12/Surf-the-Internet3/"/>
    <url>/2021/01/12/Surf-the-Internet3/</url>
    
    <content type="html"><![CDATA[<p>如果你看不到本教程中的图片，说明图片被墙了。你需要开起全局翻墙（或者将 raw.githubusercontent.com 加入翻墙白名单）才能观看图片。</p><p>长久以来，很多同学用 git 是都发现很慢很慢。那是因为 git 不会走你的小飞机代理。</p><p>现在教大家一个用 Proxifier + Shadowsocks 让 git clone 走小飞机代理，满速下载的方法。</p><p>如果你现在还不会使用 Git，那么请你在学会 Git 之后再来看这篇教程！</p><p>目录</p><ol><li>Windows命令行FQ</li><li>Mac命令行FQ</li><li>Linux命令行FQ</li></ol><h1 id="Windows命令行FQ"><a href="#Windows命令行FQ" class="headerlink" title="Windows命令行FQ"></a>Windows命令行FQ</h1><h2 id="确保-Shadowsocks-可以翻墙"><a href="#确保-Shadowsocks-可以翻墙" class="headerlink" title="确保 Shadowsocks 可以翻墙"></a>确保 Shadowsocks 可以翻墙</h2><p>请确保自己可以访问 twitter.com 后，才可以进行后面的步骤了</p><h2 id="下载-Proxifier"><a href="#下载-Proxifier" class="headerlink" title="下载 Proxifier"></a>下载 Proxifier</h2><p><a href="https://pc.qq.com/detail/13/detail_10593.html">下载安装包</a>,并安装</p><p>如果软件提示需要输入注册码，就用下面的注册码（没提示怎么办？没提示你就偷着乐呗，还能怎么办）</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">L6Z8A</span>-XY<span class="hljs-number">2</span>J<span class="hljs-number">4</span>-BTZ<span class="hljs-number">3</span>P-ZZ<span class="hljs-number">7</span>DF-A<span class="hljs-number">2</span>Q<span class="hljs-number">9</span>C（Portable Edition）<br><br><span class="hljs-attribute">5EZ8G</span>-C<span class="hljs-number">3</span>WL<span class="hljs-number">5</span>-B<span class="hljs-number">56</span>YG-SCXM<span class="hljs-number">9</span>-<span class="hljs-number">6</span>QZAP（Standard Edition）<br><br><span class="hljs-attribute">P427L</span>-<span class="hljs-number">9</span>Y<span class="hljs-number">552</span>-<span class="hljs-number">5433</span>E-<span class="hljs-number">8</span>DSR<span class="hljs-number">3</span>-<span class="hljs-number">58</span>Z<span class="hljs-number">68</span>（MAC）<br><br></code></pre></td></tr></table></figure><h2 id="配置-Proxifier"><a href="#配置-Proxifier" class="headerlink" title="配置 Proxifier"></a>配置 Proxifier</h2><p>打开软件是这样：<br><a href="https://user-images.githubusercontent.com/59866634/72331334-fc3c0980-36f2-11ea-85ac-6ea92ccfe260.png">images</a><br>点击按钮1 -&gt; Add ，按下图填写（1080 是 Shadowsocks 默认的本地代理端口）<br><img src="https://user-images.githubusercontent.com/59866634/72331369-0fe77000-36f3-11ea-95da-864d876c58c5.png" alt="wait"><br>点击两次 OK（其中会有一次弹框，点「是」）。然后点击按钮2：</p><h2 id="首先我们要让-Shadowsocks-自身不被自己代理（不然就死循环了）。"><a href="#首先我们要让-Shadowsocks-自身不被自己代理（不然就死循环了）。" class="headerlink" title="首先我们要让 Shadowsocks 自身不被自己代理（不然就死循环了）。"></a>首先我们要让 Shadowsocks 自身不被自己代理（不然就死循环了）。</h2><p>点击 Add，按下图填写：<br><img src="https://user-images.githubusercontent.com/59866634/72331464-31485c00-36f3-11ea-92ba-750dfab5b250.png" alt="wait"><br>其中第二项的 shadowsocks.exe 是文件路径，如果你找不到，可以直接把 shadowsocks.exe 这个单词复制进去，一样能用。如果你用的是 ssr，那么就要把 shadowsocksr.exe 填进去。多个值用分号隔开。</p><p>如果你用的是 Trojan，那么这里应该填 Trojan 可执行文件的文件名，比如 trojan-qt5.exe</p><h2 id="然后让所有流向-github-com-的流量走代理"><a href="#然后让所有流向-github-com-的流量走代理" class="headerlink" title="然后让所有流向 *.github.com 的流量走代理"></a>然后让所有流向 *.github.com 的流量走代理</h2><p>点击 Add，按下图填写：<br><img src="https://user-images.githubusercontent.com/59866634/72331495-40c7a500-36f3-11ea-8061-53a2e1383c31.png" alt="wait"><br>最终结果如下：<br><img src="https://user-images.githubusercontent.com/59866634/72331517-47561c80-36f3-11ea-9edd-46a6cc953d7a.png" alt="wait"><br>然后只要你开着 Shadowsocks（全局代理是否开启无所谓，我一般选择禁用或手动）、Proxifier，那么 git clone 就能满速了！</p><h1 id="Mac命令行FQ"><a href="#Mac命令行FQ" class="headerlink" title="Mac命令行FQ"></a>Mac命令行FQ</h1><ol><li>安装 homebrew<br><code>/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</code></li><li>安装 proxychains-ng<br><code>brew install proxychains-ng</code></li><li>配置proxychains-ng</li></ol><ul><li>安装 proxychains-ng</li><li>下载配置文件（如果下面的命令执行失败，那你就自己下载<a href="https://raw.githubusercontent.com/FrankFang/dot-files/master/proxychains.conf">proxychains.conf</a>，然后将其移动到 ~/.proxychains.conf）<ul><li><code>curl -L https://raw.githubusercontent.com/FrankFang/dot-files/master/proxychains.conf &gt; ~/.proxychains.conf</code></li></ul></li><li>添加 bash alias，运行<ul><li><code>touch ~/.bashrc; echo &#39;alias pc=&quot;proxychains4 -f ~/.proxychains.conf&quot;&#39; &gt;&gt; ~/.bashrc</code></li></ul></li><li>source ~/.bashrc</li><li>pc git clone xxx 或者 pc brew install xxx –verbose，那么这个命令行就是翻墙的</li></ul><h1 id="Linux命令行FQ"><a href="#Linux命令行FQ" class="headerlink" title="Linux命令行FQ"></a>Linux命令行FQ</h1><ol><li>去 github 下载 proxychains-ng 的源码</li><li>make 编译<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs vim"># needs <span class="hljs-keyword">a</span> working C <span class="hljs-keyword">compiler</span>, preferably gcc<br>./configure --prefix=/usr --sysconfdir=/etc<br><span class="hljs-keyword">make</span><br>[optional] sudo <span class="hljs-keyword">make</span> install<br>[optional] sudo <span class="hljs-keyword">make</span> install-config (installs proxychains.<span class="hljs-keyword">conf</span>)<br><br><span class="hljs-keyword">if</span> you dont install, you can use proxychains from the build directory<br>like thi<span class="hljs-variable">s:</span> ./proxychains4 -<span class="hljs-keyword">f</span> src/proxychains.<span class="hljs-keyword">conf</span> telnet google.<span class="hljs-keyword">com</span> <span class="hljs-number">80</span><br></code></pre></td></tr></table></figure></li><li>配置proxychains-ng</li></ol><ul><li>安装 proxychains-ng</li><li>下载配置文件 （如果下面的命令执行失败，那你就自己下载，<a href="https://raw.githubusercontent.com/FrankFang/dot-files/master/proxychains.conf">proxychains.conf</a>然后将其移动到 ~/.proxychains.conf）<ul><li><code>curl -L https://raw.githubusercontent.com/FrankFang/dot-files/master/proxychains.conf &gt; ~/.proxychains.conf</code></li></ul></li><li>添加 bash alias，运行<ul><li><code>touch ~/.bashrc; echo &#39;alias pc=&quot;proxychains4 -f ~/.proxychains.conf&quot;&#39; &gt;&gt; ~/.bashrc</code></li></ul></li><li>source ~/.bashrc</li><li>pc git clone xxx 或者 pc brew install xxx –verbose，那么这个命令行就是翻墙的。</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Surf_the_Internet(插件篇)</title>
    <link href="/2021/01/12/Surf-the-Internet/"/>
    <url>/2021/01/12/Surf-the-Internet/</url>
    
    <content type="html"><![CDATA[<p>请确保你的小飞机全局翻墙可以用了，再阅读本教程！</p><p>如果你看不到本教程中的图片，说明图片被墙了。你需要开起全局翻墙（或者将 raw.githubusercontent.com 加入翻墙白名单）才能观看图片。</p><p>Chrome 插件配合 Shadowsocks 使用，效果奇佳。</p><ol><li>打开 SS 代理（比如 Trojan），开启全局模式</li><li><a href="https://chrome.google.com/webstore/detail/proxy-switchyomega/padekgcemlokbadohgkifijomclgjgif">安装插件</a></li><li>下载备份文件:<a href="https://raw.githubusercontent.com/sun-shadow/Surf_the_Internet/master/OmegaOptions.bak.zip">OmegaOptions-2020.zip</a>(29.7 KB) 并解压，里面有一个 OmegaOptions.bak 文件</li><li>在 Chrome 的插件栏右键点击图标，然后选择「选项」<br><img src="https://user-images.githubusercontent.com/59866634/72330854-2d680a00-36f2-11ea-96ae-5317075310ed.png" alt="wait"></li><li>在弹出的配置页面里点击「导入/导出」，点击「从备份文件恢复」，选中刚刚下载的OmegaOptions.bak，最后点击左边的「应用选项」即可。一定要点击「应用选项」！<br><img src="https://user-images.githubusercontent.com/59866634/72330908-483a7e80-36f2-11ea-976c-73e21f8447b7.png" alt="wait"></li><li>回到浏览器页面，选中插件的「自动切换（auto switch）」模式<br><img src="https://user-images.githubusercontent.com/59866634/72330958-5d171200-36f2-11ea-9836-1192b0cef630.png" alt="wait"></li><li>设置好自动切换后，就可以禁用 SS 的全局代理了（改为直连模式，这样国内的网站就变快了），在浏览器访问<a href="https://twitter.com/">推特</a>看看是不是能用了，同时 <a href="https://www.baidu.com/">百度</a>是不是很快。<br><img src="https://user-images.githubusercontent.com/59866634/72331022-6f914b80-36f2-11ea-8171-273f8aadc9ec.png" alt="wait"></li><li>如果遇到一些网站被墙，通过浏览器插件的「添加条件」按钮把网站域名添加进去就可以自动 FQ 了。这个插件还有一个牛逼的地方，假设你下载某个外国的文件速度很慢，只需要点击「添加条件」按钮，添加对应的域名，然后重新下载，速度就飞起来了。<br><img src="https://user-images.githubusercontent.com/59866634/72331056-8041c180-36f2-11ea-852b-78d11ddb8cf8.png" alt="wait"><br>完。<br>第三篇是终极教程：《如何让 Git 翻墙》</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Surf_the_Internet(入门篇)</title>
    <link href="/2021/01/12/%E7%A7%91%E5%AD%A6%E4%B8%8A%E6%96%87%E5%B0%8F%E7%A7%98%E6%8B%9B/"/>
    <url>/2021/01/12/%E7%A7%91%E5%AD%A6%E4%B8%8A%E6%96%87%E5%B0%8F%E7%A7%98%E6%8B%9B/</url>
    
    <content type="html"><![CDATA[<p>本系列教程一共三篇</p><ol><li>入门篇（2020年4月更新）</li><li>如何用 Chrome 插件 FQ</li><li>命令行如何 FQ</li></ol><hr><p>以下将「翻墙」简称为「FQ」，本文教你如何使用 Trojan 来 FQ。</p><ol><li>购买代理服务器（付款前在群里询问一下是否可用再买，防止买了不能用）<ol><li>进入 <a href="https://portal.shadowsocks.nz/aff.php">SS 网站</a>  购买服务器<ol><li>请购买最便宜的套餐，不用担心流量不够，因为随时可以购买流量补充包。</li><li>不用注册，你购买的时候会提示你注册的。</li><li>购买的时候会让你填各种信息，你只要保证邮箱是你的即可，其他信息可以瞎填。</li></ol></li><li>如果你已经在其他地方购买了代理服务器，则可跳过此步骤 总之你需要有一个服务器地址才行。买了服务器地址，才能配置客户端(后面我会介绍终极白嫖法)</li></ol></li><li>下载客户端<ol><li>还是刚才的网站，通过顶部通知的第一个链接进入<a href="https://portal.shadowsocks.nz/knowledgebase/151/">进入Trojan 服务客户端设置教程索引 页面</a></li><li>在页面中找到 Windows 章节（如果你是 Mac 用户就看 Mac 章节），点击进入「Trojan-QT5 设置方法」，下文简称为「教程」</li><li>根据该教程的说明，依次进行（请优先查看该教程，如果教程内容与本文有出入，请以该教程为准）如果下面的操作你试了两边之后还是没有成功，可以找我要视频教程。<ol><li>下载客户端：点击它给出的链接，找到 Trojan-Qt5-Windows.[版本号].zip 下载，解压到 trojan-xxx 目录，然后把 trojan-xxx 目录放到 D:\Software\ 目录（可换成其他目录）里面，比如我的最终目录是 D:\Software\Trojan-Qt5-Windows-0.0.9\</li><li>双击 trojan-qt5.exe 打开软件，系统托盘里会出现一个小木马图标。</li><li>通过「订阅」按钮添加节点，怎么找到订阅按钮请查看该教程第 3 节第一段给出的<a href="https://portal.shadowsocks.nz/knowledgebase">链接，里面有图文介绍。</a></li><li>右键点击屏幕右下角托盘里的小木马图标，然后找到「服务器订阅」 =&gt;「更新trojan服务器订阅」以及「更新trojan服务器订阅(不通过代理)」按钮，分别点击之</li><li>等待1分钟后，右键点击屏幕右下角托盘里的小木马图标，然后找到「服务器」，就应该可以看见一大片 IP 列表了</li><li>双击小木马，点击菜单栏里的「设置 -&gt; 常规设置 -&gt; 入站设置」，将 socks5 端口号改为 1080（如果已经是 1080 就不用再改）</li><li>双击小木马，看到 IP 列表，随便选择一个 IP，右键，连接。<ol><li>如果状态变成 Connected 就说明连接成功了。</li><li>如果连接失败，可能是 1080 端口被占用，解决方法见<a href="https://github.com/sun-shadow/Surf_the_Internet/blob/master/%E7%AB%AF%E5%8F%A3%E5%8D%A0%E7%94%A8%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95.md">这里</a>。但也可能是 IP 被墙，那么就换个 IP 连接试试。</li></ol></li><li>然后右键点击屏幕右下角托盘里的小木马图标，然后点击「打开 Trojan」<ol><li>右键点击屏幕右下角托盘里的小木马图标，点击「系统代理模式」=&gt;「PAC模式」或者「全局模式」</li></ol></li><li>如果你用 trojan 发现还是不能翻墙，可以看看 SS 网站提供的其他翻墙客户端，比如 Clash 或者 Clashy，都可以试试。</li></ol></li></ol></li><li>测试<ol><li>尝试用 Chrome 访问 facebook.com，看看是否能连接成功吧！</li><li>如果失败了，换一个 ip 重新试试，有些 ip 能用，有些 ip 不能用。</li><li>如果又失败了，就试着把上面的步骤全部重新做一遍</li></ol></li><li>自动连接<ol><li>双击小木马，找到刚刚连接成功的 IP，右键，编辑。</li><li>勾选「程序启动时自动连接」，搞定。以后软件一启动就会连接这个 IP 了。</li></ol></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这种全局 FQ 的方式有一个缺点，那就是访问国外的网站变快，但是国内的网站缺巨慢无比，怎么解决了？</p><ol><li>使用 PAC 模式，但 PAC 模式也有缺点，比如自定义翻墙白名单不方便。</li><li>也可以看我的第二篇教程</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>hexo建站记录</title>
    <link href="/2021/01/11/hexo%E5%BB%BA%E7%AB%99%E8%AE%B0%E5%BD%95/"/>
    <url>/2021/01/11/hexo%E5%BB%BA%E7%AB%99%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<p>前言:拥有自己的博客网站，是很多程序猿萌新梦寐以求的事儿，我也一样</p><p>现在的博客网站分两种，静态博客和动态博客</p><p>由于自己现在只懂前端知识，后端也就能写个接口的水平</p><p>故选择静态博客，等以后自己再撸一个动态博客，当然也是后话了，开整！！</p><hr><h1 id="Hexo简介"><a href="#Hexo简介" class="headerlink" title="Hexo简介"></a>Hexo简介</h1><p>Hexo是一款基于Node.js的静态博客框架，依赖少易于安装使用，可以方便的生成静态网页托管在GitHub和Coding上，是搭建博客的首选框架。大家可以进入hexo官网进行详细查看，因为Hexo的创建者是台湾人，对中文的支持很友好，可以选择中文进行查看。</p><p>教程分三个部分</p><ul><li>第一部分：hexo的初级搭建还有部署到github page上，以及个人域名的绑定。</li><li>第二部分：hexo的基本配置，更换主题，实现多终端工作，以及在coding page部署实现国内外分流</li><li>第三部分：hexo添加各种功能，包括搜索的SEO，阅读量统计，访问量统计和评论系统等。</li></ul><h1 id="第一部分"><a href="#第一部分" class="headerlink" title="第一部分"></a>第一部分</h1><p>hexo的初级搭建还有部署到github page上，以及个人域名的绑定。</p><h2 id="Hexo搭建步骤"><a href="#Hexo搭建步骤" class="headerlink" title="Hexo搭建步骤"></a>Hexo搭建步骤</h2><ol><li>安装Git</li><li>安装Node.js</li><li>安装Hexo</li><li>GitHub创建个人仓库</li><li>生成SSH添加到GitHub</li><li>将hexo部署到GitHub</li><li>设置个人域名</li><li>发布文章</li></ol><h3 id="1-安装Git"><a href="#1-安装Git" class="headerlink" title="1. 安装Git"></a>1. 安装Git</h3><p>Git是目前世界上最先进的分布式版本控制系统，可以有效、高速的处理从很小到非常大的项目版本管理。也就是用来管理你的hexo博客文章，上传到GitHub的工具。Git非常强大，我觉得建议每个人都去了解一下。廖雪峰老师的Git教程写的非常好，大家可以了解一下。<a href="https://link.zhihu.com/?target=https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000">Git教程</a></p><p>windows：到git官网上下载,Download git,下载后会有一个Git Bash的命令行工具，以后就用这个工具来使用git。</p><p>安装好后，用git –version 来查看一下版本</p><h3 id="2-安装nodejs"><a href="#2-安装nodejs" class="headerlink" title="2. 安装nodejs"></a>2. 安装nodejs</h3><p>Hexo是基于nodeJS编写的，所以需要安装一下nodeJs和里面的npm工具。</p><p>windows：<a href="https://nodejs.org/en/download/">nodejs</a>选择LTS版本就行了。<br>linux：<br><code>sudo apt-get install nodejs</code><br><code>sudo apt-get install npm</code></p><p>安装完后，打开命令行<br><code>node -v</code><br><code>npm -v</code></p><p>检查一下有没有安装成功</p><p>顺便说一下，windows在git安装完后，就可以直接使用git bash来敲命令行了，不用自带的cmd，cmd有点难用</p><h3 id="3-安装hexo"><a href="#3-安装hexo" class="headerlink" title="3. 安装hexo"></a>3. 安装hexo</h3><p>前面git和nodejs安装好后，就可以安装hexo了，你可以先创建一个文件夹blog，然后cd到这个文件夹下（或者在这个文件夹下直接右键git bash打开）。</p><p>输入命令<br><code>npm install -g hexo-cli</code></p><p>依旧用hexo -v查看一下版本<br>至此就全部安装完了。<br>接下来初始化一下hexo</p><p><code>hexo init myblog</code><br>这个myblog可以自己取什么名字都行，然后<br><code>cd myblog //进入这个myblog文件夹</code><br><code>npm install</code></p><ul><li>新建完成后，指定文件夹目录下有：</li><li>node_modules: 依赖包</li><li>public：存放生成的页面</li><li>scaffolds：生成文章的一些模板</li><li>source：用来存放你的文章</li><li>themes：主题</li><li>** _config.yml: 博客的配置文件**</li></ul><p><code>hexo g</code><br><code>hexo serve</code></p><p>打开hexo的服务，在浏览器输入localhost:4000就可以看到你生成的博客了。<br>大概长这样：<br><img src="https://pic1.zhimg.com/v2-d301dfbac9165b21ab1ee0a860f44de4_r.jpg" alt="wait"><br>使用ctrl+c可以把服务关掉。</p><h3 id="4-GitHub创建个人仓库"><a href="#4-GitHub创建个人仓库" class="headerlink" title="4. GitHub创建个人仓库"></a>4. GitHub创建个人仓库</h3><p>首先，你先要有一个GitHub账户，去注册一个吧。<br>注册完登录后，在<a href="http://github.com/">Github.com</a>中看到一个New repository，新建仓库<br><img src="https://pic3.zhimg.com/v2-4387cb776ccc72189bc06fd511c1e19e_r.jpg" alt="wait"></p><p>创建一个和你用户名相同的仓库，后面加github.io,只有这样，将来要部署到GitHub page的时候，才会被识别，也就是xxxx.github.io，其中xxx就是你注册GitHub的用户名。我这里是已经建过了。<br><img src="https://pic3.zhimg.com/v2-9d5692a0e62fd62f902f1085348f5e7e_r.jpg" alt="wait"><br>点击create repository。</p><h3 id="5-生成SSH添加到GitHub"><a href="#5-生成SSH添加到GitHub" class="headerlink" title="5. 生成SSH添加到GitHub"></a>5. 生成SSH添加到GitHub</h3><p>回到你的git bash中<br><code>git config --global user.name &quot;yourname&quot;</code><br><code>git config --global user.email &quot;youremail&quot;</code><br>这里的yourname输入你的GitHub用户名，youremail输入你GitHub的邮箱。这样GitHub才能知道你是不是对应它的账户。</p><p>可以用以下两条，检查一下你有没有输对<br><code>git config user.name</code><br><code>git config user.email</code></p><p>然后创建SSH,一路回车<br><code>ssh-keygen -t rsa -C &quot;youremail&quot;</code></p><p>这个时候它会告诉你已经生成了.ssh的文件夹。在你的电脑中找到这个文件夹。<br><img src="https://pic3.zhimg.com/v2-a9593147853b8f2485f05d1f04d45bb6_r.jpg" alt="wait"><br>ssh，简单来讲，就是一个秘钥，其中，id_rsa是你这台电脑的私人秘钥，不能给别人看的，id_rsa.pub是公共秘钥，可以随便给别人看。把这个公钥放在GitHub上，这样当你链接GitHub自己的账户时，它就会根据公钥匹配你的私钥，当能够相互匹配时，才能够顺利的通过git上传你的文件到GitHub上。</p><p>而后在GitHub的setting中，找到SSH keys的设置选项，点击New SSH key 把你的id_rsa.pub里面的信息复制进去。<br><img src="https://pic3.zhimg.com/v2-aad16de6208ce8a7b2cd51b16a1b2aa2_r.jpg" alt="wait"><br>在gitbash中，查看是否成功<br><code>ssh -T git@github.com</code></p><h3 id="6-将hexo部署到GitHub"><a href="#6-将hexo部署到GitHub" class="headerlink" title="6.将hexo部署到GitHub"></a>6.将hexo部署到GitHub</h3><p>这一步，我们就可以将hexo和GitHub关联起来，也就是将hexo生成的文章部署到GitHub上，打开站点配置文件 _config.yml，翻到最后，修改为 YourgithubName就是你的GitHub账户</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-attribute">deploy</span>:<br>  <span class="hljs-attribute">type</span>: git<br>  <span class="hljs-attribute">repo</span>: <span class="hljs-attribute">https</span>:<span class="hljs-comment">//github.com/YourgithubName/YourgithubName.github.io.git</span><br>  <span class="hljs-attribute">branch</span>: master<br></code></pre></td></tr></table></figure><p>这个时候需要先安装deploy-git ，也就是部署的命令,这样你才能用命令部署到GitHub。<br><code>npm install hexo-deployer-git --save</code><br>然后</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs verilog">hexo clean<br>hexo <span class="hljs-keyword">generate</span><br>hexo deploy<br></code></pre></td></tr></table></figure><p>其中 hexo clean清除了你之前生成的东西，也可以不加。 hexo generate 顾名思义，生成静态文章，可以用 hexo g缩写 hexo deploy 部署文章，可以用hexo d缩写</p><p>注意deploy时可能要你输入username和password。</p><p>得到下图就说明部署成功了，过一会儿就可以在<a href="http://yourname.github.io/">http://yourname.github.io</a> 这个网站看到你的博客了！！</p><p><img src="https://pic4.zhimg.com/v2-8fb2b2026aa0a748594642bb0f53f72b_r.jpg" alt="wait"></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
